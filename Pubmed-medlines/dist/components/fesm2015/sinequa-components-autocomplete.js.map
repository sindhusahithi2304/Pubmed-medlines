{"version":3,"file":"sinequa-components-autocomplete.js","sources":["../projects/components/autocomplete/bootstrap/autocomplete-list/autocomplete-list.html","../projects/components/autocomplete/bootstrap/autocomplete-list/autocomplete-list.ts","../../projects/components/autocomplete/bootstrap/field-search-items.component.ts","../../../projects/components/autocomplete/suggest.service.ts","../../../projects/components/autocomplete/autocomplete.directive.ts","../../../projects/components/autocomplete/autocomplete-field-search.directive.ts","../../projects/components/autocomplete/bootstrap/autocomplete.module.ts","../../../projects/components/autocomplete/sinequa-components-autocomplete.ts"],"sourcesContent":["<div class=\"sq-autocomplete-list card position-absolute\" *ngIf=\"hasItems\" (mousedown)=\"_mouseDown($event)\">\n    <div class=\"list-group list-group-flush\">\n        <a  href=\"#\" (click)=\"_itemClicked(item, $event)\"\n            *ngFor=\"let item of _items; let i = index\"\n            class=\"list-group-item list-group-item-action p-0 border-0\" \n            [ngClass]=\"{'list-group-item-primary': _isSelected(item, i)}\"\n            [sqScrollIntoView]=\"{active: _isSelected(item, i), first: i === 0}\">\n            <ng-container *ngIf=\"itemTpl\">\n                <ng-container *ngTemplateOutlet=\"itemTpl; context:{$implicit: item}\"></ng-container>\n            </ng-container>\n        </a>\n    </div>\n    <div class=\"card-footer\" *ngIf=\"footerTpl\">\n        <ng-container *ngTemplateOutlet=\"footerTpl; context:{$implicit: _items}\"></ng-container>\n    </div>\n</div>","import {Output, ContentChild, TemplateRef, Component, EventEmitter, ChangeDetectorRef} from \"@angular/core\";\nimport {AutocompleteItem, AutocompleteComponent} from \"../../autocomplete.directive\";\n\n@Component({\n    selector: \"sq-autocomplete-list\",\n    templateUrl: \"./autocomplete-list.html\",\n    styleUrls: [\"./autocomplete-list.css\"]\n})\nexport class BsAutocompleteList implements AutocompleteComponent {\n\n    /**\n     * Template for the display of AutocompleteItem items, passed by transclusion\n     */\n    @ContentChild(\"itemTpl\", {static: false}) itemTpl: TemplateRef<any>;\n\n    /**\n     * Optional footer template, passed by transclusion\n     */\n    @ContentChild(\"footerTpl\", {static: false}) footerTpl: TemplateRef<any>;\n\n    /**\n     * Event emitter for clicks on an autocomplete item\n     */\n    @Output() clicked = new EventEmitter<AutocompleteItem>();\n\n    _active: boolean = false;\n    _items: AutocompleteItem[] | undefined;\n\n    _cursor: number = -1;\n\n\n    constructor(\n        private changeDetectorRef: ChangeDetectorRef){\n    }\n\n\n    /**\n     * Update the data and state of this component\n     * @param active whether the component should be displayed\n     * @param items The list of items to display\n     */\n    public update(active: boolean, items?: AutocompleteItem[]){\n        //console.log(\"autocomplete update \", active, items);\n        this._active = active;\n        this._items = items;\n        this._cursor = -1;\n\n        this.changeDetectorRef.markForCheck();\n    }\n\n    /**\n     * Whether there are any item to display\n     */\n    public get hasItems(): boolean {\n        return this._active && !!this._items && this._items.length > 0;\n    }\n\n    /**\n     * Returns the currently selected item, if any\n     */\n    public get selectedValue(): AutocompleteItem | undefined {\n        if(this._items && this._cursor >= 0 && this._cursor < this._items.length)\n            return this._items[this._cursor];\n        return undefined;\n    }\n\n    /**\n     * Select the next item in the list and returns it\n     */\n    public selectNext(): AutocompleteItem | undefined {\n        if (this._items && this._cursor < this._items.length-1) {\n            this._cursor++;\n        }\n        return this.selectedValue;\n    }\n\n    /**\n     * Select the previous item in the list and returns it\n     */\n    public selectPrevious(): AutocompleteItem | undefined {\n        if(this._cursor > 0)\n            this._cursor--;\n        return this.selectedValue;\n    }\n\n    /**\n     * Test whether an item is selected\n     * @param item\n     * @param i\n     */\n    _isSelected(item: AutocompleteItem, i: number): boolean {\n        return this._cursor === i;\n    }\n\n    /**\n     * Listen to click events and emits events\n     * @param item\n     * @param event\n     */\n    _itemClicked(item: AutocompleteItem, event){\n        this.clicked.next(item);\n        event.stopPropagation();\n        return false;\n    }\n\n    /**\n     * This prevents the focus to be removed from the <input>, which clauses the dropdown\n     */\n    _mouseDown(event){\n        event.preventDefault();\n    }\n\n}","import { Component, EventEmitter, Output, ChangeDetectorRef } from '@angular/core';\nimport { AutocompleteItem } from '../autocomplete.directive';\nimport { FieldSearchItemsContainer } from '../autocomplete-field-search.directive';\n\n@Component({\n    selector: \"sq-field-search-items\",\n    template: `\n<span *ngFor=\"let item of items\" class=\"badge badge-pill badge-info align-self-center mr-1\" [ngClass]=\"item.category\">\n    {{item.display}} <span class=\"fas fa-times-circle clickable\" (click)=\"removeItem(item)\"></span>\n</span>\n`,\n    styles: [`\n:host {\n    display: flex;\n}\n.clickable {\n    cursor: pointer;\n}\n.clickable:hover {\n    opacity: 85%;\n}\n`]\n})\nexport class BsFieldSearchItemsComponent implements FieldSearchItemsContainer {\n    @Output() itemRemoved = new EventEmitter<AutocompleteItem>();\n\n    items: AutocompleteItem[] = [];\n\n    constructor(protected changeDetectorRef: ChangeDetectorRef) {\n    }\n\n    update(items: AutocompleteItem[]): void {\n        this.items = items;\n        this.changeDetectorRef.markForCheck();\n    }\n\n    removeItem(item: AutocompleteItem) {\n        this.itemRemoved.next(item);\n        this.changeDetectorRef.markForCheck();\n    }\n\n}\n","import {Injectable} from \"@angular/core\";\nimport {Observable, of} from \"rxjs\";\nimport {map, flatMap} from \"rxjs/operators\";\nimport {Utils} from \"@sinequa/core/base\";\nimport {SuggestQueryWebService, SuggestFieldWebService, Suggestion, EngineType} from \"@sinequa/core/web-services\";\nimport {AppService, Query} from \"@sinequa/core/app-utils\";\nimport {AutocompleteItem} from './autocomplete.directive';\n\n@Injectable({\n    providedIn: \"root\"\n})\nexport class SuggestService {\n\n    fieldCategory: string;\n\n    constructor(\n        private suggestQueryWebService: SuggestQueryWebService,\n        private suggestFieldWebService: SuggestFieldWebService,\n        private appService: AppService) {\n        this.fieldCategory = \"$field$\";\n    }\n\n    private addFields(text: string, suggests: Suggestion[]) {\n        if (text.includes(\" \")) {\n            return;\n        }\n        for (const field of this.appService.fields) {\n            if (Utils.startsWith(field, text)) {\n                suggests.unshift({\n                    category: this.fieldCategory,\n                    display: field\n                });\n            }\n        }\n    }\n\n    get(suggestQuery: string, text: string, fields?: string | string[], query?: Query): Observable<Suggestion[]> {\n        if (!this.appService.ccquery) {\n            return of([]);\n        }\n        const observable = this.suggestQueryWebService.get(suggestQuery, text, this.appService.ccquery.name, fields);\n        return observable.pipe(\n            flatMap(suggests => {\n                if (!fields) {\n                    if (!suggests) {\n                        suggests = [];\n                    }\n                    this.addFields(text, suggests);\n                }\n                else {\n                    if (!suggests || suggests.length === 0) {\n                        const _fields = Utils.isArray(fields) ? fields : [fields];\n                        fields = [];\n                        for (const field of _fields) {\n                            const column = this.appService.getColumn(field);\n                            if (!!column && (column.eType === EngineType.csv || AppService.isScalar(column))) {\n                                fields.push(field);\n                            }\n                        }\n                        if (fields.length > 0) {\n                            return this.suggestFieldWebService.get(text, fields, query).pipe(\n                                map((suggests) => {\n                                    suggests.forEach(value => value.display = Utils.toSqlValue(value.display)); // because dates get automatically converted by the interceptor\n                                    return suggests;\n                                }));\n                        }\n                    }\n                }\n                return of(suggests);\n            }));\n    }\n\n\n    /**\n     * Search for the input text in a list of objects and return autocomplete items asynchronously\n     * @param query The text to search for\n     * @param data The list of objects\n     * @param primaryText A function that returns the primary text input given the object\n     * @param secondaryText An (optional) function that returns a list of secondary text inputs given the object\n     */\n    public async searchData<T>(\n        category: string,\n        query: string,\n        data: T[],\n        primaryText: (obj:T) => string,\n        secondaryText?: (obj:T) => string[],\n        label?: string) : Promise<AutocompleteItem[]> {\n\n        return data\n            .map(obj => SuggestService.findMatch(primaryText(obj), query,\n                !!secondaryText ? secondaryText(obj) : [], obj)) // Look for matches in all saved queries\n            .filter(item => !!item) // Keep only the matches\n            .sort((a,b) => b!.score - a!.score) // Sort by decreasing score\n            .map(item => {\n                item = item!;\n                return {    // Make an autocomplete item\n                    display: item.display,\n                    displayHtml: item.displayHtml,\n                    category,\n                    label: label || category,\n                    data: item.data,\n                    score: item.score\n                };\n            } );\n    }\n\n    /**\n     * Searches for the query string inside a given text. Returns a match object containing:\n     * - a score proportional to the number and quality of matches\n     * - the text formatted as HTML with the query found in the text\n     * @param text The text to search\n     * @param query The string to search for\n     * @param secondaryText Secondary fields to search input, with less importance than the primary field\n     * @param data A data object to be included in the match object (for convenience mostly)\n     */\n    public static findMatch(text: string, query: string, secondaryText?: string[], data?: any): {display: string, displayHtml: string, score: number, data?:any} | undefined {\n\n        if(!text || !query){\n            return undefined;\n        }\n\n        // pass text and query in lower case and no accent to make search case insensitive\n        const textLower = Utils.removeAccents(text.toLowerCase());\n        query = Utils.removeAccents(query.toLowerCase());\n        let i = 0;\n        const matches: number[] = [];\n        let score = 0;\n\n        // Compute score of the match\n        i = textLower.indexOf(query);\n        while(i !== -1){    // While there's a match\n            matches.push(i);\n            if(i === 0){    // Start of the text\n                score += 4;\n            }\n            else if(textLower[i-1] === \" \"){ // Start of a word\n                score += 2;\n            }\n            else {\n                score += 1; // Middle of a word\n            }\n            i = textLower.indexOf(query, i+query.length);\n        }\n\n        // Format HTML display\n        let html = text;\n        for(let j=matches.length-1; j>=0; j--) { // decreasing order so the indices remain valid\n            i = matches[j];\n            html = html.slice(0, i).concat(\"<strong>\", html.slice(i, i+query.length), \"</strong>\", html.slice(i+query.length));\n        }\n\n        // Secondary text\n        if(secondaryText) {\n            secondaryText\n                .map(t => this.findMatch(t, query)) // Search each secondary text for matches\n                .filter(item => !!item) // Keep only the matches\n                .sort((a,b) => b!.score - a!.score) // Sort by decreasing score\n                .forEach(match => {\n                    match = match!;\n                    score += match.score / 2;  // Secondary matches added to the score, but count half\n                    html += \" <small>\" + match.displayHtml + \"</small>\"; // Concatenate secondary match html to the main html\n                });\n        }\n\n        if(score > 0){\n            return {\n                display: text,\n                displayHtml: html,\n                score: score,\n                data: data\n            };\n        }\n        return undefined;\n    }\n}","import {Directive, Input, Output, ElementRef, HostListener, OnInit, EventEmitter, OnDestroy, OnChanges, SimpleChanges, HostBinding} from \"@angular/core\";\nimport {Observable, Subscription} from \"rxjs\";\nimport {Utils, Keys} from \"@sinequa/core/base\";\nimport {AppService} from \"@sinequa/core/app-utils\";\nimport {SuggestService} from \"./suggest.service\";\nimport {UIService} from \"@sinequa/components/utils\";\n\n/**\n * Minimal interface for autocomplete items (note that the Suggestion\n * objects returned by the Suggestion service implement naturally this\n * interface)\n */\nexport interface AutocompleteItem {\n    display: string;\n    normalized?: string;\n    category: string;\n    label?: string;\n}\n\n/**\n * Interface required to be implemented by the dropdown components\n * binded to this autocomplete directive.\n * The component is responsible for displaying a list of items\n * and signaling back if a component was clicked. The component must\n * also manage navigation through the list (next/previous and selectedValue).\n */\nexport interface AutocompleteComponent {\n\n    /**\n     * Whether there are any item to display\n     */\n    hasItems: boolean;\n\n    /**\n     * Event emitter for clicks on an autocomplete item\n     */\n    clicked: EventEmitter<AutocompleteItem>;\n\n    /**\n     * Returns the currently selected item, if any\n     */\n    selectedValue: AutocompleteItem | undefined;\n\n    /**\n     * Update the data and state of this component\n     * @param active whether the component should be displayed\n     * @param items The list of items to display\n     */\n    update(active: boolean, items?: AutocompleteItem[]): void;\n\n    /**\n     * Select the next item in the list and returns it\n     */\n    selectNext(): AutocompleteItem | undefined;\n\n    /**\n     * Select the previous item in the list and returns it\n     */\n    selectPrevious(): AutocompleteItem | undefined;\n}\n\n/**\n * States in which the autocomplete component can be\n */\nexport enum AutocompleteState {\n    OFF = \"OFF\", // Autocomplete is turned off (via @Input())\n    INIT = \"INIT\", // Input is not focused, dropdown is closed\n    START = \"START\", // Input is focused, no text typed in, dropdown is closed\n    ACTIVE = \"ACTIVE\", // Input is focused, text is typed, suggests are being queried, dropdown is closed\n    OPENED = \"OPENED\", // Input is focused, text is typed, suggests are available, dropdown/autocomplete component is displayed\n    SELECTED = \"SELECTED\" // Input is focused, an input from the dropdown was selected\n}\n\n@Directive({\n    selector: \"[sqAutocomplete]\"\n})\nexport class Autocomplete implements OnInit, OnChanges, OnDestroy {\n\n    /** Reference to the AutocompleteComponent that displays the autocomplete items */\n    @Input() dropdown: AutocompleteComponent;\n\n    /** Whether the autocomplete should be active or not */\n    @Input() off: boolean;\n\n    /** Debounce delay between autocomplete queries */\n    @Input() suggestDelay: number = 200;\n\n    /** Name of the Suggest Query to be used */\n    @Input() suggestQuery: string;\n\n    /** Custom placeholder */\n    @Input() placeholder: string = '';\n\n    @HostBinding('attr.placeholder') _placeholder;\n\n    // Event emitters\n\n    @Output() stateChange = new EventEmitter<AutocompleteState>();\n    @Output() submit = new EventEmitter<void>();\n\n    private _state: AutocompleteState = AutocompleteState.INIT;\n\n    // The input HTML element to which this directive is attached\n    protected readonly inputElement: HTMLInputElement;\n\n\n    // Initialization\n\n    constructor(\n        elementRef: ElementRef,\n        protected suggestService: SuggestService,\n        protected appService: AppService,\n        protected uiService: UIService){\n\n        this.inputElement = elementRef.nativeElement;\n    }\n\n\n    /**\n     * On initialization, we listen to the autocomplete component for\n     * selection events\n     */\n    ngOnInit(){\n        this._dropdownSubscription = this.dropdown.clicked.subscribe(item => {\n            this.select(item, true);  // An item was selected from the autocomplete => take the value\n        });\n\n        this._placeholder = this.placeholder;\n        this.inputElement.focus();\n        this.start();\n    }\n\n    /**\n     * If the off input changes state, react accordingly\n     * @param changes\n     */\n    ngOnChanges(changes: SimpleChanges){\n        // Turn on the autocomplete\n        if(changes[\"off\"] && !this.off){\n            this.start();\n        }\n    }\n\n\n    protected _dropdownSubscription: Subscription;\n    /**\n     * Unsubscribe when destroying the component\n     */\n    ngOnDestroy(){\n        if(this._dropdownSubscription){\n            this._dropdownSubscription.unsubscribe();\n        }\n    }\n\n\n    // Getters and Setters\n\n    /**\n     * Return the current state of the autocomplete\n     */\n    public getState(): AutocompleteState {\n        return this._state;\n    }\n\n    /**\n     * Set the current state of the autocomplete\n     */\n    protected setState(state: AutocompleteState) {\n        if(this.off){\n            if(this._state !== AutocompleteState.OFF){\n                this._state = AutocompleteState.OFF;\n                this.stateChange.next(this.getState());\n            }\n            // ignore state change if Autocomplete is off\n        }\n        else if(!!state && this._state !== state) {\n            this._state = state;\n            //console.log(\"STATE: \", this._state);\n            this.stateChange.next(this.getState());\n        }\n    }\n\n    /**\n     * Get the current text value of the HTML <input>\n     * to which this directive is attached\n     */\n    protected getInputValue() : string {\n        return this.inputElement.value;\n    }\n\n    /**\n     * Set the current text value of the HTML <input>\n     * to which this directive is attached\n     */\n    protected setInputValue(value: string) {\n        // Using setCaret() allows to properly update the underlying form\n        this.uiService.setCaret(this.inputElement, 0, -1, value); // 0, -1 erases the current value and writes the new one\n    }\n\n    /**\n     * Sets the content of the <input> based on the given\n     * Autocomplete Item (various implementations are possible,\n     * depending on the item content and nature).\n     * This would be the right method to override to implement\n     * fielded search autocomplete.\n     * @returns true if this autocomplete item should be searched\n     */\n    protected setAutocompleteItem(item: AutocompleteItem): boolean {\n        if(item) {\n            this.setInputValue(item.display);\n            return true;\n        }\n        return false;\n    }\n\n\n    // Methods triggering state changes\n\n    /**\n     * INIT state (Input is not focused, dropdown is closed)\n     */\n    protected init(): void {\n        this.setState(AutocompleteState.INIT);\n        this.dropdown.update(false);    // If the dropdown was active\n    }\n\n    /**\n     * START state (Input is focused, no text typed in, dropdown is closed)\n     */\n    protected start(): void {\n        this.setState(AutocompleteState.START);\n        this.dropdown.update(false);    // If the dropdown was active\n    }\n\n    /**\n     * START state and if the <input> has content, immediately switch to ACTIVE\n     */\n    protected startOrActive(): void {\n        if(this.getState()!== AutocompleteState.ACTIVE && this.getState()!== AutocompleteState.OPENED){ // Avoid flickering\n            this.start();\n            if(!!this.getInputValue()){\n                this.active();\n            }\n        }\n    }\n\n    /**\n     * ACTIVE state (Input is focused, text is typed, suggests are being queried, dropdown is closed)\n     */\n    protected active(): void {\n        if(this.getState() === AutocompleteState.START || this.getState() === AutocompleteState.ACTIVE || this.getState() === AutocompleteState.OPENED){\n            this.setState(AutocompleteState.ACTIVE);\n            this.dropdown.update(false);    // If the dropdown was active\n            this.suggest();\n        }\n    }\n\n    /**\n     * Select the given autocomplete suggestion for search\n     * @param submit if, true also trigger a submit\n     * @param item a specific item to submit\n     */\n    protected select(item: AutocompleteItem, submit?: boolean): void {\n        this.setState(AutocompleteState.SELECTED); // Change state BEFORE setting input value, so the event is correctly processed\n        const searchable = this.setAutocompleteItem(item);\n        this.dropdown.update(false);    // Close dropdown\n\n        if(submit && searchable) this.submit.next();\n    }\n\n    /**\n     * Switch to OPENED state (from ACTIVE only)\n     */\n    protected open(): void {\n        if(this.getState() === AutocompleteState.ACTIVE){\n            this.setState(AutocompleteState.OPENED);\n        }\n    }\n\n    /**\n     * Request suggestions from the server, and update the dropdown contents\n     * and autocomplete state asynchronously.\n     * Override this method for a synchronous implementation.\n     */\n    protected suggest() {\n        this.debounceSuggest();\n    }\n\n    /**\n     * Actually makes the API call to the suggestService to retrieve suggestions\n     * and process them.\n     */\n    protected getSuggests() {\n        const value = this.getInputValue();\n        if(value) { // If there is text, make a call to the suggest API\n            this.processSuggests(\n                this.getSuggestsObs(value)\n            );\n        }\n        else {  // If empty input, restart autocomplete\n            this.start();\n        }\n    }\n\n    /**\n     * Returns an observable of Suggestions, given some input text\n     * @param value input text for which to return suggestions\n     */\n    protected getSuggestsObs(value: string, fields?: string[]): Observable<AutocompleteItem[]> {\n        return this.suggestService.get(this.suggestQuery, value, fields);\n    }\n\n    /**\n     * Process suggestions obtained (from whatever mean):\n     * - If data available, filter out fields\n     * - update the dropdown content\n     * - Switch between OPEN and ACTIVE states\n     * - Use changeDetectorRef to update display\n     * @param obs an observable of AutocompleteItem suggestions\n     */\n    protected processSuggests(obs: Observable<AutocompleteItem[]>){\n        obs.subscribe(\n            suggests => {\n                if(this.getState() === AutocompleteState.ACTIVE || this.getState() === AutocompleteState.OPENED){\n                    this.dropdown.update(true, suggests\n                        .filter(item => item.category !== \"$field$\")  // Filter out fields\n                        .map(item => {\n                            if(!item.label){\n                                item.label = this.appService.getLabel(item.category);\n                            }\n                            return item;\n                        }));\n                }\n            },\n            err => {\n                this.dropdown.update(false);\n            },\n            () => {\n                if(this.dropdown.hasItems && this.getState() === AutocompleteState.ACTIVE){\n                    this.open();    // Switch from ACTIVE to OPENED (if not already)\n                }\n                else if(!this.dropdown.hasItems && this.getState() === AutocompleteState.OPENED){   // No data\n                    this.active();  // Switch from OPENED to ACTIVE (if not already)\n                }\n            });\n    }\n\n    /**\n     * Use the suggest service to retrieve suggestions given the input text.\n     * The suggest (autocomplete) query is debounded to avoid flooding the server.\n     */\n    private readonly debounceSuggest: () => void = Utils.debounce(() => {\n        this.getSuggests();\n    }, this.suggestDelay);\n\n\n    /**\n     * Returns the caret position within the input\n     */\n    protected getInputPosition(): number {\n        // Come back before trailing spaces so the preceding value is still seen as the input value\n        // (needed for ExprParser to stop autocomplete being cancelled on entering trailing spaces)\n        const position = this.uiService.getCaret(this.inputElement).start;\n        const length = Utils.len(Utils.trimEnd(this.getInputValue()));\n        return Math.min(position, length);\n    }\n\n    /**\n     * The following are event listeners applied to the <input> host component\n     * onto which this directive is applied.\n     * The events affect the state of the autocomplete, which triggers\n     * various actions (call to suggest API, etc.).\n     */\n\n    /**\n     * Listens to click events on the <input> host\n     */\n    @HostListener(\"click\") click() {\n        //console.log(\"input clicked\");\n        this.startOrActive();\n    }\n\n    /**\n     * Listens to touchstart events (mobile clicks) on the <input> host\n     */\n    @HostListener(\"touchstart\") touchstart() {\n        //console.log(\"input touchstart\");\n        this.startOrActive();\n    }\n\n    /**\n     * Listens to focus events on the <input> host\n     */\n    @HostListener(\"focus\") focus() {\n        //console.log(\"input focus gained\");\n        this.start();\n    }\n\n    /**\n     * Listens to blur events (out of focus) on the <input> host\n     */\n    @HostListener(\"blur\", [\"$event\"]) blur(event: FocusEvent) {\n        //console.log(\"input focus lost\");\n        this.init();\n    }\n\n    /**\n     * Listen to any change in the <input> content and react\n     * according to the current state of the autocomplete\n     * @param event\n     */\n    @HostListener(\"input\", [\"$event\"]) inputChanged(event: Event) {\n        //console.log(\"input value changed\");\n        switch(this.getState()){\n            case AutocompleteState.OPENED:\n                this.suggest(); // Just request more data, but no state change\n                break;\n            case AutocompleteState.START:\n            case AutocompleteState.ACTIVE:\n                this.active(); // get more data, and change state if not already ACTIVE\n                break;\n            case AutocompleteState.SELECTED:\n                this.start(); // The model changed because we selected a value ==> we restart in case the user keeps typing\n                break;\n            case AutocompleteState.INIT:\n                console.error(\"Should not be in INIT state if the form changes\");\n                break;\n        }\n    }\n\n    /**\n     * Listen to user's keyboard actions in the <input>, in order to navigate\n     * and select the autocomplete suggestions.\n     * @param event the keyboard\n     */\n    @HostListener(\"keydown\", [\"$event\"]) keydown(event: KeyboardEvent) {\n        // Navigation in the opened dropdown\n        if (this.getState() === AutocompleteState.OPENED) {\n            switch (event.keyCode) {\n                case Keys.up:\n                    this.dropdown.selectPrevious();\n                    return false; // prevent default\n                case Keys.down:\n                    this.dropdown.selectNext();\n                    return false; // prevent default\n                case Keys.tab:\n                    if(!!this.dropdown.selectedValue){\n                        this.select(this.dropdown.selectedValue);\n                    } else {\n                        this.dropdown.selectNext();\n                    }\n                    return false; // prevent default (change focus)\n                case Keys.esc:\n                    this.start(); // Just restart the autocomplete\n                    //event.stopPropagation(); // needed?\n                    return false; // prevent default\n                case Keys.enter:\n                    if(!!this.dropdown.selectedValue){\n                        this.select(this.dropdown.selectedValue, true);\n                        //event.stopPropagation(); // needed?\n                        return false; // prevent default action (auto submit)\n                    }\n            }\n        }\n\n        // If a search was triggered, restart the autocomplete\n        if(event.keyCode === Keys.enter) {\n            this.submit.next();\n            this.start();\n        }\n        return undefined;\n    }\n}\n","import { Directive, Input, Output, EventEmitter, SimpleChanges, ElementRef, OnChanges, OnDestroy } from \"@angular/core\";\nimport { Observable, Subscription, of } from \"rxjs\";\nimport { Utils, Keys} from \"@sinequa/core/base\";\nimport { AppService, Expr, ExprBuilder, ExprParser, ExprValueInfo} from \"@sinequa/core/app-utils\";\nimport { Autocomplete, AutocompleteItem, AutocompleteState } from './autocomplete.directive';\nimport { SuggestService } from './suggest.service';\nimport { UIService } from '@sinequa/components/utils';\n\n/**\n * Interface required to be implement by the component displaying\n * the fielded search items (basically the content of fieldSearchItems)\n */\nexport interface FieldSearchItemsContainer {\n\n    /** Update the list of items displayed by the container */\n    update(items: AutocompleteItem[]): void;\n\n    /** Event triggered when the user removes an item from the container */\n    itemRemoved: EventEmitter<AutocompleteItem>;\n}\n\nexport interface ParseResult {\n    result?: Expr;\n    error?: string;\n}\n\n@Directive({\n    selector: \"[sqAutocompleteFieldSearch]\"\n})\nexport class AutocompleteFieldSearch extends Autocomplete implements OnChanges, OnDestroy {\n\n\n    // FIELDED SEARCH\n\n    /** \n     * \"text\" mode: fielded search is entirely managed as text in the <input> component \n     * \"selects\" mode: fielded search stores the selected autocomplete items to create selections, while keeping a clean <input> content (better UI/UX but does not support operators like OR, NOT, and parentheses)\n     */\n    @Input() fieldSearchMode: \"off\" | \"text\" | \"selects\" = \"text\";\n\n    /** Fields excluded from fielded search (searched as regular strings if selected) */\n    @Input() excludedFields: string[] = [\"concepts\"];\n\n    /* Fields included in fielded search (have precedence over excluded fields) */\n    @Input() includedFields?: string[];\n\n   /** Container displaying the fieldSearchItems (only needed if mode === \"selects\") */\n    @Input() fieldSearchItemsContainer?: FieldSearchItemsContainer;\n\n    /** Current selection expression needed to update the list of field search items if mode === \"selects\" */\n    @Input() fieldSearchExpression?: string;\n \n    /** Stores the selected fielded search items selected via Tab */\n    public readonly fieldSearchItems: AutocompleteItem[] = [];\n\n\n    // Event emitters\n\n    @Output() parse = new EventEmitter<ParseResult>();\n\n    constructor(elementRef: ElementRef<any>, \n        suggestService: SuggestService,\n        appService: AppService,\n        uiService: UIService,\n        protected exprBuilder: ExprBuilder){\n        super(elementRef, suggestService, appService, uiService);\n    }\n\n\n    /**\n     * If the off input changes state, react accordingly\n     * @param changes\n     */\n    ngOnChanges(changes: SimpleChanges){\n        super.ngOnChanges(changes);\n\n        // Subscribe to the field search items's container\n        if(changes[\"fieldSearchItemsContainer\"] && this.fieldSearchItemsContainer) {\n            if(this._fieldSearchSubscription){\n                this._fieldSearchSubscription.unsubscribe();\n            }\n            this._fieldSearchSubscription = this.fieldSearchItemsContainer.itemRemoved.subscribe(item => {\n                this.fieldSearchItems.splice(this.fieldSearchItems.indexOf(item), 1);\n                this.updatePlaceholder();\n                this.submit.next();\n            });\n        }\n\n        // Transform the field search expresion (Expr string) into a list of autocomplete items displayed in the field search container\n        if(changes[\"fieldSearchExpression\"] && this.fieldSearchMode === \"selects\") {\n            if(this.fieldSearchExpression) {\n                const expr = this.appService.parseExpr(this.fieldSearchExpression);\n                if(expr instanceof Expr && this.fieldSearchItems.length !== expr.getFields().length) {\n                    this.fieldSearchItems.splice(0);\n                    if(expr.and) {\n                        expr.operands.forEach(e => \n                            this.fieldSearchItems.push(this.exprToItem(e))\n                        );\n                    }\n                    else {\n                        this.fieldSearchItems.push(this.exprToItem(expr));\n                    }\n                }\n            }\n            else {\n                this.fieldSearchItems.splice(0);\n            }\n        }\n\n        // If fieldSearchMode changes from selects to something else, we must remove the field search items\n        if(changes[\"fieldSearchMode\"] && this.fieldSearchMode !== \"selects\" && this.fieldSearchItems.length > 0) {\n            this.fieldSearchItems.splice(0);\n        }\n\n        this.updatePlaceholder();\n        this.fieldSearchItemsContainer?.update(this.fieldSearchItems);\n    }\n\n\n    private _fieldSearchSubscription: Subscription;\n    /**\n     * Unsubscribe when destroying the component\n     */\n    ngOnDestroy(){\n        super.ngOnDestroy();\n        if(this._fieldSearchSubscription){\n            this._fieldSearchSubscription.unsubscribe();\n        }\n    }\n\n    /**\n     * Insert the given autocomplete item into the current search input\n     * at the right location\n     * @param item \n     */\n    protected insertAutocompleteItem(item: AutocompleteItem): boolean {\n        const value = this.getInputValue(); // Current text in the input\n        if(value) { // There should always be text\n            const parseResult = this.parseQuery(); // Parse the current text\n            if(parseResult.result) { // (if no result, a parsing error occurred)\n                const res = parseResult.result.findValue(this.getInputPosition()); // Get the expression at the caret location\n                // Autocomplete \"compa\" => \"company:\"\n                if(res && item.category === \"$field$\") {\n                    this.replaceValueInForm(res, item.display + \": \");\n                    return false;\n                }\n                // Autocomplete \"company:Goo\" => \"company:`GOOGLE`\"\n                if(res && res.field === item.category) {\n                    this.replaceValueInForm(res, ExprParser.escape(item.normalized || item.display));\n                    return true;\n                }\n                // Autocomplete \"Goo\" => \"company:`GOOGLE`\"\n                if(res && !res.field && item.category && \n                    (this.includedFields && this.includedFields?.includes(item.category) || \n                    (!this.includedFields && !this.excludedFields?.includes(item.category)))) { // Filter out fields if not in fieldSearch mode\n                    this.replaceValueInForm(res, this.exprBuilder.makeExpr(item.category, item.normalized || item.display));\n                    return true;\n                }\n                // Autocomplete \"Search eng\" => \"Search engine\"\n                if(res && !res.field) {\n                    this.replaceValueInForm(res, item.display);\n                    return true;\n                }\n                // Remaining edge case ?\n                console.error(item, parseResult.result);\n            }\n        }\n\n        console.error(\"Shouldn't be here: an autocomplete item is selected, but there is no text or a parse error!\");\n        // Default to just overriding the current value (a complex query with multiple items might become reduced to this single item!)\n        if(item.category === \"$field$\") {\n            this.setInputValue(item.display + \":\");\n            return false;\n        }\n        this.setInputValue(this.exprBuilder.makeExpr(item.category, item.normalized || item.display)); // person: `Bill Gates`\n        return true;\n    }\n\n    /**\n     * Replaces the piece of expression (res) with a new value\n     * in the input form\n     * @param res The piece of expression parsed from the input content\n     * @param value The new value\n     */\n    protected replaceValueInForm(res: ExprValueInfo, value: string) {\n        this.uiService.setCaret(this.inputElement, res.start, res.start+res.length, value);\n    }\n\n    /**\n     * Sets the content of the <input> based on the given\n     * Autocomplete Item (various implementations are possible,\n     * depending on the item content and nature).\n     * This would be the right method to override to implement\n     * fielded search autocomplete.\n     * @returns true if this autocomplete item should be searched\n     */\n    protected setAutocompleteItem(item: AutocompleteItem): boolean {\n        if(item) {\n            if(this.fieldSearchMode === \"text\") {\n                return this.insertAutocompleteItem(item);\n            }\n\n            else if(this.fieldSearchMode === \"selects\" && item.category && \n                (this.includedFields && this.includedFields?.includes(item.category) || \n                (!this.includedFields && !this.excludedFields?.includes(item.category)))) { // Filter out fields if not in fieldSearch mode\n                // In the case of of a field name, we display the field for autocomplete, but we don't want to search for it\n                if(item.category === \"$field$\") {\n                    this.setInputValue(item.display + \":\");\n                    return false;\n                }\n                // Store the autocomplete item that will be used to create a selection\n                this.setInputValue(\"\");\n                this.fieldSearchItems.push(item);\n                this.updatePlaceholder();\n                this.fieldSearchItemsContainer?.update(this.fieldSearchItems);\n                return true;\n            }\n\n            else {\n                this.setInputValue(item.display);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns an expression (Expr) for the fielded search items\n     */\n    public getFieldSearchExpression(): string | undefined {\n        return this.itemsToExpr(this.fieldSearchItems);\n    }\n\n    /**\n     * Transforms a list of AutocompleteItems into an expression\n     * @param items list of AutocompleteItems\n     */\n    protected itemsToExpr(items: AutocompleteItem[]): string | undefined {\n        if(items.length > 0) {\n            return this.exprBuilder.concatAndExpr(items.map(item => \n                this.exprBuilder.makeExpr(item.category, item.normalized || item.display, item.display)));\n        }\n        return undefined;\n    }\n\n    /**\n     * Transforms an expression into a list of AutocompleteItems\n     * @param expr an expression\n     */\n    protected exprToItem(expr: Expr): AutocompleteItem {\n        return {\n            category: expr.field!,\n            display: expr.display!,\n            normalized: expr.value!,\n        }\n    }\n\n    /**\n     * Takes the text from the <input> element and parse it to\n     * determine what type of suggestion to request from the server.\n     * The suggestions are then fetched by getSuggestsObs() and processed\n     * by processSuggests().\n     */\n    protected getSuggests() {\n        let value = this.getInputValue();\n        if(value) { // If there is text, make a call to the suggest API\n            const parseResult = this.parseQuery(); // If using fieldSearch, the result can be used to detect an active field\n            let fields: string[] | undefined;\n            if(parseResult.result && this.fieldSearchMode !== \"off\"){\n                const position = this.getInputPosition(); // Position of the caret, if needed\n                const res = parseResult.result.findValue(position);\n                // Field Search suggest\n                if(!!res && !!res.field){\n                    fields = Utils.startsWith(res.field, \"@\") ? [\"text\"] : [res.field];\n                    value = res.value;\n                }\n                if(!!res && this.fieldSearchMode === \"text\") {\n                    value = res.value;\n                }\n            }\n\n            if(parseResult.error && this.fieldSearchMode !== \"off\") {\n                this.processSuggests(of([])); // Empty autocomplete if parsing errors\n                return;\n            }\n\n            this.processSuggests(\n                this.getSuggestsObs(value, fields)\n            );\n\n        }\n        else {  // If empty input, restart autocomplete\n            this.parse.next({}); // remove error messages if any\n            this.start();\n        }\n    }\n\n    /**\n     * Process suggestions obtained (from whatever mean):\n     * - If data available, filter out fields\n     * - update the dropdown content\n     * - Switch between OPEN and ACTIVE states\n     * - Use changeDetectorRef to update display\n     * @param obs an observable of AutocompleteItem suggestions\n     */\n    protected processSuggests(obs: Observable<AutocompleteItem[]>){\n        obs.subscribe(\n            suggests => {\n                if(this.getState() === AutocompleteState.ACTIVE || this.getState() === AutocompleteState.OPENED){\n                    this.dropdown.update(true, suggests\n                        .filter(item => item.category !== \"$field$\" || (this.fieldSearchMode !== \"off\" && \n                            (this.includedFields && this.includedFields?.includes(item.display) || \n                            (!this.includedFields && !this.excludedFields?.includes(item.display)))))  // Filter out fields if not in fieldSearch mode\n                        .map(item => {\n                            if(!item.label){\n                                if(item.category === \"$field$\") {\n                                    item.label = \"Field\";\n                                }\n                                else {\n                                    item.label = this.appService.getLabel(item.category);\n                                }\n                            }\n                            return item;\n                        }));\n                }\n            },\n            err => {\n                this.dropdown.update(false);\n            },\n            () => {\n                if(this.dropdown.hasItems && this.getState() === AutocompleteState.ACTIVE){\n                    this.open();    // Switch from ACTIVE to OPENED (if not already)\n                }\n                else if(!this.dropdown.hasItems && this.getState() === AutocompleteState.OPENED){   // No data\n                    this.active();  // Switch from OPENED to ACTIVE (if not already)\n                }\n            });\n    }\n\n    /**\n     * Parse the query for syntax errors (also allows to detect field search if needed).\n     * Fires a parse event.\n     */\n    protected parseQuery() : ParseResult {\n        const value = this.getInputValue();\n        const result = this.appService.parseExpr(value, {allowEmptyValues: true});\n        const event = result instanceof Expr? { result: result } : { error: result };\n        this.parse.next(event);\n        return event;\n    }\n\n\n    /**\n     * Listen to user's keyboard actions in the <input>, in order to navigate\n     * and select the autocomplete suggestions.\n     * Overrides the parent keydown method, adds the management of the backspace key\n     * to remove field search items.\n     * @param event the keyboard\n     */\n    keydown(event: KeyboardEvent) {\n\n        const keydown = super.keydown(event);\n\n        if(keydown === undefined) {\n            // In fielded search mode, we can remove selections by typing <backspace> when the input is empty\n            if(event.keyCode === Keys.backspace) {\n                if(this.fieldSearchMode === \"selects\" && this.getInputValue() === '') {\n                    this.fieldSearchItems.pop();\n                    this.updatePlaceholder();\n                    this.fieldSearchItemsContainer?.update(this.fieldSearchItems);\n                }\n            }    \n        }\n        \n        return keydown;\n    }\n\n    /**\n     * Updates the <input>'s placeholder to avoid displaying something\n     * when there are fieldSearchItems displayed to the left.\n     */\n    updatePlaceholder() {\n        this._placeholder = this.fieldSearchItems.length > 0 ? '' : this.placeholder;\n    }\n}","import {NgModule} from \"@angular/core\";\nimport {CommonModule} from \"@angular/common\";\nimport {Autocomplete} from \"../autocomplete.directive\";\nimport {AutocompleteFieldSearch} from \"../autocomplete-field-search.directive\";\nimport {BsAutocompleteList} from \"./autocomplete-list/autocomplete-list\";\nimport {BsFieldSearchItemsComponent} from './field-search-items.component';\nimport {UtilsModule} from '@sinequa/components/utils';\n\n@NgModule({\n    imports: [\n        CommonModule,\n        UtilsModule\n    ],\n    declarations: [\n        BsAutocompleteList, BsFieldSearchItemsComponent, Autocomplete, AutocompleteFieldSearch\n    ],\n    exports: [\n        BsAutocompleteList, BsFieldSearchItemsComponent, Autocomplete, AutocompleteFieldSearch\n    ]\n})\nexport class BsAutocompleteModule {\n}","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["i0.ɵɵelementContainer","i0.ɵɵelementContainerStart","i0.ɵɵtemplate","i0.ɵɵelementContainerEnd","i0.ɵɵadvance","i0.ɵɵproperty","i0.ɵɵelementStart","i0.ɵɵlistener","i0.ɵɵelementEnd","i0.ɵɵtext","i0.ɵɵtextInterpolate1"],"mappings":"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"}