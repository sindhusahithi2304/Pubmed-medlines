{"version":3,"sources":["../projects/components/autocomplete/bootstrap/autocomplete-list/autocomplete-list.html","../projects/components/autocomplete/bootstrap/autocomplete-list/autocomplete-list.ts","../../projects/components/autocomplete/bootstrap/field-search-items.component.ts","../../../node_modules/tslib/tslib.es6.js","../../../projects/components/autocomplete/autocomplete.directive.ts","../../../projects/components/autocomplete/suggest.service.ts","../../../projects/components/autocomplete/autocomplete-field-search.directive.ts","../../projects/components/autocomplete/bootstrap/autocomplete.module.ts"],"names":["i0.ɵɵelementContainer","i0.ɵɵelementContainerStart","i0.ɵɵtemplate","i0.ɵɵelementContainerEnd","i0.ɵɵadvance","i0.ɵɵproperty","i0","ɵɵpureFunction1","_c2","item_r3","i0.ɵɵelementStart","i0.ɵɵlistener","i0.ɵɵelementEnd","ɵɵpureFunction2","_c4","ctx_r1","_isSelected","i_r4","ctx_r2","_items","BsAutocompleteList","changeDetectorRef","this","clicked","EventEmitter","_active","_cursor","prototype","update","active","items","markForCheck","Object","defineProperty","length","selectNext","selectedValue","selectPrevious","item","i","_itemClicked","event","next","stopPropagation","_mouseDown","preventDefault","i0.ɵɵtext","i0.ɵɵtextInterpolate1","ɵɵdirectiveInject","ChangeDetectorRef","selectors","contentQueries","rf","ctx","dirIndex","BsFieldSearchItemsComponent","itemRemoved","removeItem","outputs","decls","vars","consts","template","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","n","v","op","TypeError","call","pop","push","create","__values","o","s","m","AutocompleteState","SuggestService","suggestQueryWebService","suggestFieldWebService","appService","fieldCategory","addFields","text","suggests","includes","_b","fields","_c","field","Utils","startsWith","unshift","category","display","get","suggestQuery","query","_this","ccquery","name","pipe","flatMap","_fields","isArray","_fields_1","_fields_1_1","column","getColumn","eType","AppService","isScalar","map","forEach","toSqlValue","of","searchData","data","primaryText","secondaryText","obj","findMatch","filter","sort","a","score","displayHtml","textLower","removeAccents","toLowerCase","matches","indexOf","html","j","slice","concat","match","ɵɵinject","i1$1","SuggestQueryWebService","SuggestFieldWebService","i2","factory","ɵfac","providedIn","Autocomplete","elementRef","suggestService","uiService","suggestDelay","placeholder","stateChange","submit","_state","INIT","debounceSuggest","debounce","getSuggests","inputElement","nativeElement","ngOnInit","_dropdownSubscription","dropdown","subscribe","select","_placeholder","focus","start","ngOnChanges","changes","off","ngOnDestroy","unsubscribe","getState","setState","state","OFF","getInputValue","setInputValue","setCaret","setAutocompleteItem","init","START","startOrActive","ACTIVE","OPENED","suggest","SELECTED","searchable","open","processSuggests","getSuggestsObs","obs","getLabel","err","hasItems","getInputPosition","position","getCaret","len","trimEnd","Math","min","click","touchstart","blur","inputChanged","console","error","keydown","keyCode","Keys","up","down","tab","esc","enter","ElementRef","i3","UIService","hostVars","hostBindings","$event","AutocompleteFieldSearch","exprBuilder","_super","fieldSearchMode","excludedFields","fieldSearchItems","parse","__","constructor","__extends","fieldSearchItemsContainer","_fieldSearchSubscription","splice","updatePlaceholder","fieldSearchExpression","expr","parseExpr","Expr","getFields","and","operands","exprToItem","_a","insertAutocompleteItem","parseResult","parseQuery","res","findValue","replaceValueInForm","ExprParser","escape","normalized","includedFields","makeExpr","getFieldSearchExpression","itemsToExpr","concatAndExpr","allowEmptyValues","undefined","backspace","ExprBuilder","inputs","features","ɵɵInheritDefinitionFeature","ɵɵNgOnChangesFeature","BsAutocompleteModule","imports","CommonModule","UtilsModule","declarations","exports"],"mappings":"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","sourcesContent":["<div class=\"sq-autocomplete-list card position-absolute\" *ngIf=\"hasItems\" (mousedown)=\"_mouseDown($event)\">\n    <div class=\"list-group list-group-flush\">\n        <a  href=\"#\" (click)=\"_itemClicked(item, $event)\"\n            *ngFor=\"let item of _items; let i = index\"\n            class=\"list-group-item list-group-item-action p-0 border-0\" \n            [ngClass]=\"{'list-group-item-primary': _isSelected(item, i)}\"\n            [sqScrollIntoView]=\"{active: _isSelected(item, i), first: i === 0}\">\n            <ng-container *ngIf=\"itemTpl\">\n                <ng-container *ngTemplateOutlet=\"itemTpl; context:{$implicit: item}\"></ng-container>\n            </ng-container>\n        </a>\n    </div>\n    <div class=\"card-footer\" *ngIf=\"footerTpl\">\n        <ng-container *ngTemplateOutlet=\"footerTpl; context:{$implicit: _items}\"></ng-container>\n    </div>\n</div>","import {Output, ContentChild, TemplateRef, Component, EventEmitter, ChangeDetectorRef} from \"@angular/core\";\nimport {AutocompleteItem, AutocompleteComponent} from \"../../autocomplete.directive\";\n\n@Component({\n    selector: \"sq-autocomplete-list\",\n    templateUrl: \"./autocomplete-list.html\",\n    styleUrls: [\"./autocomplete-list.css\"]\n})\nexport class BsAutocompleteList implements AutocompleteComponent {\n\n    /**\n     * Template for the display of AutocompleteItem items, passed by transclusion\n     */\n    @ContentChild(\"itemTpl\", {static: false}) itemTpl: TemplateRef<any>;\n\n    /**\n     * Optional footer template, passed by transclusion\n     */\n    @ContentChild(\"footerTpl\", {static: false}) footerTpl: TemplateRef<any>;\n\n    /**\n     * Event emitter for clicks on an autocomplete item\n     */\n    @Output() clicked = new EventEmitter<AutocompleteItem>();\n\n    _active: boolean = false;\n    _items: AutocompleteItem[] | undefined;\n\n    _cursor: number = -1;\n\n\n    constructor(\n        private changeDetectorRef: ChangeDetectorRef){\n    }\n\n\n    /**\n     * Update the data and state of this component\n     * @param active whether the component should be displayed\n     * @param items The list of items to display\n     */\n    public update(active: boolean, items?: AutocompleteItem[]){\n        //console.log(\"autocomplete update \", active, items);\n        this._active = active;\n        this._items = items;\n        this._cursor = -1;\n\n        this.changeDetectorRef.markForCheck();\n    }\n\n    /**\n     * Whether there are any item to display\n     */\n    public get hasItems(): boolean {\n        return this._active && !!this._items && this._items.length > 0;\n    }\n\n    /**\n     * Returns the currently selected item, if any\n     */\n    public get selectedValue(): AutocompleteItem | undefined {\n        if(this._items && this._cursor >= 0 && this._cursor < this._items.length)\n            return this._items[this._cursor];\n        return undefined;\n    }\n\n    /**\n     * Select the next item in the list and returns it\n     */\n    public selectNext(): AutocompleteItem | undefined {\n        if (this._items && this._cursor < this._items.length-1) {\n            this._cursor++;\n        }\n        return this.selectedValue;\n    }\n\n    /**\n     * Select the previous item in the list and returns it\n     */\n    public selectPrevious(): AutocompleteItem | undefined {\n        if(this._cursor > 0)\n            this._cursor--;\n        return this.selectedValue;\n    }\n\n    /**\n     * Test whether an item is selected\n     * @param item\n     * @param i\n     */\n    _isSelected(item: AutocompleteItem, i: number): boolean {\n        return this._cursor === i;\n    }\n\n    /**\n     * Listen to click events and emits events\n     * @param item\n     * @param event\n     */\n    _itemClicked(item: AutocompleteItem, event){\n        this.clicked.next(item);\n        event.stopPropagation();\n        return false;\n    }\n\n    /**\n     * This prevents the focus to be removed from the <input>, which clauses the dropdown\n     */\n    _mouseDown(event){\n        event.preventDefault();\n    }\n\n}","import { Component, EventEmitter, Output, ChangeDetectorRef } from '@angular/core';\nimport { AutocompleteItem } from '../autocomplete.directive';\nimport { FieldSearchItemsContainer } from '../autocomplete-field-search.directive';\n\n@Component({\n    selector: \"sq-field-search-items\",\n    template: `\n<span *ngFor=\"let item of items\" class=\"badge badge-pill badge-info align-self-center mr-1\" [ngClass]=\"item.category\">\n    {{item.display}} <span class=\"fas fa-times-circle clickable\" (click)=\"removeItem(item)\"></span>\n</span>\n`,\n    styles: [`\n:host {\n    display: flex;\n}\n.clickable {\n    cursor: pointer;\n}\n.clickable:hover {\n    opacity: 85%;\n}\n`]\n})\nexport class BsFieldSearchItemsComponent implements FieldSearchItemsContainer {\n    @Output() itemRemoved = new EventEmitter<AutocompleteItem>();\n\n    items: AutocompleteItem[] = [];\n\n    constructor(protected changeDetectorRef: ChangeDetectorRef) {\n    }\n\n    update(items: AutocompleteItem[]): void {\n        this.items = items;\n        this.changeDetectorRef.markForCheck();\n    }\n\n    removeItem(item: AutocompleteItem) {\n        this.itemRemoved.next(item);\n        this.changeDetectorRef.markForCheck();\n    }\n\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {Directive, Input, Output, ElementRef, HostListener, OnInit, EventEmitter, OnDestroy, OnChanges, SimpleChanges, HostBinding} from \"@angular/core\";\nimport {Observable, Subscription} from \"rxjs\";\nimport {Utils, Keys} from \"@sinequa/core/base\";\nimport {AppService} from \"@sinequa/core/app-utils\";\nimport {SuggestService} from \"./suggest.service\";\nimport {UIService} from \"@sinequa/components/utils\";\n\n/**\n * Minimal interface for autocomplete items (note that the Suggestion\n * objects returned by the Suggestion service implement naturally this\n * interface)\n */\nexport interface AutocompleteItem {\n    display: string;\n    normalized?: string;\n    category: string;\n    label?: string;\n}\n\n/**\n * Interface required to be implemented by the dropdown components\n * binded to this autocomplete directive.\n * The component is responsible for displaying a list of items\n * and signaling back if a component was clicked. The component must\n * also manage navigation through the list (next/previous and selectedValue).\n */\nexport interface AutocompleteComponent {\n\n    /**\n     * Whether there are any item to display\n     */\n    hasItems: boolean;\n\n    /**\n     * Event emitter for clicks on an autocomplete item\n     */\n    clicked: EventEmitter<AutocompleteItem>;\n\n    /**\n     * Returns the currently selected item, if any\n     */\n    selectedValue: AutocompleteItem | undefined;\n\n    /**\n     * Update the data and state of this component\n     * @param active whether the component should be displayed\n     * @param items The list of items to display\n     */\n    update(active: boolean, items?: AutocompleteItem[]): void;\n\n    /**\n     * Select the next item in the list and returns it\n     */\n    selectNext(): AutocompleteItem | undefined;\n\n    /**\n     * Select the previous item in the list and returns it\n     */\n    selectPrevious(): AutocompleteItem | undefined;\n}\n\n/**\n * States in which the autocomplete component can be\n */\nexport enum AutocompleteState {\n    OFF = \"OFF\", // Autocomplete is turned off (via @Input())\n    INIT = \"INIT\", // Input is not focused, dropdown is closed\n    START = \"START\", // Input is focused, no text typed in, dropdown is closed\n    ACTIVE = \"ACTIVE\", // Input is focused, text is typed, suggests are being queried, dropdown is closed\n    OPENED = \"OPENED\", // Input is focused, text is typed, suggests are available, dropdown/autocomplete component is displayed\n    SELECTED = \"SELECTED\" // Input is focused, an input from the dropdown was selected\n}\n\n@Directive({\n    selector: \"[sqAutocomplete]\"\n})\nexport class Autocomplete implements OnInit, OnChanges, OnDestroy {\n\n    /** Reference to the AutocompleteComponent that displays the autocomplete items */\n    @Input() dropdown: AutocompleteComponent;\n\n    /** Whether the autocomplete should be active or not */\n    @Input() off: boolean;\n\n    /** Debounce delay between autocomplete queries */\n    @Input() suggestDelay: number = 200;\n\n    /** Name of the Suggest Query to be used */\n    @Input() suggestQuery: string;\n\n    /** Custom placeholder */\n    @Input() placeholder: string = '';\n\n    @HostBinding('attr.placeholder') _placeholder;\n\n    // Event emitters\n\n    @Output() stateChange = new EventEmitter<AutocompleteState>();\n    @Output() submit = new EventEmitter<void>();\n\n    private _state: AutocompleteState = AutocompleteState.INIT;\n\n    // The input HTML element to which this directive is attached\n    protected readonly inputElement: HTMLInputElement;\n\n\n    // Initialization\n\n    constructor(\n        elementRef: ElementRef,\n        protected suggestService: SuggestService,\n        protected appService: AppService,\n        protected uiService: UIService){\n\n        this.inputElement = elementRef.nativeElement;\n    }\n\n\n    /**\n     * On initialization, we listen to the autocomplete component for\n     * selection events\n     */\n    ngOnInit(){\n        this._dropdownSubscription = this.dropdown.clicked.subscribe(item => {\n            this.select(item, true);  // An item was selected from the autocomplete => take the value\n        });\n\n        this._placeholder = this.placeholder;\n        this.inputElement.focus();\n        this.start();\n    }\n\n    /**\n     * If the off input changes state, react accordingly\n     * @param changes\n     */\n    ngOnChanges(changes: SimpleChanges){\n        // Turn on the autocomplete\n        if(changes[\"off\"] && !this.off){\n            this.start();\n        }\n    }\n\n\n    protected _dropdownSubscription: Subscription;\n    /**\n     * Unsubscribe when destroying the component\n     */\n    ngOnDestroy(){\n        if(this._dropdownSubscription){\n            this._dropdownSubscription.unsubscribe();\n        }\n    }\n\n\n    // Getters and Setters\n\n    /**\n     * Return the current state of the autocomplete\n     */\n    public getState(): AutocompleteState {\n        return this._state;\n    }\n\n    /**\n     * Set the current state of the autocomplete\n     */\n    protected setState(state: AutocompleteState) {\n        if(this.off){\n            if(this._state !== AutocompleteState.OFF){\n                this._state = AutocompleteState.OFF;\n                this.stateChange.next(this.getState());\n            }\n            // ignore state change if Autocomplete is off\n        }\n        else if(!!state && this._state !== state) {\n            this._state = state;\n            //console.log(\"STATE: \", this._state);\n            this.stateChange.next(this.getState());\n        }\n    }\n\n    /**\n     * Get the current text value of the HTML <input>\n     * to which this directive is attached\n     */\n    protected getInputValue() : string {\n        return this.inputElement.value;\n    }\n\n    /**\n     * Set the current text value of the HTML <input>\n     * to which this directive is attached\n     */\n    protected setInputValue(value: string) {\n        // Using setCaret() allows to properly update the underlying form\n        this.uiService.setCaret(this.inputElement, 0, -1, value); // 0, -1 erases the current value and writes the new one\n    }\n\n    /**\n     * Sets the content of the <input> based on the given\n     * Autocomplete Item (various implementations are possible,\n     * depending on the item content and nature).\n     * This would be the right method to override to implement\n     * fielded search autocomplete.\n     * @returns true if this autocomplete item should be searched\n     */\n    protected setAutocompleteItem(item: AutocompleteItem): boolean {\n        if(item) {\n            this.setInputValue(item.display);\n            return true;\n        }\n        return false;\n    }\n\n\n    // Methods triggering state changes\n\n    /**\n     * INIT state (Input is not focused, dropdown is closed)\n     */\n    protected init(): void {\n        this.setState(AutocompleteState.INIT);\n        this.dropdown.update(false);    // If the dropdown was active\n    }\n\n    /**\n     * START state (Input is focused, no text typed in, dropdown is closed)\n     */\n    protected start(): void {\n        this.setState(AutocompleteState.START);\n        this.dropdown.update(false);    // If the dropdown was active\n    }\n\n    /**\n     * START state and if the <input> has content, immediately switch to ACTIVE\n     */\n    protected startOrActive(): void {\n        if(this.getState()!== AutocompleteState.ACTIVE && this.getState()!== AutocompleteState.OPENED){ // Avoid flickering\n            this.start();\n            if(!!this.getInputValue()){\n                this.active();\n            }\n        }\n    }\n\n    /**\n     * ACTIVE state (Input is focused, text is typed, suggests are being queried, dropdown is closed)\n     */\n    protected active(): void {\n        if(this.getState() === AutocompleteState.START || this.getState() === AutocompleteState.ACTIVE || this.getState() === AutocompleteState.OPENED){\n            this.setState(AutocompleteState.ACTIVE);\n            this.dropdown.update(false);    // If the dropdown was active\n            this.suggest();\n        }\n    }\n\n    /**\n     * Select the given autocomplete suggestion for search\n     * @param submit if, true also trigger a submit\n     * @param item a specific item to submit\n     */\n    protected select(item: AutocompleteItem, submit?: boolean): void {\n        this.setState(AutocompleteState.SELECTED); // Change state BEFORE setting input value, so the event is correctly processed\n        const searchable = this.setAutocompleteItem(item);\n        this.dropdown.update(false);    // Close dropdown\n\n        if(submit && searchable) this.submit.next();\n    }\n\n    /**\n     * Switch to OPENED state (from ACTIVE only)\n     */\n    protected open(): void {\n        if(this.getState() === AutocompleteState.ACTIVE){\n            this.setState(AutocompleteState.OPENED);\n        }\n    }\n\n    /**\n     * Request suggestions from the server, and update the dropdown contents\n     * and autocomplete state asynchronously.\n     * Override this method for a synchronous implementation.\n     */\n    protected suggest() {\n        this.debounceSuggest();\n    }\n\n    /**\n     * Actually makes the API call to the suggestService to retrieve suggestions\n     * and process them.\n     */\n    protected getSuggests() {\n        const value = this.getInputValue();\n        if(value) { // If there is text, make a call to the suggest API\n            this.processSuggests(\n                this.getSuggestsObs(value)\n            );\n        }\n        else {  // If empty input, restart autocomplete\n            this.start();\n        }\n    }\n\n    /**\n     * Returns an observable of Suggestions, given some input text\n     * @param value input text for which to return suggestions\n     */\n    protected getSuggestsObs(value: string, fields?: string[]): Observable<AutocompleteItem[]> {\n        return this.suggestService.get(this.suggestQuery, value, fields);\n    }\n\n    /**\n     * Process suggestions obtained (from whatever mean):\n     * - If data available, filter out fields\n     * - update the dropdown content\n     * - Switch between OPEN and ACTIVE states\n     * - Use changeDetectorRef to update display\n     * @param obs an observable of AutocompleteItem suggestions\n     */\n    protected processSuggests(obs: Observable<AutocompleteItem[]>){\n        obs.subscribe(\n            suggests => {\n                if(this.getState() === AutocompleteState.ACTIVE || this.getState() === AutocompleteState.OPENED){\n                    this.dropdown.update(true, suggests\n                        .filter(item => item.category !== \"$field$\")  // Filter out fields\n                        .map(item => {\n                            if(!item.label){\n                                item.label = this.appService.getLabel(item.category);\n                            }\n                            return item;\n                        }));\n                }\n            },\n            err => {\n                this.dropdown.update(false);\n            },\n            () => {\n                if(this.dropdown.hasItems && this.getState() === AutocompleteState.ACTIVE){\n                    this.open();    // Switch from ACTIVE to OPENED (if not already)\n                }\n                else if(!this.dropdown.hasItems && this.getState() === AutocompleteState.OPENED){   // No data\n                    this.active();  // Switch from OPENED to ACTIVE (if not already)\n                }\n            });\n    }\n\n    /**\n     * Use the suggest service to retrieve suggestions given the input text.\n     * The suggest (autocomplete) query is debounded to avoid flooding the server.\n     */\n    private readonly debounceSuggest: () => void = Utils.debounce(() => {\n        this.getSuggests();\n    }, this.suggestDelay);\n\n\n    /**\n     * Returns the caret position within the input\n     */\n    protected getInputPosition(): number {\n        // Come back before trailing spaces so the preceding value is still seen as the input value\n        // (needed for ExprParser to stop autocomplete being cancelled on entering trailing spaces)\n        const position = this.uiService.getCaret(this.inputElement).start;\n        const length = Utils.len(Utils.trimEnd(this.getInputValue()));\n        return Math.min(position, length);\n    }\n\n    /**\n     * The following are event listeners applied to the <input> host component\n     * onto which this directive is applied.\n     * The events affect the state of the autocomplete, which triggers\n     * various actions (call to suggest API, etc.).\n     */\n\n    /**\n     * Listens to click events on the <input> host\n     */\n    @HostListener(\"click\") click() {\n        //console.log(\"input clicked\");\n        this.startOrActive();\n    }\n\n    /**\n     * Listens to touchstart events (mobile clicks) on the <input> host\n     */\n    @HostListener(\"touchstart\") touchstart() {\n        //console.log(\"input touchstart\");\n        this.startOrActive();\n    }\n\n    /**\n     * Listens to focus events on the <input> host\n     */\n    @HostListener(\"focus\") focus() {\n        //console.log(\"input focus gained\");\n        this.start();\n    }\n\n    /**\n     * Listens to blur events (out of focus) on the <input> host\n     */\n    @HostListener(\"blur\", [\"$event\"]) blur(event: FocusEvent) {\n        //console.log(\"input focus lost\");\n        this.init();\n    }\n\n    /**\n     * Listen to any change in the <input> content and react\n     * according to the current state of the autocomplete\n     * @param event\n     */\n    @HostListener(\"input\", [\"$event\"]) inputChanged(event: Event) {\n        //console.log(\"input value changed\");\n        switch(this.getState()){\n            case AutocompleteState.OPENED:\n                this.suggest(); // Just request more data, but no state change\n                break;\n            case AutocompleteState.START:\n            case AutocompleteState.ACTIVE:\n                this.active(); // get more data, and change state if not already ACTIVE\n                break;\n            case AutocompleteState.SELECTED:\n                this.start(); // The model changed because we selected a value ==> we restart in case the user keeps typing\n                break;\n            case AutocompleteState.INIT:\n                console.error(\"Should not be in INIT state if the form changes\");\n                break;\n        }\n    }\n\n    /**\n     * Listen to user's keyboard actions in the <input>, in order to navigate\n     * and select the autocomplete suggestions.\n     * @param event the keyboard\n     */\n    @HostListener(\"keydown\", [\"$event\"]) keydown(event: KeyboardEvent) {\n        // Navigation in the opened dropdown\n        if (this.getState() === AutocompleteState.OPENED) {\n            switch (event.keyCode) {\n                case Keys.up:\n                    this.dropdown.selectPrevious();\n                    return false; // prevent default\n                case Keys.down:\n                    this.dropdown.selectNext();\n                    return false; // prevent default\n                case Keys.tab:\n                    if(!!this.dropdown.selectedValue){\n                        this.select(this.dropdown.selectedValue);\n                    } else {\n                        this.dropdown.selectNext();\n                    }\n                    return false; // prevent default (change focus)\n                case Keys.esc:\n                    this.start(); // Just restart the autocomplete\n                    //event.stopPropagation(); // needed?\n                    return false; // prevent default\n                case Keys.enter:\n                    if(!!this.dropdown.selectedValue){\n                        this.select(this.dropdown.selectedValue, true);\n                        //event.stopPropagation(); // needed?\n                        return false; // prevent default action (auto submit)\n                    }\n            }\n        }\n\n        // If a search was triggered, restart the autocomplete\n        if(event.keyCode === Keys.enter) {\n            this.submit.next();\n            this.start();\n        }\n        return undefined;\n    }\n}\n","import {Injectable} from \"@angular/core\";\nimport {Observable, of} from \"rxjs\";\nimport {map, flatMap} from \"rxjs/operators\";\nimport {Utils} from \"@sinequa/core/base\";\nimport {SuggestQueryWebService, SuggestFieldWebService, Suggestion, EngineType} from \"@sinequa/core/web-services\";\nimport {AppService, Query} from \"@sinequa/core/app-utils\";\nimport {AutocompleteItem} from './autocomplete.directive';\n\n@Injectable({\n    providedIn: \"root\"\n})\nexport class SuggestService {\n\n    fieldCategory: string;\n\n    constructor(\n        private suggestQueryWebService: SuggestQueryWebService,\n        private suggestFieldWebService: SuggestFieldWebService,\n        private appService: AppService) {\n        this.fieldCategory = \"$field$\";\n    }\n\n    private addFields(text: string, suggests: Suggestion[]) {\n        if (text.includes(\" \")) {\n            return;\n        }\n        for (const field of this.appService.fields) {\n            if (Utils.startsWith(field, text)) {\n                suggests.unshift({\n                    category: this.fieldCategory,\n                    display: field\n                });\n            }\n        }\n    }\n\n    get(suggestQuery: string, text: string, fields?: string | string[], query?: Query): Observable<Suggestion[]> {\n        if (!this.appService.ccquery) {\n            return of([]);\n        }\n        const observable = this.suggestQueryWebService.get(suggestQuery, text, this.appService.ccquery.name, fields);\n        return observable.pipe(\n            flatMap(suggests => {\n                if (!fields) {\n                    if (!suggests) {\n                        suggests = [];\n                    }\n                    this.addFields(text, suggests);\n                }\n                else {\n                    if (!suggests || suggests.length === 0) {\n                        const _fields = Utils.isArray(fields) ? fields : [fields];\n                        fields = [];\n                        for (const field of _fields) {\n                            const column = this.appService.getColumn(field);\n                            if (!!column && (column.eType === EngineType.csv || AppService.isScalar(column))) {\n                                fields.push(field);\n                            }\n                        }\n                        if (fields.length > 0) {\n                            return this.suggestFieldWebService.get(text, fields, query).pipe(\n                                map((suggests) => {\n                                    suggests.forEach(value => value.display = Utils.toSqlValue(value.display)); // because dates get automatically converted by the interceptor\n                                    return suggests;\n                                }));\n                        }\n                    }\n                }\n                return of(suggests);\n            }));\n    }\n\n\n    /**\n     * Search for the input text in a list of objects and return autocomplete items asynchronously\n     * @param query The text to search for\n     * @param data The list of objects\n     * @param primaryText A function that returns the primary text input given the object\n     * @param secondaryText An (optional) function that returns a list of secondary text inputs given the object\n     */\n    public async searchData<T>(\n        category: string,\n        query: string,\n        data: T[],\n        primaryText: (obj:T) => string,\n        secondaryText?: (obj:T) => string[],\n        label?: string) : Promise<AutocompleteItem[]> {\n\n        return data\n            .map(obj => SuggestService.findMatch(primaryText(obj), query,\n                !!secondaryText ? secondaryText(obj) : [], obj)) // Look for matches in all saved queries\n            .filter(item => !!item) // Keep only the matches\n            .sort((a,b) => b!.score - a!.score) // Sort by decreasing score\n            .map(item => {\n                item = item!;\n                return {    // Make an autocomplete item\n                    display: item.display,\n                    displayHtml: item.displayHtml,\n                    category,\n                    label: label || category,\n                    data: item.data,\n                    score: item.score\n                };\n            } );\n    }\n\n    /**\n     * Searches for the query string inside a given text. Returns a match object containing:\n     * - a score proportional to the number and quality of matches\n     * - the text formatted as HTML with the query found in the text\n     * @param text The text to search\n     * @param query The string to search for\n     * @param secondaryText Secondary fields to search input, with less importance than the primary field\n     * @param data A data object to be included in the match object (for convenience mostly)\n     */\n    public static findMatch(text: string, query: string, secondaryText?: string[], data?: any): {display: string, displayHtml: string, score: number, data?:any} | undefined {\n\n        if(!text || !query){\n            return undefined;\n        }\n\n        // pass text and query in lower case and no accent to make search case insensitive\n        const textLower = Utils.removeAccents(text.toLowerCase());\n        query = Utils.removeAccents(query.toLowerCase());\n        let i = 0;\n        const matches: number[] = [];\n        let score = 0;\n\n        // Compute score of the match\n        i = textLower.indexOf(query);\n        while(i !== -1){    // While there's a match\n            matches.push(i);\n            if(i === 0){    // Start of the text\n                score += 4;\n            }\n            else if(textLower[i-1] === \" \"){ // Start of a word\n                score += 2;\n            }\n            else {\n                score += 1; // Middle of a word\n            }\n            i = textLower.indexOf(query, i+query.length);\n        }\n\n        // Format HTML display\n        let html = text;\n        for(let j=matches.length-1; j>=0; j--) { // decreasing order so the indices remain valid\n            i = matches[j];\n            html = html.slice(0, i).concat(\"<strong>\", html.slice(i, i+query.length), \"</strong>\", html.slice(i+query.length));\n        }\n\n        // Secondary text\n        if(secondaryText) {\n            secondaryText\n                .map(t => this.findMatch(t, query)) // Search each secondary text for matches\n                .filter(item => !!item) // Keep only the matches\n                .sort((a,b) => b!.score - a!.score) // Sort by decreasing score\n                .forEach(match => {\n                    match = match!;\n                    score += match.score / 2;  // Secondary matches added to the score, but count half\n                    html += \" <small>\" + match.displayHtml + \"</small>\"; // Concatenate secondary match html to the main html\n                });\n        }\n\n        if(score > 0){\n            return {\n                display: text,\n                displayHtml: html,\n                score: score,\n                data: data\n            };\n        }\n        return undefined;\n    }\n}","import { Directive, Input, Output, EventEmitter, SimpleChanges, ElementRef, OnChanges, OnDestroy } from \"@angular/core\";\nimport { Observable, Subscription, of } from \"rxjs\";\nimport { Utils, Keys} from \"@sinequa/core/base\";\nimport { AppService, Expr, ExprBuilder, ExprParser, ExprValueInfo} from \"@sinequa/core/app-utils\";\nimport { Autocomplete, AutocompleteItem, AutocompleteState } from './autocomplete.directive';\nimport { SuggestService } from './suggest.service';\nimport { UIService } from '@sinequa/components/utils';\n\n/**\n * Interface required to be implement by the component displaying\n * the fielded search items (basically the content of fieldSearchItems)\n */\nexport interface FieldSearchItemsContainer {\n\n    /** Update the list of items displayed by the container */\n    update(items: AutocompleteItem[]): void;\n\n    /** Event triggered when the user removes an item from the container */\n    itemRemoved: EventEmitter<AutocompleteItem>;\n}\n\nexport interface ParseResult {\n    result?: Expr;\n    error?: string;\n}\n\n@Directive({\n    selector: \"[sqAutocompleteFieldSearch]\"\n})\nexport class AutocompleteFieldSearch extends Autocomplete implements OnChanges, OnDestroy {\n\n\n    // FIELDED SEARCH\n\n    /** \n     * \"text\" mode: fielded search is entirely managed as text in the <input> component \n     * \"selects\" mode: fielded search stores the selected autocomplete items to create selections, while keeping a clean <input> content (better UI/UX but does not support operators like OR, NOT, and parentheses)\n     */\n    @Input() fieldSearchMode: \"off\" | \"text\" | \"selects\" = \"text\";\n\n    /** Fields excluded from fielded search (searched as regular strings if selected) */\n    @Input() excludedFields: string[] = [\"concepts\"];\n\n    /* Fields included in fielded search (have precedence over excluded fields) */\n    @Input() includedFields?: string[];\n\n   /** Container displaying the fieldSearchItems (only needed if mode === \"selects\") */\n    @Input() fieldSearchItemsContainer?: FieldSearchItemsContainer;\n\n    /** Current selection expression needed to update the list of field search items if mode === \"selects\" */\n    @Input() fieldSearchExpression?: string;\n \n    /** Stores the selected fielded search items selected via Tab */\n    public readonly fieldSearchItems: AutocompleteItem[] = [];\n\n\n    // Event emitters\n\n    @Output() parse = new EventEmitter<ParseResult>();\n\n    constructor(elementRef: ElementRef<any>, \n        suggestService: SuggestService,\n        appService: AppService,\n        uiService: UIService,\n        protected exprBuilder: ExprBuilder){\n        super(elementRef, suggestService, appService, uiService);\n    }\n\n\n    /**\n     * If the off input changes state, react accordingly\n     * @param changes\n     */\n    ngOnChanges(changes: SimpleChanges){\n        super.ngOnChanges(changes);\n\n        // Subscribe to the field search items's container\n        if(changes[\"fieldSearchItemsContainer\"] && this.fieldSearchItemsContainer) {\n            if(this._fieldSearchSubscription){\n                this._fieldSearchSubscription.unsubscribe();\n            }\n            this._fieldSearchSubscription = this.fieldSearchItemsContainer.itemRemoved.subscribe(item => {\n                this.fieldSearchItems.splice(this.fieldSearchItems.indexOf(item), 1);\n                this.updatePlaceholder();\n                this.submit.next();\n            });\n        }\n\n        // Transform the field search expresion (Expr string) into a list of autocomplete items displayed in the field search container\n        if(changes[\"fieldSearchExpression\"] && this.fieldSearchMode === \"selects\") {\n            if(this.fieldSearchExpression) {\n                const expr = this.appService.parseExpr(this.fieldSearchExpression);\n                if(expr instanceof Expr && this.fieldSearchItems.length !== expr.getFields().length) {\n                    this.fieldSearchItems.splice(0);\n                    if(expr.and) {\n                        expr.operands.forEach(e => \n                            this.fieldSearchItems.push(this.exprToItem(e))\n                        );\n                    }\n                    else {\n                        this.fieldSearchItems.push(this.exprToItem(expr));\n                    }\n                }\n            }\n            else {\n                this.fieldSearchItems.splice(0);\n            }\n        }\n\n        // If fieldSearchMode changes from selects to something else, we must remove the field search items\n        if(changes[\"fieldSearchMode\"] && this.fieldSearchMode !== \"selects\" && this.fieldSearchItems.length > 0) {\n            this.fieldSearchItems.splice(0);\n        }\n\n        this.updatePlaceholder();\n        this.fieldSearchItemsContainer?.update(this.fieldSearchItems);\n    }\n\n\n    private _fieldSearchSubscription: Subscription;\n    /**\n     * Unsubscribe when destroying the component\n     */\n    ngOnDestroy(){\n        super.ngOnDestroy();\n        if(this._fieldSearchSubscription){\n            this._fieldSearchSubscription.unsubscribe();\n        }\n    }\n\n    /**\n     * Insert the given autocomplete item into the current search input\n     * at the right location\n     * @param item \n     */\n    protected insertAutocompleteItem(item: AutocompleteItem): boolean {\n        const value = this.getInputValue(); // Current text in the input\n        if(value) { // There should always be text\n            const parseResult = this.parseQuery(); // Parse the current text\n            if(parseResult.result) { // (if no result, a parsing error occurred)\n                const res = parseResult.result.findValue(this.getInputPosition()); // Get the expression at the caret location\n                // Autocomplete \"compa\" => \"company:\"\n                if(res && item.category === \"$field$\") {\n                    this.replaceValueInForm(res, item.display + \": \");\n                    return false;\n                }\n                // Autocomplete \"company:Goo\" => \"company:`GOOGLE`\"\n                if(res && res.field === item.category) {\n                    this.replaceValueInForm(res, ExprParser.escape(item.normalized || item.display));\n                    return true;\n                }\n                // Autocomplete \"Goo\" => \"company:`GOOGLE`\"\n                if(res && !res.field && item.category && \n                    (this.includedFields && this.includedFields?.includes(item.category) || \n                    (!this.includedFields && !this.excludedFields?.includes(item.category)))) { // Filter out fields if not in fieldSearch mode\n                    this.replaceValueInForm(res, this.exprBuilder.makeExpr(item.category, item.normalized || item.display));\n                    return true;\n                }\n                // Autocomplete \"Search eng\" => \"Search engine\"\n                if(res && !res.field) {\n                    this.replaceValueInForm(res, item.display);\n                    return true;\n                }\n                // Remaining edge case ?\n                console.error(item, parseResult.result);\n            }\n        }\n\n        console.error(\"Shouldn't be here: an autocomplete item is selected, but there is no text or a parse error!\");\n        // Default to just overriding the current value (a complex query with multiple items might become reduced to this single item!)\n        if(item.category === \"$field$\") {\n            this.setInputValue(item.display + \":\");\n            return false;\n        }\n        this.setInputValue(this.exprBuilder.makeExpr(item.category, item.normalized || item.display)); // person: `Bill Gates`\n        return true;\n    }\n\n    /**\n     * Replaces the piece of expression (res) with a new value\n     * in the input form\n     * @param res The piece of expression parsed from the input content\n     * @param value The new value\n     */\n    protected replaceValueInForm(res: ExprValueInfo, value: string) {\n        this.uiService.setCaret(this.inputElement, res.start, res.start+res.length, value);\n    }\n\n    /**\n     * Sets the content of the <input> based on the given\n     * Autocomplete Item (various implementations are possible,\n     * depending on the item content and nature).\n     * This would be the right method to override to implement\n     * fielded search autocomplete.\n     * @returns true if this autocomplete item should be searched\n     */\n    protected setAutocompleteItem(item: AutocompleteItem): boolean {\n        if(item) {\n            if(this.fieldSearchMode === \"text\") {\n                return this.insertAutocompleteItem(item);\n            }\n\n            else if(this.fieldSearchMode === \"selects\" && item.category && \n                (this.includedFields && this.includedFields?.includes(item.category) || \n                (!this.includedFields && !this.excludedFields?.includes(item.category)))) { // Filter out fields if not in fieldSearch mode\n                // In the case of of a field name, we display the field for autocomplete, but we don't want to search for it\n                if(item.category === \"$field$\") {\n                    this.setInputValue(item.display + \":\");\n                    return false;\n                }\n                // Store the autocomplete item that will be used to create a selection\n                this.setInputValue(\"\");\n                this.fieldSearchItems.push(item);\n                this.updatePlaceholder();\n                this.fieldSearchItemsContainer?.update(this.fieldSearchItems);\n                return true;\n            }\n\n            else {\n                this.setInputValue(item.display);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns an expression (Expr) for the fielded search items\n     */\n    public getFieldSearchExpression(): string | undefined {\n        return this.itemsToExpr(this.fieldSearchItems);\n    }\n\n    /**\n     * Transforms a list of AutocompleteItems into an expression\n     * @param items list of AutocompleteItems\n     */\n    protected itemsToExpr(items: AutocompleteItem[]): string | undefined {\n        if(items.length > 0) {\n            return this.exprBuilder.concatAndExpr(items.map(item => \n                this.exprBuilder.makeExpr(item.category, item.normalized || item.display, item.display)));\n        }\n        return undefined;\n    }\n\n    /**\n     * Transforms an expression into a list of AutocompleteItems\n     * @param expr an expression\n     */\n    protected exprToItem(expr: Expr): AutocompleteItem {\n        return {\n            category: expr.field!,\n            display: expr.display!,\n            normalized: expr.value!,\n        }\n    }\n\n    /**\n     * Takes the text from the <input> element and parse it to\n     * determine what type of suggestion to request from the server.\n     * The suggestions are then fetched by getSuggestsObs() and processed\n     * by processSuggests().\n     */\n    protected getSuggests() {\n        let value = this.getInputValue();\n        if(value) { // If there is text, make a call to the suggest API\n            const parseResult = this.parseQuery(); // If using fieldSearch, the result can be used to detect an active field\n            let fields: string[] | undefined;\n            if(parseResult.result && this.fieldSearchMode !== \"off\"){\n                const position = this.getInputPosition(); // Position of the caret, if needed\n                const res = parseResult.result.findValue(position);\n                // Field Search suggest\n                if(!!res && !!res.field){\n                    fields = Utils.startsWith(res.field, \"@\") ? [\"text\"] : [res.field];\n                    value = res.value;\n                }\n                if(!!res && this.fieldSearchMode === \"text\") {\n                    value = res.value;\n                }\n            }\n\n            if(parseResult.error && this.fieldSearchMode !== \"off\") {\n                this.processSuggests(of([])); // Empty autocomplete if parsing errors\n                return;\n            }\n\n            this.processSuggests(\n                this.getSuggestsObs(value, fields)\n            );\n\n        }\n        else {  // If empty input, restart autocomplete\n            this.parse.next({}); // remove error messages if any\n            this.start();\n        }\n    }\n\n    /**\n     * Process suggestions obtained (from whatever mean):\n     * - If data available, filter out fields\n     * - update the dropdown content\n     * - Switch between OPEN and ACTIVE states\n     * - Use changeDetectorRef to update display\n     * @param obs an observable of AutocompleteItem suggestions\n     */\n    protected processSuggests(obs: Observable<AutocompleteItem[]>){\n        obs.subscribe(\n            suggests => {\n                if(this.getState() === AutocompleteState.ACTIVE || this.getState() === AutocompleteState.OPENED){\n                    this.dropdown.update(true, suggests\n                        .filter(item => item.category !== \"$field$\" || (this.fieldSearchMode !== \"off\" && \n                            (this.includedFields && this.includedFields?.includes(item.display) || \n                            (!this.includedFields && !this.excludedFields?.includes(item.display)))))  // Filter out fields if not in fieldSearch mode\n                        .map(item => {\n                            if(!item.label){\n                                if(item.category === \"$field$\") {\n                                    item.label = \"Field\";\n                                }\n                                else {\n                                    item.label = this.appService.getLabel(item.category);\n                                }\n                            }\n                            return item;\n                        }));\n                }\n            },\n            err => {\n                this.dropdown.update(false);\n            },\n            () => {\n                if(this.dropdown.hasItems && this.getState() === AutocompleteState.ACTIVE){\n                    this.open();    // Switch from ACTIVE to OPENED (if not already)\n                }\n                else if(!this.dropdown.hasItems && this.getState() === AutocompleteState.OPENED){   // No data\n                    this.active();  // Switch from OPENED to ACTIVE (if not already)\n                }\n            });\n    }\n\n    /**\n     * Parse the query for syntax errors (also allows to detect field search if needed).\n     * Fires a parse event.\n     */\n    protected parseQuery() : ParseResult {\n        const value = this.getInputValue();\n        const result = this.appService.parseExpr(value, {allowEmptyValues: true});\n        const event = result instanceof Expr? { result: result } : { error: result };\n        this.parse.next(event);\n        return event;\n    }\n\n\n    /**\n     * Listen to user's keyboard actions in the <input>, in order to navigate\n     * and select the autocomplete suggestions.\n     * Overrides the parent keydown method, adds the management of the backspace key\n     * to remove field search items.\n     * @param event the keyboard\n     */\n    keydown(event: KeyboardEvent) {\n\n        const keydown = super.keydown(event);\n\n        if(keydown === undefined) {\n            // In fielded search mode, we can remove selections by typing <backspace> when the input is empty\n            if(event.keyCode === Keys.backspace) {\n                if(this.fieldSearchMode === \"selects\" && this.getInputValue() === '') {\n                    this.fieldSearchItems.pop();\n                    this.updatePlaceholder();\n                    this.fieldSearchItemsContainer?.update(this.fieldSearchItems);\n                }\n            }    \n        }\n        \n        return keydown;\n    }\n\n    /**\n     * Updates the <input>'s placeholder to avoid displaying something\n     * when there are fieldSearchItems displayed to the left.\n     */\n    updatePlaceholder() {\n        this._placeholder = this.fieldSearchItems.length > 0 ? '' : this.placeholder;\n    }\n}","import {NgModule} from \"@angular/core\";\nimport {CommonModule} from \"@angular/common\";\nimport {Autocomplete} from \"../autocomplete.directive\";\nimport {AutocompleteFieldSearch} from \"../autocomplete-field-search.directive\";\nimport {BsAutocompleteList} from \"./autocomplete-list/autocomplete-list\";\nimport {BsFieldSearchItemsComponent} from './field-search-items.component';\nimport {UtilsModule} from '@sinequa/components/utils';\n\n@NgModule({\n    imports: [\n        CommonModule,\n        UtilsModule\n    ],\n    declarations: [\n        BsAutocompleteList, BsFieldSearchItemsComponent, Autocomplete, AutocompleteFieldSearch\n    ],\n    exports: [\n        BsAutocompleteList, BsFieldSearchItemsComponent, Autocomplete, AutocompleteFieldSearch\n    ]\n})\nexport class BsAutocompleteModule {\n}"]}