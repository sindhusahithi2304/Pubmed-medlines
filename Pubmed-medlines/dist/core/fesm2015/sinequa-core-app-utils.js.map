{"version":3,"file":"sinequa-core-app-utils.js","sources":["../../../projects/core/app-utils/app-service-helpers.ts","../../projects/core/app-utils/query/expr-parser.ts","../../projects/core/app-utils/query/expr-builder.ts","../../projects/core/app-utils/query/query.ts","../../../projects/core/app-utils/format.service.ts","../../../projects/core/app-utils/app.service.ts","../../../projects/core/app-utils/audit.interceptor.ts","../../../projects/core/app-utils/module.providers.ts","../../../projects/core/app-utils/app-utils.module.ts","../../../projects/core/app-utils/sinequa-core-app-utils.ts"],"sourcesContent":["import {CCColumn, EngineType, EngineTypeModifier} from \"@sinequa/core/web-services\";\n\n/**\n * @ignore\n *\n * Used internally to avoid circular references between ExprParser, AppService and FormatService.\n * Do not export from the app-utils module.\n */\nexport class AppServiceHelpers {\n    static isString(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.string) {\n            return true;\n        }\n        if (column.eType === EngineType.csv && (column.eTypeModifier & EngineTypeModifier.x) === EngineTypeModifier.x) {\n            return true;\n        }\n        return false;\n    }\n\n    static isCsv(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.csv && (column.eTypeModifier & EngineTypeModifier.x) !== EngineTypeModifier.x) {\n            return true;\n        }\n        return false;\n    }\n\n    static isTree(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.csv && (column.eTypeModifier & EngineTypeModifier.t) === EngineTypeModifier.t) {\n            return true;\n        }\n        return false;\n    }\n\n    static isEntity(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.csv && (column.eTypeModifier & (EngineTypeModifier.e | EngineTypeModifier.l)) === (EngineTypeModifier.e | EngineTypeModifier.l)) {\n            return true;\n        }\n        return false;\n    }\n\n    static isBoolean(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.bool) {\n            return true;\n        }\n        return false;\n    }\n\n    static isDate(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.date || column.eType === EngineType.dateTime || column.eType === EngineType.time) {\n            return true;\n        }\n        return false;\n    }\n\n    static isDouble(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.double || column.eType === EngineType.float) {\n            return true;\n        }\n        return false;\n    }\n\n    static isInteger(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.integer || column.eType === EngineType.unsigned) {\n            return true;\n        }\n        return false;\n    }\n\n    static isNumber(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isInteger(column) || AppServiceHelpers.isDouble(column);\n    }\n\n    static isScalar(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isNumber(column) || AppServiceHelpers.isDate(column) || AppServiceHelpers.isBoolean(column);\n    }\n\n    static isSortable(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isString(column) || AppServiceHelpers.isScalar(column) ||\n            (AppServiceHelpers.isCsv(column) && !!column && ((column.eTypeModifier & EngineTypeModifier.l) === EngineTypeModifier.l));\n    }\n}\n","import {Utils, MapOf, IRef, FieldValue} from \"@sinequa/core/base\";\nimport {AppService} from \"../app.service\";\nimport {AppServiceHelpers} from \"../app-service-helpers\";\nimport {CCColumn, EngineType} from \"@sinequa/core/web-services\";\nimport {IntlService} from \"@sinequa/core/intl\";\nimport {FormatService} from \"../format.service\";\n\n/**\n * Describes a context for processing expressions\n */\nexport interface ExprContext {\n    appService: AppService;\n    formatService: FormatService;\n    intlService: IntlService;\n    disallowFulltext?: boolean;\n}\n\n/**\n * The operators accepted in fielded search expressions\n */\nexport const enum ExprOperator {\n    none,\n    eq,\n    gt,\n    gte,\n    lt,\n    lte,\n    neq,\n    regex,\n    like,\n    contains,\n    in,\n    between\n}\n\n/**\n * The range operators accepted in fielded search expressions\n */\nexport const enum ExprRange {\n    none,\n    gteLte,\n    gteLt,\n    gtLte,\n    gtLt\n}\n\n/**\n * An object containing the data necessary to format an `Expr` using\n * [IntlService.formatMessage]{@link IntlService#formatMessage}\n */\nexport interface ExprMessage {\n    /**\n     * The `IntlService` compatible message string\n     */\n    message: string;\n    /**\n     * Any values referenced by `message`\n     */\n    values?: {\n        [key: string]: FieldValue\n    };\n}\n\n/**\n * Options to be used with `Expr.toMessage`\n */\nexport interface ExprMessageOptions {\n    /**\n     * If `true`, field names are included in the message\n     */\n    withFields?: boolean;\n    /**\n     * If `true`, use any display value set in the expression\n     */\n    useDisplay?: boolean;\n    /**\n     * Include HTML formatting in the message\n     */\n    asHTML?: boolean;\n    /**\n     * If `true`, don't include any outer `NOT` operator in the message\n     */\n    hideOuterNot?: boolean;\n}\n\n/**\n * @ignore\n */\ninterface ExprMessageCtxt {\n    inner: boolean;\n    message: string[];\n    values: {\n        [key: string]: FieldValue\n    };\n    valueIndex: number;\n}\n\n/**\n * Describes a location in a fielded search expression\n */\nexport interface ExprLocation {\n    start: number;\n    length: number;\n}\n\n/**\n * Describes a location and value in a fielded search expression\n */\nexport interface ExprValueLocation extends ExprLocation {\n    value: string;\n}\n\n/**\n * Describes a location, value and field in a fielded search expression\n */\nexport interface ExprValueInfo extends ExprValueLocation {\n    field: string;\n}\n\n/**\n * Describes the data used in [Expr.evaluate]{@link Expr#evaluate}\n */\nexport interface ExprEvaluationContext {\n    [key: string]: any;\n}\n\n/**\n * Describes an initialization object used in the construction of an {@link Expr} from a value\n */\nexport interface ExprValueInitializer {\n    /**\n     * The expression context\n     */\n    exprContext: ExprContext;\n    /**\n     * A single value\n     */\n    value?: string;\n    /**\n     * An array of values\n     */\n    values?: string[];\n    /**\n     * Locations of the values used in range expressions\n     */\n    locations?: ExprLocation[];\n    /**\n     * The operator used in the expression\n     */\n    operator?: ExprOperator;\n    /**\n     * The field name\n     */\n    field?: string;\n    /**\n     * The display value\n     */\n    display?: string;\n}\n\n/**\n * Describes an initialization object used in the construction of a boolean {@link Expr} with a pair of operands\n */\nexport interface ExprOperandsInitializer {\n    /**\n     * The expression context\n     */\n    exprContext: ExprContext;\n    /**\n     * The first operand\n     */\n    op1: Expr;\n    /**\n     * If `true` this `Expr` represents an `AND` expression, otherwise it represents an `OR` expression\n     */\n    and: boolean;\n    /**\n     * The second operand\n     */\n    op2: Expr;\n    /**\n     * The field name\n     */\n    field?: string;\n    /**\n     * The display value\n     */\n    display?: string;\n}\n\n/**\n * Represents a parsed fielded search expression. A tree of expression nodes is built when an expression\n * combines sub-expressions using boolean operators\n */\nexport class Expr {\n\n    private _field: string | undefined = undefined;\n\n    /**\n     * Return the field name of this expression. Return the first ancestor's non-empty field\n     * if the field on this node is empty\n     */\n    public get field(): string | undefined {\n        let expr: Expr = this;\n        while (expr) {\n            if (!Utils.isEmpty(expr._field)) {\n                return expr._field;\n            }\n            expr = expr.parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * Set the field name of this expression\n     */\n    public set field(value: string | undefined) {\n        this._field = value;\n    }\n\n    private _display: string | undefined = undefined;\n    private _displayObj: {label?: string, display?: string} | undefined = undefined;\n\n    /**\n     * Return the display value of this expression. Return the first ancestor's non-empty display value\n     * if the display value on this node is empty\n     */\n    public get display(): string | undefined {\n        let expr: Expr = this;\n        while (expr) {\n            if (!Utils.isEmpty(expr._display)) {\n                return expr._display;\n            }\n            expr = expr.parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * Set the display value of this expression. If the display value is a valid stringified JSON object\n     * then set `displayObj` to the parsed object\n     */\n    public set display(value: string | undefined) {\n        this._display = value;\n        if (!this._display) {\n            this._displayObj = undefined;\n        }\n        else {\n            if (this._display[0] === \"{\" && this._display[this._display.length - 1] === \"}\") {\n                try {\n                    this._displayObj = Utils.fromJson(this._display);\n                }\n                catch (e) {\n                    this._displayObj = undefined;\n                }\n            }\n            else {\n                this._displayObj = undefined;\n            }\n        }\n    }\n\n    /**\n     * Return the display object of this expression. Return the first ancestor's non-empty display object\n     * if the display object on this node is empty\n     */\n    public get displayObj(): {label?: string, display?: string} | undefined {\n        let expr: Expr = this;\n        while (expr) {\n            if (expr._displayObj) {\n                return expr._displayObj;\n            }\n            expr = expr.parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * The values of this expression\n     */\n    public values: string[] | undefined = undefined;\n    /**\n     * The locations of the values of this expression\n     */\n    public locations: ExprLocation[] | undefined;\n\n    /**\n     * Return the value of this expression. Note that range expressions may have multiple values\n     */\n    public get value(): string | undefined {\n        if (!this.values || this.values.length === 0) {\n            return undefined;\n        }\n        return this.values[0];\n    }\n\n    /**\n     * Set the value of this expression\n     */\n    public set value(value: string | undefined) {\n        if (value === undefined) {\n            this.values = undefined;\n        }\n        else {\n            if (!this.values) {\n                this.values = [];\n            }\n            this.values[0] = value;\n            this.values.length = 1;\n        }\n    }\n\n    /**\n     * The operator of this expression\n     */\n    public operator: ExprOperator;\n    /**\n     * If `true` then this expression included the `NOT` boolean operator\n     */\n    public not: boolean;\n    /**\n     * If `true` then the operands of this expression are combined with the `AND` operator.\n     * Otherwise the operands are combined with the `OR` operator\n     */\n    public and: boolean;\n    /**\n     * The operands of this expression, if any\n     */\n    public operands: Expr[];\n    /**\n     * The parent expression, if any\n     */\n    public parent: Expr;\n    /**\n     * The expression context\n     */\n    public exprContext: ExprContext;\n    /**\n     * The distance specified in a `NEAR` expression\n     */\n    public near: number;\n    /**\n     * The position of this expression's value in the original text\n     */\n    public start: number;\n    /**\n     * The length of this expression's value in the original text\n     */\n    public length: number;\n    private mergedStructured: boolean;\n\n    // for evaluate\n    private _evaluationRegExps: MapOf<RegExp | undefined>;\n    private get evaluationRegExps(): MapOf<RegExp | undefined> {\n        if (!this._evaluationRegExps) {\n            this._evaluationRegExps = {};\n        }\n        return this._evaluationRegExps;\n    }\n\n    constructor(init: ExprValueInitializer | ExprOperandsInitializer) {\n        if (!(<ExprOperandsInitializer>init).op1) {\n            const valueInit: ExprValueInitializer = <ExprValueInitializer>init;\n            this.exprContext = valueInit.exprContext;\n            if (!Utils.isUndefined(valueInit.value)) {\n                this.value = ExprParser.unescape(valueInit.value);\n            }\n            else if (!Utils.isUndefined(valueInit.values)) {\n                this.values = ExprParser.unescapeList(valueInit.values);\n            }\n            this.locations = valueInit.locations;\n            this.field = valueInit.field;\n            this.display = valueInit.display;\n            this.operator = !Utils.isUndefined(valueInit.operator) ? valueInit.operator : ExprOperator.none;\n            this.near = -1;\n            this.start = -1;\n            this.length = 0;\n        }\n        else {\n            const opsInit: ExprOperandsInitializer = init as ExprOperandsInitializer;\n            this.exprContext = opsInit.exprContext;\n            this.field = opsInit.field;\n            this.display = opsInit.display;\n            this.addOperand(opsInit.op1);\n            this.addOperand(opsInit.op2);\n            this.and = opsInit.and;\n            this.near = -1;\n            this.start = -1;\n            this.length = 0;\n        }\n    }\n\n    /**\n     * Add an operand to this expression\n     *\n     * @param operand The operand to add\n     * @param contextField The parser's field context, if any\n     * @param prepend If `true` the operand is prepended to the operands\n     */\n    public addOperand(operand: Expr, contextField?: string, prepend = false) {\n        if (Utils.isUndefined(contextField)) {\n            contextField = this.field;\n        }\n        if (!this.operands) {\n            this.operands = [];\n        }\n        if (!Utils.isEmpty(this.field) && Utils.isEmpty(operand.field) && !operand.isStructured) {\n            if (Utils.isEmpty(contextField)) {\n                // Prefer setting the fields explicitly on the target operands rather the Field to \"text\" on the source operand\n                // operand.field = ExprParser.fieldPartnamePrefix + \"text\";\n                for (const expr of this.operands) {\n                    if (Utils.isEmpty(expr._field)) {\n                        expr._field = this.field;\n                    }\n                }\n                this.field = undefined;\n            }\n        }\n        if (!Utils.eqNC(this.field || \"\", operand.field || \"\")) {\n            operand._field = operand.field;\n        }\n        else {\n            operand._field = undefined;\n        }\n        if (!Utils.isEmpty(this.display)) {\n            operand._display = undefined;\n        }\n        if (prepend) {\n            this.operands.unshift(operand);\n        }\n        else {\n            this.operands.push(operand);\n        }\n        operand.parent = this;\n    }\n\n    /**\n     * Return `true` if this expression is a leaf node (does have a value)\n     */\n    public get isLeaf(): boolean {\n        // if (this.value === null && !this.operands) throw \"Expr.isLeaf - bad expression\";\n        return !!this.value;\n    }\n\n    /**\n     * Make an expression object\n     *\n     * @param exprContext The expression context\n     * @param text The value of the expression\n     * @param field The parser's field context\n     * @param display The display value\n     * @param allowEmptyValue Determines how empty values will be processed when making the expression\n     */\n    public static makeExpr(exprContext: ExprContext, text: string, field: string, display: string, allowEmptyValue: boolean): Expr | undefined {\n        if (!Expr.getIsStructuredField(exprContext, Expr.resolveField(exprContext, field))) {\n            return new Expr({\n                exprContext: exprContext,\n                value: text,\n                field: field,\n                display: display\n            });\n        }\n\n        const values: IRef<string[] | undefined> = {value: undefined};\n        const locations: IRef<ExprLocation[] | undefined> = {value: undefined};\n        const operator: IRef<ExprOperator> = {value: ExprOperator.none};\n        const range: IRef<ExprRange> = {value: ExprRange.none};\n        Expr.parseValue(exprContext, text, field, allowEmptyValue, values, locations, operator, range);\n        if (range.value !== ExprRange.none && values.value && locations.value) {\n            const value1 = values.value[0];\n            const value2 = values.value[1];\n            const location1 = locations.value[0];\n            const location2 = locations.value[1];\n            if (range.value === ExprRange.gteLte && !Utils.eqNC(value1, \"*\") && !Utils.eqNC(value2, \"*\")) {\n                return new Expr({\n                    exprContext: exprContext,\n                    values: values.value,\n                    locations: locations.value,\n                    field: field,\n                    display: display,\n                    operator: ExprOperator.between\n                });\n            }\n            const expr1 = !Utils.eqNC(value1, \"*\") ? new Expr({\n                exprContext: exprContext,\n                value: value1,\n                locations: [location1],\n                field: field,\n                display: display,\n                operator: range.value === ExprRange.gteLt || range.value === ExprRange.gteLte ? ExprOperator.gte : ExprOperator.gt\n            }) : null;\n            const expr2 = !Utils.eqNC(value2, \"*\") ? new Expr({\n                exprContext: exprContext,\n                value: value2,\n                locations: [location2],\n                field: field,\n                display: display,\n                operator: range.value === ExprRange.gteLte || range.value === ExprRange.gtLte ? ExprOperator.lte : ExprOperator.lt\n            }) : undefined;\n            if (!expr1 && !expr2) {\n                return undefined;\n            }\n            if (!(!!expr1 && !!expr2)) return !!expr1 ? expr1 : expr2;\n            return new Expr({\n                exprContext: exprContext,\n                op1: expr1,\n                and: true,\n                op2: expr2,\n                display: display\n            });\n        }\n        return new Expr({\n            exprContext: exprContext,\n            values: values.value,\n            locations: locations.value,\n            field: field,\n            display: display,\n            operator: operator.value\n        });\n    }\n\n    private static resolveField(exprContext: ExprContext, field: string | null | undefined): string {\n        if (Utils.isString(field)) {\n            return exprContext.appService.resolveColumnName(field);\n        }\n        return \"\";\n    }\n\n    private static getColumn(exprContext: ExprContext, field: string | undefined): CCColumn | undefined {\n        return exprContext.appService.getColumn(field);\n    }\n\n    /**\n     * Return the {@link CCColumn} corresponding to this expression\n     */\n    get column(): CCColumn | undefined {\n        return Expr.getColumn(this.exprContext, this.field);\n    }\n\n    private static getIsStructuredField(exprContext: ExprContext, field: string | undefined): boolean {\n        if (!field) {\n            return false;\n        }\n        if (exprContext.disallowFulltext) {\n            return true;\n        }\n        else {\n            if (field[0] === \":\") {\n                return false; // :: => take partname over column\n            }\n            if (Utils.eqNCN(field, \"exists\", \"missing\")) {\n                return true;\n            }\n            return !!Expr.getColumn(exprContext, field);\n        }\n    }\n\n    /**\n     * Return `true` if the expression has a non-fulltext field. In this case the expression will be a leaf node\n     */\n    get isStructuredField(): boolean {\n        if (!this.isLeaf) {\n            return false;\n        }\n        return Expr.getIsStructuredField(this.exprContext, this.field);\n    }\n\n    /**\n     * Return `true` if the expression only contains non-fulltext fields\n     */\n    public get isStructured(): boolean {\n        if (this.mergedStructured) {\n            return true;\n        }\n        if (this.isLeaf) {\n            return this.isStructuredField;\n        }\n        if (!this.operands) {\n            return false;\n        }\n        for (const operand of this.operands) {\n            if (!operand.isStructured) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return `true` if the expression and its ancestors do not have `not` set to `true`\n     */\n    public get isPositive(): boolean {\n        let positive = true;\n        let current: Expr = this;\n        while (current != null) {\n            positive = positive && !current.not;\n            current = current.parent;\n        }\n        return positive;\n    }\n\n    /**\n     * Return an `ExprValueLocation` object for the passed text. Leading and trailing\n     * whitespace is excluded\n     */\n    static getValueAndLocation(text: string): ExprValueLocation {\n        let start = 0;\n        let length = text.length;\n        const value1 = Utils.trimStart(text);\n        start += length - value1.length;\n        length -= length - value1.length;\n        const value2 = Utils.trimEnd(value1);\n        length -= length - value2.length;\n        return {\n            value: value2,\n            start: start,\n            length: length\n        };\n    }\n\n    private static parseValue(exprContext: ExprContext, text: string, field: string, allowEmptyValue: boolean, values: IRef<string[] | undefined>, locations: IRef<ExprLocation[] | undefined>, operator: IRef<ExprOperator>, range: IRef<ExprRange>) {\n        if (Utils.isEmpty(text) && !allowEmptyValue) {\n            return;\n        }\n        const first = text[0];\n        const last = text[text.length - 1];\n        let vl: ExprValueLocation;\n        if (\"[{\".includes(first) && \"]}\".includes(last)) {\n            text = text.substr(1, text.length - 2);\n            let sepLen = 4;\n            let sep = text.indexOf(\" TO \");\n            if (sep === -1) {\n                sepLen = 2;\n                sep = text.indexOf(\"..\");\n            }\n            if (sep === -1) {\n                const vls = ExprParser.valuesAndLocationsFromText(text, ',');\n                values.value = [];\n                locations.value = [];\n                vls.forEach(vl1 => {\n                    values.value!.push(vl1.value);\n                    locations.value!.push({start: 1 + vl1.start, length: vl1.length});\n                });\n                operator.value = ExprOperator.in;\n                return;\n            }\n            vl = Expr.getValueAndLocation(text.substr(0, sep));\n            values.value = [vl.value];\n            locations.value = [{start: 1 + vl.start, length: vl.length}];\n            vl = Expr.getValueAndLocation(text.substr(sep + sepLen));\n            values.value.push(vl.value);\n            locations.value.push({start: 1 + sep + sepLen + vl.start, length: vl.length});\n            if (first === \"[\") {\n                range.value = last === \"]\" ? ExprRange.gteLte : ExprRange.gteLt;\n            }\n            else { // '{'\n                range.value = last === \"}\" ? ExprRange.gtLt : ExprRange.gtLte;\n            }\n            return;\n        }\n        vl = {\n            value: text,\n            start: 0,\n            length: text.length\n        };\n        if (text.startsWith(\"=\")) {\n            operator.value = ExprOperator.eq;\n            vl = Expr.getValueAndLocation(text.substr(1));\n            vl.start += 1;\n        }\n        else if (text.startsWith(\">=\")) {\n            operator.value = ExprOperator.gte;\n            vl = Expr.getValueAndLocation(text.substr(2));\n            vl.start += 2;\n        }\n        else if (text.startsWith(\">\")) {\n            operator.value = ExprOperator.gt;\n            vl = Expr.getValueAndLocation(text.substr(1));\n            vl.start += 1;\n        }\n        else if (text.startsWith(\"<=\")) {\n            operator.value = ExprOperator.lte;\n            vl = Expr.getValueAndLocation(text.substr(2));\n            vl.start += 2;\n        }\n        else if (text.startsWith(\"<>\")) {\n            operator.value = ExprOperator.neq;\n            vl = Expr.getValueAndLocation(text.substr(2));\n            vl.start += 2;\n        }\n        else if (text.startsWith(\"<\")) {\n            operator.value = ExprOperator.lt;\n            vl = Expr.getValueAndLocation(text.substr(1));\n            vl.start += 1;\n        }\n        else if (text.startsWith(\"~\")) {\n            operator.value = ExprOperator.regex;\n            vl = Expr.getValueAndLocation(text.substr(1));\n            vl.start += 1;\n        }\n        else if (text.length > 1 && text.startsWith(\"/\") && text.endsWith(\"/\")) {\n            operator.value = ExprOperator.regex;\n            vl.value = text.substr(1, text.length - 2);\n            vl.start = 1;\n            vl.length = vl.value.length;\n        }\n        if (text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\")) {\n            vl.value = text.substr(1, text.length - 2);\n            vl.start = 1;\n            vl.length = vl.value.length;\n        }\n        values.value = [vl.value];\n        locations.value = [{start: vl.start, length: vl.length}];\n    }\n\n    private static getOperatorText(operator: ExprOperator): string {\n        switch (operator) {\n            case ExprOperator.eq: return \"=\";\n            case ExprOperator.gt: return \">\";\n            case ExprOperator.gte: return \">=\";\n            case ExprOperator.lt: return \"<\";\n            case ExprOperator.lte: return \"<=\";\n            case ExprOperator.neq: return \"<>\";\n            case ExprOperator.regex: return \"REGEXP\";\n            case ExprOperator.like: return \"LIKE\";\n            case ExprOperator.contains: return \"CONTAINS\";\n            case ExprOperator.in: return \"IN\";\n            case ExprOperator.between: return \"BETWEEN\";\n            default: return \"=\";\n        }\n    }\n\n    /**\n     * Find the first `ExprValueInfo` object from a starting position in this expression\n     *\n     * @param start The position at which to start the search\n     */\n    findValue(start: number): ExprValueInfo | undefined {\n        if (this.isLeaf) {\n            if (start >= this.start && start <= this.start + this.length) {\n                if (!this.isStructured) {\n                    return {\n                        /* eslint-disable-next-line */\n                        value: this.value!,\n                        /* eslint-disable-next-line */\n                        field: this.field!,\n                        start: this.start,\n                        length: this.length\n                    };\n                }\n                else if (!!this.locations && this.values && this.values.length === this.locations.length) {\n                    for (let i = 0, ic = this.values.length; i < ic; i++) {\n                        const value = this.values[i];\n                        const location = this.locations[i];\n                        if (start >= this.start + location.start && start <= this.start + location.start + location.length) {\n                            return {\n                                value,\n                                /* eslint-disable-next-line */\n                                field: this.field!,\n                                start: this.start + location.start,\n                                length: location.length\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        else if (!!this.operands) {\n            for (const expr of this.operands) {\n                const value = expr.findValue(start);\n                if (value) {\n                    return value;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Combine two expressions into a single expression. The second expression will be added to\n     * the first expression and the first expression returned if the first expression is non-leaf\n     * and is an `AND` expression and not negated. Otherwise, a new `AND` expression will be created\n     * to which both expressions are added as operands.\n     */\n    static combine(expr1: Expr, expr2: Expr): Expr {\n        if (!expr1) {\n            return expr2;\n        }\n        if (!expr2) {\n            return expr1;\n        }\n        if (!expr1.isLeaf && expr1.and && !expr1.not) {\n            if (expr1.isLeaf || !expr2.and || expr2.not) {\n                expr1.addOperand(expr2);\n            }\n            else {\n                for (const expr3 of expr2.operands) {\n                    expr1.addOperand(expr3);\n                }\n            }\n            return expr1;\n        }\n        return new Expr({\n            exprContext: expr1.exprContext,\n            op1: expr1,\n            and: true,\n            op2: expr2\n        });\n    }\n\n    private normalizeField(field: string | undefined): string | undefined {\n        if (field && field[0] === ExprParser.fieldPartnamePrefix) {\n            return field.substr(1);\n        }\n        return field;\n    }\n\n    private shouldDisplayField(): boolean {\n        if (!this.field && !this.parent) { // top level full text\n            return true;\n        }\n        return !!this.field && (!this.parent || !Utils.eqNC(this.field, this.parent.field || \"\"));\n    }\n\n    private getOperatorString(): string {\n        if (this.operator === ExprOperator.none || this.operator === ExprOperator.eq) {\n            return \"\";\n        }\n        return Expr.getOperatorText(this.operator);\n    }\n\n    private escapeValue(value: string | null | undefined): string {\n        if (!!value && !!this.column && (AppServiceHelpers.isString(this.column) || AppServiceHelpers.isCsv(this.column))) {\n            return ExprParser.escape(value);\n        }\n        return value || \"\";\n    }\n\n    private getValueString(): string {\n        if (this.operator === ExprOperator.between && this.values && this.values.length === 2) {\n            return `[${this.escapeValue(this.values[0])}..${this.escapeValue(this.values[1])}]`;\n        }\n        if (this.values && this.values.length > 1) {\n            const sb: string[] = [];\n            for (const value of this.values) {\n                if (sb.length > 0) {\n                    sb.push(\", \");\n                }\n                sb.push(this.escapeValue(value));\n            }\n            sb.unshift(\"[\");\n            sb.push(\"]\");\n            return sb.join(\"\");\n        }\n        return this.escapeValue(this.value);\n    }\n\n    private addFieldToString(sb: string[]): boolean {\n        let added = false;\n        if (this.shouldDisplayField()) {\n            sb.push(this.normalizeField(this.field) || \"text\");\n            added = true;\n        }\n        if (this.display) {\n            sb.push(ExprParser.escape(this.display));\n            added = true;\n        }\n        if (added) {\n            sb.push(\":\");\n        }\n        return added;\n    }\n\n    private _toString(withFields: boolean, inner: boolean): string {\n        const sb: string[] = [];\n        if (this.isLeaf) {\n            if (this.not) {\n                sb.push(\"NOT \");\n            }\n            if (withFields) {\n                this.addFieldToString(sb);\n            }\n            sb.push(this.getOperatorString());\n            sb.push(this.getValueString());\n        }\n        else {\n            if (!this.operands) {\n                return \"\";\n            }\n            if (this.not) {\n                sb.push(\"NOT \");\n            }\n            let bracketed = inner;\n            if (this.addFieldToString(sb)) {\n                bracketed = true;\n            }\n            if (bracketed) {\n                sb.push(\"(\");\n            }\n            let first = true;\n            for (const operand of this.operands) {\n                if (!first) {\n                    if (this.and) {\n                        sb.push(\" AND \");\n                    }\n                    else {\n                        sb.push(\" OR \");\n                    }\n                }\n                first = false;\n                sb.push(operand._toString(withFields, true));\n            }\n            if (bracketed) {\n                sb.push(\")\");\n            }\n        }\n        return sb.join(\"\");\n    }\n\n    /**\n     * Return a string representation of this expression\n     *\n     * @param withFields If `true`, include field names\n     */\n    toString(withFields = true): string {\n        return this._toString(withFields, false);\n    }\n\n    private addDisplay(options: ExprMessageOptions, ctxt: ExprMessageCtxt, display: string) {\n        this._addValue(options, ctxt, this.value || \"\", display);\n    }\n\n    private encodeHTML(text: string, options: ExprMessageOptions): string {\n        if (options && options.asHTML) {\n            return Utils.encodeHTML(text);\n        }\n        else {\n            return text;\n        }\n    }\n\n    private _addValue(options: ExprMessageOptions, ctxt: ExprMessageCtxt, value: string, display?: string) {\n        if (options.asHTML) {\n            ctxt.message.push(`<span class=\"sq-value\">`);\n        }\n        const column = this.exprContext.appService.getColumn(this.field);\n        const valueId = `value${ctxt.valueIndex++}`;\n        let _value: FieldValue = value;\n        let _display: string | undefined;\n        if (display) {\n            _display = this.encodeHTML(ExprParser.unescape(display), options);\n        }\n        if (column && AppServiceHelpers.isNumber(column) && Utils.testFloat(value)) {\n            _value = +value;\n        }\n        else if (column && AppServiceHelpers.isDate(column)) {\n            _value = Utils.fromSysDateStr(value) || value;\n        }\n        else if (column && AppServiceHelpers.isBoolean(column)) {\n            _value = Utils.isTrue(value);\n        }\n        else if (Utils.isString(_value)) {\n            _value = this.encodeHTML(_value, options);\n        }\n        ctxt.message.push(`{${valueId}}`);\n        ctxt.values[valueId] = column\n            ? this.exprContext.formatService.formatFieldValue({value: _value, display: _display}, column)\n            : _display || _value;\n        if (options.asHTML) {\n            ctxt.message.push(`</span>`);\n        }\n    }\n\n    private addValue(options: ExprMessageOptions, ctxt: ExprMessageCtxt) {\n        if (this.values) {\n            if (this.operator === ExprOperator.between && this.values.length === 2) {\n                this._addValue(options, ctxt, this.values[0]);\n                ctxt.message.push(\" \");\n                this.addOperator(\"AND\", options, ctxt);\n                ctxt.message.push(\" \");\n                this._addValue(options, ctxt, this.values[1]);\n            }\n            else if (this.values.length > 1) {\n                let first = true;\n                for (const value of this.values) {\n                    ctxt.message.push(first ? \"[\" : \", \");\n                    first = false;\n                    this._addValue(options, ctxt, value);\n                }\n                ctxt.message.push(\"]\");\n            }\n            else {\n                this._addValue(options, ctxt, this.values[0]);\n            }\n        }\n    }\n\n    private addText(options: ExprMessageOptions, ctxt: ExprMessageCtxt, text: string) {\n        const valueId = `value${ctxt.valueIndex++}`;\n        const message = `{${valueId}}`;\n        ctxt.message.push(message);\n        ctxt.values[valueId] = this.encodeHTML(text, options);\n    }\n\n    private addFieldLabel(options: ExprMessageOptions, ctxt: ExprMessageCtxt) {\n        const displayObj = this.displayObj;\n        if (displayObj && displayObj.label) {\n            this.addText(options, ctxt, displayObj.label);\n        }\n        else if (this.field) {\n            const label = this.exprContext.appService.getLabel(this.normalizeField(this.field) || \"\");\n            this.addText(options, ctxt, label);\n        }\n        else {\n            if (!this.isStructured) {\n                const label = this.exprContext.appService.getLabel(\"text\");\n                this.addText(options, ctxt, label);\n            }\n            else {\n                const fields = this.getFields();\n                fields.forEach((field, index) => {\n                    if (index !== 0) {\n                        this.addText(options, ctxt, \"/\");\n                    }\n                    const label = this.exprContext.appService.getLabel(field);\n                    this.addText(options, ctxt, label);\n                });\n            }\n        }\n    }\n\n    private addField(options: ExprMessageOptions, ctxt: ExprMessageCtxt) {\n        if (options.asHTML) {\n            ctxt.message.push(`<span class=\"sq-field\">`);\n        }\n        this.addFieldLabel(options, ctxt);\n        if (options.asHTML) {\n            ctxt.message.push(`</span>`);\n            ctxt.message.push(`<span class=\"sq-separator\">`);\n        }\n        this.addText(options, ctxt, \"msg#system.fieldSeparator\");\n        if (options.asHTML) {\n            ctxt.message.push(`</span>`);\n        }\n    }\n\n    private addOperator(operator: string, options: ExprMessageOptions, ctxt: ExprMessageCtxt) {\n        if (!operator) {\n            return;\n        }\n        if (options.asHTML) {\n            ctxt.message.push(`<span class=\"sq-operator\">`);\n        }\n        ctxt.message.push(this.encodeHTML(operator, options));\n        if (options.asHTML) {\n            ctxt.message.push(`</span>`);\n        }\n    }\n\n    private _toMessage(ctxt: ExprMessageCtxt, options?: ExprMessageOptions): ExprMessage {\n        const inner = ctxt.inner;\n        ctxt.inner = true;\n        if (!options) {\n            options = {};\n        }\n        if (Utils.isUndefined(options.useDisplay)) {\n            options.useDisplay = true;\n        }\n\n        const displayObj = this.displayObj;\n        const display = (displayObj ? displayObj.display : undefined) || this.display;\n        const showNot = this.not && (inner || !options.hideOuterNot);\n        const showField = (options.withFields || inner) && this.shouldDisplayField();\n        if (options.useDisplay && !!display) {\n            if (showNot) {\n                this.addOperator(\"NOT\", options, ctxt);\n                ctxt.message.push(\" \");\n            }\n            if (showField) {\n                this.addField(options, ctxt);\n            }\n            this.addDisplay(options, ctxt, display);\n        }\n        else if (this.isLeaf) {\n            if (showNot) {\n                this.addOperator(\"NOT\", options, ctxt);\n                ctxt.message.push(\" \");\n            }\n            if (showField) {\n                this.addField(options, ctxt);\n            }\n            const operator = this.getOperatorString();\n            if (operator) {\n                this.addOperator(operator, options, ctxt);\n                ctxt.message.push(\" \");\n            }\n            this.addValue(options, ctxt);\n        }\n        else {\n            if (!this.operands) {\n                return {message: \"\"};\n            }\n            if (showNot) {\n                this.addOperator(\"NOT\", options, ctxt);\n                ctxt.message.push(\" \");\n            }\n            let bracketed = inner;\n            if (showField) {\n                this.addField(options, ctxt);\n                bracketed = true;\n            }\n            if (bracketed) {\n                ctxt.message.push(\"(\");\n            }\n            let first = true;\n            for (const operand of this.operands) {\n                if (!first) {\n                    if (this.and) {\n                        ctxt.message.push(\" \");\n                        this.addOperator(\"AND\", options, ctxt);\n                        ctxt.message.push(\" \");\n                    }\n                    else {\n                        ctxt.message.push(\" \");\n                        this.addOperator(\"OR\", options, ctxt);\n                        ctxt.message.push(\" \");\n                    }\n                }\n                first = false;\n                operand._toMessage(ctxt, options);\n            }\n            if (bracketed) {\n                ctxt.message.push(\")\");\n            }\n        }\n        if (inner) {\n            return {message: \"\"};\n        }\n        return {\n            message: ctxt.message.join(\"\"),\n            values: ctxt.values\n        };\n    }\n\n    /**\n     * Return an `ExprMessage` for the expression which can be used with [IntlService.formatMessage]{@link IntlService#formatMessage}\n     * for display purposes\n     */\n    toMessage(options?: ExprMessageOptions): ExprMessage {\n        return this._toMessage({\n            inner: false,\n            message: [\"txt#\"],\n            values: {},\n            valueIndex: 0\n        }, options);\n    }\n\n    private static matchNode(context: ExprContext, expr1: Expr, expr2: Expr): boolean {\n        if (expr1.isLeaf !== expr2.isLeaf) {\n            return false;\n        }\n        if (expr1.isLeaf) {\n            if (expr1.isStructured !== expr2.isStructured) {\n                return false;\n            }\n            if (expr1.not !== expr2.not) {\n                return false;\n            }\n            const field1 = context.appService.resolveColumnAlias(expr1.field);\n            const field2 = context.appService.resolveColumnAlias(expr2.field);\n            if (field1 !== field2) {\n                return false;\n            }\n            const operator1 = expr1.operator === ExprOperator.none ? ExprOperator.eq : expr1.operator;\n            const operator2 = expr2.operator === ExprOperator.none ? ExprOperator.eq : expr2.operator;\n            if (operator1 !== operator2) {\n                return false;\n            }\n        }\n        if (!expr1.isLeaf) {\n            if (expr1.and !== expr2.and) {\n                return false;\n            }\n            // All of the structured and non-structured operands in expr2 must be in expr1 so check that there are at least enough\n            // operands available. (The actual matching of the contents of the operand nodes is done in the recursive calls to MatchNode)\n            if (!expr1.operands !== !expr2.operands) {\n                return false;\n            }\n            let expr1StructuredCount = 0, expr1UnstructuredCount = 0, expr2StructuredCount = 0, expr2UnstructuredCount = 0;\n            expr1.operands.forEach((operand) => { if (operand.isStructured) { expr1StructuredCount++; } else { expr1UnstructuredCount++; }});\n            expr2.operands.forEach((operand) => { if (operand.isStructured) { expr2StructuredCount++; } else { expr2UnstructuredCount++; }});\n            if ((expr2StructuredCount > expr1StructuredCount) || (expr2UnstructuredCount > expr1UnstructuredCount)) {\n                return false;\n            }\n        }\n        const values1Length = expr1.values ? expr1.values.length : 0;\n        const values2Length = expr2.values ? expr2.values.length : 0;\n        if (values1Length !== values2Length) {\n            return false;\n        }\n        if (values1Length && expr1.values && expr2.values) {\n            for (const value1 of expr1.values) {\n                let found = false;\n                for (const value2 of expr2.values) {\n                    if (Utils.eqNC(value1, value2)) {\n                        found = true;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return `true` if this expression matches the passed one\n     */\n    matchNode(expr: Expr): boolean {\n        return Expr.matchNode(this.exprContext, this, expr);\n    }\n\n    /**\n     * Returns the matching expression or sub-expression in this expression with the passed one.\n     *\n     * @param expr The expression to match\n     * @param filter An option filter function called on first level candidate sub-expressions\n     * before matching within them\n     */\n    find(expr: Expr, filter?: (expr: Expr) => boolean): Expr | null {\n        if (this.matchNode(expr)) {\n            if (!this.isLeaf && this.operands) {\n                for (const child1 of expr.operands) {\n                    let found = false;\n                    for (const child2 of this.operands) {\n                        if (filter && filter(child2)) {\n                            continue;\n                        }\n                        if (child2.find(child1)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        return null;\n                    }\n                }\n            }\n            return this;\n        }\n        else {\n            if (!this.isLeaf && this.operands) {\n                for (const child of this.operands) {\n                    if (filter && filter(child)) {\n                        continue;\n                    }\n                    if (child.find(expr)) {\n                        return child;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Perform the passed `action` on this expression and any descendant operands\n     *\n     * @param action The action to perform\n     */\n    forEach(action: (expr: Expr) => void) {\n        action(this);\n        if (this.operands) {\n            for (const operand of this.operands) {\n                operand.forEach(action);\n            }\n        }\n    }\n\n    /**\n     * Execute the callback function on this node and any descendants until the callback returns a truthy value\n     * in which case immediately return `true`. Otherwise return `false`.\n     */\n    some(callback: (expr: Expr) => boolean): boolean {\n        if (callback(this)) {\n            return true;\n        }\n        if (this.operands) {\n            for (const operand of this.operands) {\n                if (operand.some(callback)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Execute the callback function on this node and any descendants until the callback returns a falsy value\n     * in which case, immediately return `false`. Otherwise return `true`.\n     */\n    every(callback: (expr: Expr) => boolean): boolean {\n        if (!callback(this)) {\n            return false;\n        }\n        if (this.operands) {\n            for (const operand of this.operands) {\n                if (!operand.every(callback)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return `true` if the exoression has at least one fulltext operand.\n     * The test on `isPositive` filters expressions that only contain\n     * negative fulltext terms which will be ignored on the server. Fulltext\n     * expressions must have at least one positive term.\n     */\n    get hasRelevance(): boolean {\n        return this.some(expr => expr.isLeaf && !expr.isStructured && expr.isPositive);\n    }\n\n    /**\n     * Return an array of all fields used in this expression\n     */\n    getFields(): string[] {\n        const fields: string[] = [];\n        this.forEach((expr) => {\n            const field = this.exprContext.appService.resolveColumnAlias(expr.field);\n            if (field) {\n                if (!fields.find((field1) => Utils.eqNC(field, field1))) {\n                    fields.push(field);\n                }\n            }\n        });\n        return fields;\n    }\n\n    /**\n     * Return an array of all values used in this expression that pertain to the passed field and where the associated `isPositive`\n     * field matches the passed `positive` parameter\n     *\n     * @param field The field for which values are to be returned\n     * @param positive The value to test against `isPositive`\n     */\n    getValues(field: string, positive = true): string[] {\n        const values: string[] = [];\n        const column = this.exprContext.appService.resolveColumnName(field);\n        this.forEach((expr) => {\n            if (column) {\n                const column1 = this.exprContext.appService.resolveColumnName(expr.field);\n                if (!Utils.eqNC(column, column1)) {\n                    return;\n                }\n            }\n            if (expr.isLeaf && expr.isPositive === positive && expr.values) {\n                values.push(...expr.values);\n            }\n        });\n        return values;\n    }\n\n    private getDataValue(data: ExprEvaluationContext, field?: string, defaultScope?: string): any {\n        if (!data) {\n            return undefined;\n        }\n        const fields = Utils.split(field || \"\", \".\");\n        if (fields.length >= 1 && Utils.isUndefined(data[fields[0]]) && !!defaultScope) {\n            // By default, look on the \"defaultScope\" sub-object\n            fields.unshift(...Utils.split(defaultScope, \".\"));\n        }\n        let value: any = data;\n        for (const _field of fields) {\n            if (!value) {\n                break;\n            }\n            value = value[_field];\n        }\n        return value;\n    }\n\n    private getWildcardRegExp(value: string): RegExp | undefined {\n        if (value) {\n            let regExp = this.evaluationRegExps[value];\n            if (!Utils.isUndefined(regExp)) {\n                return regExp;\n            }\n            let haveWildcards = false;\n            let escaping = false;\n            const sb: string[] = [];\n            for (const ch of value) {\n                switch (ch) {\n                    // Handle wildcards and wildcard escaping\n                    case \"\\\\\":\n                        if (escaping) {\n                            sb.push(\"\\\\\\\\\");\n                            escaping = false;\n                        }\n                        else {\n                            escaping = true;\n                        }\n                        break;\n                    case \"*\":\n                        if (escaping) {\n                            sb.push(\"\\\\\");\n                            sb.push(ch);\n                            escaping = false;\n                        }\n                        else {\n                            haveWildcards = true;\n                            sb.push(\".*?\");\n                        }\n                        break;\n                    case \"?\":\n                        if (escaping) {\n                            sb.push(\"\\\\\");\n                            sb.push(ch);\n                            escaping = false;\n                        }\n                        else {\n                            haveWildcards = true;\n                            sb.push(\".\");\n                        }\n                        break;\n                    // Escape other regexp special characters\n                    case \"-\":\n                    case \"/\":\n                    case \"^\":\n                    case \"$\":\n                    case \"+\":\n                    case \".\":\n                    case \"(\":\n                    case \")\":\n                    case \"|\":\n                    case \"[\":\n                    case \"]\":\n                    case \"{\":\n                    case \"}\":\n                        sb.push(\"\\\\\");\n                        sb.push(ch);\n                        escaping = false;\n                        break;\n                    // All other characters just emit\n                    default:\n                        sb.push(ch);\n                        escaping = false;\n                        break;\n                }\n            }\n            if (haveWildcards) {\n                regExp = new RegExp(\"^\" + sb.join(\"\") + \"$\", \"i\");\n                this.evaluationRegExps[value] = regExp;\n                return regExp;\n            }\n            else {\n                this.evaluationRegExps[value] = undefined;\n            }\n        }\n        return undefined;\n    }\n\n    // NB comparisons with NaN always return false\n    private compare(value: string | string[] | undefined, dataValue: any, equality?: boolean): number {\n        if (Utils.isArray(dataValue) && dataValue.length === 0) {\n            return NaN;\n        }\n        const column = Expr.getColumn(this.exprContext, this.field || \"\");\n        if (Utils.isArray(dataValue) || Utils.isArray(value)) {\n            // \"in\" / \"contains\"\n            if (!Utils.isArray(dataValue)) {\n                dataValue = [dataValue];\n            }\n            if (Utils.isArray(value)) {\n                if (value.length === 0) {\n                    return NaN;\n                }\n            }\n            else {\n                value = [value + \"\"];\n            }\n            // At least one value in the value array must match a value in the dataValue array\n            for (const value1 of value) {\n                for (const dataValue1 of dataValue) {\n                    if (this.compare(value1, dataValue1, true) === 0) {\n                        return 0;\n                    }\n                }\n            }\n            return NaN;\n        }\n        if (!Utils.isArray(value)) {\n            value = ExprParser.unescape(value || \"\");\n            if (column && column.parser) {\n                value = this.exprContext.formatService.parseValue(value, column.parser);\n            }\n            if (AppServiceHelpers.isNumber(column)) {\n                if (!Utils.isNumber(dataValue)) {\n                    dataValue = 0;\n                }\n                const _value = Utils.toNumber(value);\n                return dataValue - _value;\n            }\n            if (AppServiceHelpers.isDate(column)) {\n                if (Utils.isString(dataValue)){\n                    dataValue = Utils.toDate(dataValue);\n                }\n                if (Utils.isDate(dataValue)) {\n                    const _value = this.exprContext.intlService.parseDate(value);\n                    if (_value) {\n                        return dataValue.getTime() - _value.getTime();\n                    }\n                }\n                return NaN;\n            }\n            if (AppServiceHelpers.isBoolean(column)) {\n                const _value = Utils.isTrue(value) ? 1 : 0;\n                return (dataValue ? 1 : 0) - _value;\n            }\n            dataValue = dataValue || \"\";\n            if (Utils.isString(dataValue)) {\n                dataValue = ExprParser.unescape(dataValue);\n                if (equality) {\n                    const regExp = this.getWildcardRegExp(value);\n                    if (regExp) {\n                        return regExp.test(dataValue) ? 0 : -1;\n                    }\n                }\n                return Utils.compare(dataValue, value);\n            }\n        }\n        return NaN;\n    }\n\n    /**\n     * Evaluate this expression using `data` to provide field values. Field values\n     * can contain scopes (full stop separated components) to reference sub-objects\n     * in the data\n     *\n     * @param data The field values to be used in the evaluation\n     * @param defaultScope If a field value cannot be resolved then try to retrieve a value with this scope prepended to the field name\n     * @return The boolean result of the expression evaluation\n     */\n    evaluate(data: ExprEvaluationContext, defaultScope?: string): boolean {\n        let ret: boolean;\n        if (this.isLeaf) {\n            if (!this.isStructured) {\n                ret = false;\n            }\n            else {\n                if (Utils.eqNC(this.field || \"\", \"exists\")) {\n                    const dataValue = this.getDataValue(data, this.value, defaultScope);\n                    ret = !Utils.isUndefined(dataValue);\n                }\n                else if (Utils.eqNC(this.field || \"\", \"missing\")) {\n                    const dataValue = this.getDataValue(data, this.value, defaultScope);\n                    ret = Utils.isUndefined(dataValue);\n                }\n                else {\n                    const dataValue = this.getDataValue(data, this.field, defaultScope);\n                    switch (this.operator) {\n                        case ExprOperator.none:\n                        case ExprOperator.eq:\n                            ret = this.compare(this.value, dataValue, true) === 0;\n                            break;\n                        case ExprOperator.gt:\n                            ret = this.compare(this.value, dataValue) > 0;\n                            break;\n                        case ExprOperator.gte:\n                            ret = this.compare(this.value, dataValue) >= 0;\n                            break;\n                        case ExprOperator.lt:\n                            ret = this.compare(this.value, dataValue) < 0;\n                            break;\n                        case ExprOperator.lte:\n                            ret = this.compare(this.value, dataValue) <= 0;\n                            break;\n                        case ExprOperator.neq:\n                            ret = this.compare(this.value, dataValue, true) !== 0;\n                            break;\n                        case ExprOperator.regex: {\n                            const regExp = new RegExp(this.value || \"\");\n                            ret = regExp.test(dataValue + \"\");\n                            break;\n                        }\n                        case ExprOperator.like: // not currently generated in parse\n                            ret = this.compare(this.value + \"*\", dataValue, true) === 0;\n                            break;\n                        case ExprOperator.in:\n                            ret = this.compare(this.values, dataValue, true) === 0;\n                            break;\n                        case ExprOperator.contains: // not currently generated in parse\n                            ret = this.compare(this.value, dataValue, true) === 0;\n                            break;\n                        case ExprOperator.between:\n                            ret = !!this.values &&\n                                this.compare(this.values[0], dataValue) >= 0 && this.compare(this.values[1], dataValue) <= 0;\n                            break;\n                    }\n                }\n            }\n        }\n        else {\n            ret = !!this.and;\n            for (const operand of this.operands) {\n                const ret1 = operand.evaluate(data, defaultScope);\n                if (this.and) {\n                    ret = ret && ret1;\n                    if (!ret) {\n                        break;\n                    }\n                }\n                else {\n                    ret = ret || ret1;\n                }\n            }\n        }\n        if (this.not) {\n            ret = !ret;\n        }\n        return ret;\n    }\n}\n\n/**\n * @ignore\n */\nexport const enum Token {\n    invalid=-1,\n    or=0,\n    and=1,\n    not=2,\n    near=3,\n    infixNear=4,\n    lPar=5,\n    rPar=6,\n    eof=7,\n    value=8\n}\n\n/**\n * @ignore\n */\nconst enum Act {\n    s,  // shift\n    r,  // reduce\n    a,  // accept\n    e1, // error : missing right parenthesis\n    e2, // error : missing operator\n    e3, // error : unbalanced right parenthesis\n    e4  // error : invalid function argument\n}\n\n/**\n * Parsing options\n */\nexport interface ExprParserOptions {\n    /**\n     * If `true` then a fielded search expression with no value will not generate an error. This would be used\n     * when providing feedback during text entry\n     */\n    allowEmptyValues?: boolean;\n    /**\n     * If `true`, fields can contain the scoping character (`.`). This is typically used with `Expr.evaluate`\n     */\n    allowScopedFields?: boolean;\n    /**\n     * If `true` then arbitrary field names are permitted. This is typically used with `Expr.evaluate`\n     */\n    disallowFulltext?: boolean;\n}\n\n/**\n * @ignore\n */\nexport class ExprParserOperator {\n    public static invalid: ExprParserOperator = new ExprParserOperator(Token.invalid);\n    public static or: ExprParserOperator = new ExprParserOperator(Token.or);\n    public static and: ExprParserOperator = new ExprParserOperator(Token.and);\n    public static not: ExprParserOperator = new ExprParserOperator(Token.not);\n    public static lPar: ExprParserOperator = new ExprParserOperator(Token.lPar);\n    public static rPar: ExprParserOperator = new ExprParserOperator(Token.rPar);\n    public static eof: ExprParserOperator = new ExprParserOperator(Token.eof);\n\n    public tok: Token;\n    public tokValue: string;\n    public tokValuePos: number;\n    public tokValueLen: number;\n\n    constructor(tok: Token, value: string = \"\", valuePos: number = -1, valueLen: number = -1) {\n        this.tok = tok;\n        this.tokValue = value;\n        this.tokValuePos = valuePos;\n        this.tokValueLen = valueLen;\n    }\n}\n\n/**\n * A parser for Sinequa fielded search expressions. Such expressions allow filters to be specified in fulltext and\n * can be combined with boolean operators to build complex queries.\n *\n * A single fielded search clause has this form:\n * ``<fieldname>[`display value`]:[:][<operator>]<value>``\n *\n * A field name is either a column name or alias or a partname. In the case of a partname and column name clashing then\n * the field is treated as a column. Two colons can be specified as the separator to denote that the field is a partname.\n * An optional display value can follow the fieldname enclosed in backquote characters\n *\n * Operators are: `=` (default), `>=`, `>`, `<=`, `<`, `~` (regexp)\n * In addition, a regular expression can be specified by enclosing the value in `/` characters\n *\n * An inclusive range of values can be specified using a square bracket syntax: `[value1..value2]`\n * An exclusive range of values can be specified using a curly bracket syntax: `{value1..value2}`\n * The brackets can be mixed. For example: `age:{5..13]` expresses `13 >= age > 5`.\n *\n * For multi-value csv fields an `IN` condition can be expressed using a comma-separated list of values enclosed in square brackets.\n * For example: `authors:[Proust, Orwell, Dickens]`\n *\n * If a value contains reserved characters then it can be enclosed in backquote characters to prevent the parser interpreting them\n * incorrectly. For example: ``code: `a:b:c` ``\n *\n * The parser also supports a NEAR operator to allow searching for terms close to each other. There are two forms suppported:\n * * infix - `term1 NEAR[/n] term2` where `n` is the maximum number of words between the two terms for them to match\n * * function - `NEAR[/n](term1, term2, term3, ...)` where `n` is \"window\" size within which all the terms must be present for them\n * to match. The minimum useful value for n is thus equal to the number of terms passed to the operator.\n *\n * Fielded search expresions can be combined with the boolean operators `AND`, `OR` and `NOT` and brackets used for grouping.\n * For example: `football (age:>=7 AND (name:smith OR name:jones))`\n */\nexport class ExprParser {\n\n    public static fieldPartnamePrefix = \"@\";\n    private static parsetbl: Act[][] = [\n    /* stk  ------------- input ------------*/\n    /*\t\t                                 INFIX                  */\n    /*\t\t         OR\t   AND\t NOT   NEAR  NEAR  (\t  )\t     $  */\n    /*OR */         [Act.r, Act.s, Act.s, Act.s, Act.s, Act.s, Act.r, Act.r],\n    /*AND*/         [Act.r, Act.r, Act.s, Act.s, Act.s, Act.s, Act.r, Act.r],\n    /*NOT*/         [Act.r, Act.r, Act.s, Act.s, Act.r, Act.s, Act.r, Act.r],\n    /*NEAR*/        [Act.r, Act.r, Act.s, Act.s, Act.r, Act.s, Act.r, Act.r],\n    /*INFIXNEAR*/   [Act.r, Act.r, Act.s, Act.s, Act.r, Act.s, Act.r, Act.r],\n    /*(*/           [Act.s, Act.s, Act.s, Act.s, Act.s, Act.s, Act.s, Act.e1],\n    /*)*/           [Act.r, Act.r, Act.r, Act.r, Act.r, Act.e2, Act.r, Act.r],\n    /*$*/           [Act.s, Act.s, Act.s, Act.s, Act.s, Act.s, Act.e3, Act.a]\n    ];\n\n    private exprContext: ExprContext;\n    private options: ExprParserOptions;\n    private expressions: Expr[];\n    private operators: ExprParserOperator[];\n    private fields: string[]; // pushed on '(', popped on ')'\n    private displays: string[]; // pushed on '(', popped on ')'\n    private op: ExprParserOperator;\n    private prevOp: ExprParserOperator;\n    private saveOp: ExprParserOperator; // for default conjunction operator\n    private field: string;\n    private display: string;\n    private text: string;\n    private current: number;\n    private length: number;\n\n    private constructor(exprContext: ExprContext, options?: ExprParserOptions) {\n        this.exprContext = exprContext;\n        this.options = options || {};\n        this.exprContext.disallowFulltext = this.options.disallowFulltext;\n        this.expressions = [];\n        this.operators = [];\n        this.fields = [];\n        this.displays = [];\n        this.text = \"\";\n        this.current = 0;\n        this.length = 0;\n        this.op = this.prevOp = this.saveOp = ExprParserOperator.invalid;\n    }\n\n    /**\n     * Escape a string so that the characters in it are not processed by the fielded search expression parser.\n     * Single occurrences of the backslash character are replaced by two backslashes and backquote characters\n     * are prefixed by a backslash. Finally, the string is enclosed in backquotes.\n     *\n     * For example: `` a\\`\\b `` => `` a\\\\\\`\\\\b ``\n     */\n    // \\ => \\\\\n    // ` => \\`\n    // then surround with ``\n    public static escape(value: string | undefined): string {\n        if (!value) {\n            return \"``\";\n        }\n        value = String(value); // make sure we have a string\n        if (value.search(/[\\\\`]/) === -1) {\n            return \"`\" + value + \"`\";\n        }\n        const sb: string[] = [\"`\"];\n        for (let i = 0, ic = value.length; i < ic; i++) {\n            const ch = value[i];\n            if (ch === \"\\\\\" || ch === \"`\") {\n                sb.push(\"\\\\\");\n            }\n            sb.push(ch);\n        }\n        sb.push(\"`\");\n        return sb.join(\"\");\n    }\n\n    private static isEscaped(value: string | undefined): boolean {\n        return !!value && value.length >= 2 && value[0] === \"`\" && value[value.length - 1] === \"`\";\n    }\n\n    /**\n     * Perform the reverse operation to [ExprParser.escpae]{@link ExprParser#escape}\n     */\n    // remove surrounding ``\n    // \\\\ => \\\n    // \\` => `\n    public static unescape(value: string): string {\n        if (!ExprParser.isEscaped(value)) {\n            return value;\n        }\n        const sb: string[] = [];\n        for (let i = 1, ic = value.length - 1; i < ic; i++) {\n            let ch = value[i];\n            if (ch === \"\\\\\") {\n                if (i >= ic - 1) { // we end with a \\ => drop it\n                    continue;\n                }\n                ch = value[++i];\n            }\n            sb.push(ch);\n        }\n        return sb.join(\"\");\n    }\n\n    /**\n     * @ignore\n     */\n    public static unescapeList(values: string[]): string[] {\n        if (!values) {\n            return values;\n        }\n        const values1: string[] = [];\n        for (let _i = 0, _a = values; _i < _a.length; _i++) {\n            const value = _a[_i];\n            values1.push(ExprParser.unescape(value));\n        }\n        return values1;\n    }\n\n    /**\n     * @ignore\n     */\n    public static valuesAndLocationsFromText(text: string, separator: string): ExprValueLocation[] {\n        if (Utils.isEmpty(text)) {\n            return [];\n        }\n        if (!text.includes(separator)) {\n            return [{value: text, start: 0, length: text.length}];\n        }\n        const values: ExprValueLocation[] = [];\n        const length = text.length;\n        let current = 0;\n        let currentStart = 0;\n        const sb: string[] = [];\n        let value: ExprValueLocation;\n        while (true) {\n            if (current >= length) {\n                value = Expr.getValueAndLocation(sb.join(\"\"));\n                value.start += currentStart;\n                if (!Utils.isEmpty(value.value)) {\n                    values.push(value);\n                }\n                break;\n            }\n            const ch = text[current];\n            if (ch === \"\\\\\") {\n                sb.push(ch);\n                current++;\n                if (current < length) {\n                    const ch1 = text[current];\n                    if (ch1 === \"\\\\\" || ch1 === \"`\") {\n                        sb.push(ch1);\n                        current++;\n                    }\n                }\n            }\n            else if (ch === \"`\") {\n                const last: IRef<number> = {value: 0};\n                const s = ExprParser.matchUntil(text, length, current, current + 1, \"`\", last);\n                if (!!s) {\n                    sb.push(s);\n                    current = last.value;\n                }\n                else {\n                    sb.push(ch);\n                    current++;\n                }\n            }\n            else if (ch === separator) {\n                value = Expr.getValueAndLocation(sb.join(\"\"));\n                value.start += currentStart;\n                sb.length = 0;\n                if (!Utils.isEmpty(value.value)) {\n                    values.push(value);\n                }\n                current++;\n                currentStart = current;\n            }\n            else {\n                sb.push(ch);\n                current++;\n            }\n        }\n        return values;\n    }\n\n    private matchKeyword(keyword: string, sbCurrentValue: string[], suffixCh?: string): boolean {\n        if (sbCurrentValue.length !== 0) {\n            const currentValue = sbCurrentValue.join(\"\");\n            if (!!currentValue && !\" \\r\\n\\t\".includes(currentValue[currentValue.length - 1])) {\n                return false;\n            }\n        }\n        if (Utils.isEmpty(keyword)) {\n            return false;\n        }\n        const keywordLen = keyword.length;\n        if (this.current + keywordLen > this.length) {\n            return false;\n        }\n        for (let i = 0, ic = keywordLen; i < ic; i++) {\n            const ch = this.text[this.current + i];\n            const kh = keyword[i];\n            if (ch !== kh) {\n                return false;\n            }\n        }\n        if (this.current + keywordLen < this.length) {\n            const nch = this.text[this.current + keywordLen];\n            if (nch !== suffixCh && !\" \\r\\n\\t(\".includes(nch)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private matchUntil(first: number, start: number, endChars: string, last: IRef<number>): string | undefined {\n        return ExprParser.matchUntil(this.text, this.length, first, start, endChars, last);\n    }\n\n    private static matchUntil(text: string, length: number, first: number, start: number, endChars: string, last: IRef<number>): string | undefined {\n        last.value = start;\n        let found = false;\n        const sb: string[] = [text.substr(first, start - first)];\n        while (last.value < length) {\n            let ch = text[last.value++];\n            if (ch === \"\\\\\") {\n                sb.push(ch);\n                if (last.value < length) {\n                    ch = text[last.value++];\n                    if (ch === \"\\\\\" || ch === \"`\") {\n                        sb.push(ch);\n                        continue;\n                    }\n                }\n            }\n            sb.push(ch);\n            if (endChars.includes(ch)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return undefined;\n        }\n        return sb.join(\"\");\n    }\n\n    private matchSimpleValue(start: number): string {\n        const first = this.current;\n        let last = start;\n        while (last < this.length) {\n            const ch = this.text[last];\n            if (\" \\r\\n\\t)\".includes(ch)) {\n                break;\n            }\n            last++;\n        }\n        if (last === start) {\n            return \"\";\n        }\n        return this.text.substr(first, last - first);\n    }\n\n    private getTerminators(ch: string, allowRanges: boolean): string {\n        if (ch === \"\\\"\") return \"\\\"\";\n        if (ch === \"[\") return allowRanges ? \"]}\" : \"]\";\n        if (ch === \"{\") return allowRanges ? \"}]\" : \"}\";\n        if (ch === \"/\") return \"/\";\n        if (ch === \"(\") return \")\";\n        if (ch === \"`\") return \"`\";\n        return \"\";\n    }\n\n    private canBeTokValue(value: string, canBeEmpty = true) {\n        return !Utils.isEmpty(value) || (canBeEmpty && this.options.allowEmptyValues && !Utils.isEmpty(this.field));\n    }\n\n    private _getTokValue(value: string, canBeEmpty = true): boolean {\n        // Current is pointing at the next non-whitepspace character after this value\n        if (value === null) return false;\n        let pos = this.current;\n        const len = value.length;\n        value = Utils.trimEnd(value);\n        pos -= len - value.length;\n        value = value.trim();\n        if (this.canBeTokValue(value, canBeEmpty)) {\n            this.op = new ExprParserOperator(Token.value, value, pos - value.length, value.length);\n            return true;\n        }\n        return false;\n    }\n\n    private getTokValue(sb: string[], canBeEmpty = true): boolean {\n        if (!sb) {\n            return false;\n        }\n        return this._getTokValue(sb.join(\"\"), canBeEmpty);\n    }\n\n    private ensureNearValue(value: string): string {\n        const defaultNearValue = this.exprContext.appService.ccquery ? this.exprContext.appService.ccquery.defaultNearValue : 0;\n        let near = Utils.toInt(value, defaultNearValue);\n        if (near < 0) {\n            near = defaultNearValue;\n        }\n        return near.toString();\n    }\n\n    private findDisplay(value: string): number {\n        if (!value || value.length < 3) {\n            return -1;\n        }\n        if (value[value.length - 1] !== \"`\") {\n            return -1;\n        }\n        let pos = value.length - 2;\n        while (pos !== -1) {\n            pos = value.lastIndexOf(\"`\", pos);\n            if (pos !== -1) {\n                let escapes = 0;\n                let pos1 = pos - 1;\n                while (pos1 >= 0) {\n                    if (value[pos1] !== \"\\\\\") {\n                        break;\n                    }\n                    escapes++;\n                    pos1--;\n                }\n                if (escapes % 2 === 0) {\n                    return pos;\n                }\n                pos--;\n            }\n        }\n        return -1;\n    }\n\n    private isValidFieldName(name: string): boolean {\n        return this.options.allowScopedFields ? Utils.isValidScopedSimpleName(name) : Utils.isValidSimpleName(name);\n    }\n\n    private isAllowedField(field: string, forcePartname: boolean, isPartname: IRef<boolean>): boolean {\n        isPartname.value = false;\n        if (Utils.eqNCN(field, \"exists\", \"missing\")) {\n            return true;\n        }\n        if (Utils.eqNCN(field, \"text\", \"concepts\", \"refine\", \"matchingpartnames\")) {\n            // NB @concepts, @refine and @matchingpartnames must be handled specially by the caller\n            isPartname.value = true;\n            return true;\n        }\n        const ccquery = this.exprContext.appService.ccquery;\n        if (ccquery) {\n            forcePartname = forcePartname && !this.exprContext.disallowFulltext;\n            let column = forcePartname ? undefined : this.exprContext.appService.getColumn(field);\n            if (!!column) {\n                if (column.eType === EngineType.varchar) { // only type not indexed\n                    column = undefined;\n                }\n                else if ((ccquery.$columnFieldsPattern && ccquery.$columnFieldsPattern.hasPatterns()) &&\n                    !ccquery.$columnFieldsPattern.isIncluded(field) &&\n                    !ccquery.$columnFieldsPattern.isIncluded(column.name)) {\n                    column = undefined;\n                }\n            }\n            if (!this.exprContext.disallowFulltext && !column) {\n                isPartname.value = true;\n                if ((ccquery.$partnameFieldsPattern && ccquery.$partnameFieldsPattern.hasPatterns()) &&\n                    !ccquery.$partnameFieldsPattern.isIncluded(field)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private readToken(): string | undefined {\n        if (this.saveOp !== ExprParserOperator.invalid) {\n            this.prevOp = this.op;\n            this.op = this.saveOp;\n            this.saveOp = ExprParserOperator.invalid;\n            return undefined;\n        }\n        let ch;\n        this.prevOp = this.op;\n        let nextValue: string | undefined;\n        const sbCurrentValue: string[] = [];\n        let candidateFieldPos = -1;\n        let fieldSpecified = false;\n        while (true) {\n            if (this.current >= this.length) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.eof;\n                return undefined;\n            }\n            ch = this.text[this.current];\n            if (ch === \"\\\\\") { // \\ escapes \\ and `\n                sbCurrentValue.push(ch);\n                this.current++;\n                if (this.current < this.length) {\n                    const ch1 = this.text[this.current];\n                    if (ch1 === \"\\\\\" || ch1 === \"`\") {\n                        sbCurrentValue.push(ch1);\n                        this.current++;\n                    }\n                }\n            }\n            else if (ch === \"(\") {\n                if (this.getTokValue(sbCurrentValue, false)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.lPar;\n                this.current++;\n                return undefined;\n            }\n            else if (ch === \")\") {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.rPar;\n                this.current++;\n                return undefined;\n            }\n            else if (this.matchKeyword(\"AND\", sbCurrentValue)) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.and;\n                this.current += 3;\n                return undefined;\n            }\n            else if (this.matchKeyword(\"OR\", sbCurrentValue)) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.or;\n                this.current += 2;\n                return undefined;\n            }\n            else if (this.matchKeyword(\"NOT\", sbCurrentValue)) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.not;\n                this.current += 3;\n                return undefined;\n            }\n            else if (this.matchKeyword(\"NEAR\", sbCurrentValue, \"/\")) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.current += 4;\n                nextValue = undefined;\n                if (this.current < this.length && this.text[this.current] === \"/\") {\n                    const last: IRef<number> = {value: 0};\n                    nextValue = this.matchUntil(this.current + 1, this.current + 1, \" \\r\\n\\t`\\\"([/\", last);\n                    let near = -1;\n                    if (nextValue !== undefined) {\n                        nextValue = nextValue.substr(0, nextValue.length - 1);\n                        near = Utils.toInt(nextValue, -1);\n                    }\n                    if (near < 0) {\n                        return \"bad operator\";\n                    }\n                    this.current = last.value - 1;\n                }\n                nextValue = this.ensureNearValue(nextValue || \"\");\n                const infix = this.current >= this.length || this.text[this.current] !== \"(\";\n                // For infix, near value is the number of words between the two terms so add the 2 terms to\n                // the window (near/0 = adjacent terms)\n                this.op = infix ?\n                    new ExprParserOperator(Token.infixNear, (Utils.toInt(nextValue) + 2).toString()) :\n                    new ExprParserOperator(Token.near, nextValue);\n                return undefined;\n            }\n            else if (ch === \"+\" || ch === \"-\") {\n                if (this.current + 1 < this.length) {\n                    const ch1 = this.text[this.current + 1];\n                    const last: IRef<number> = {value: 0};\n                    let length: number;\n                    if (\"(\\\"[/`\".includes(ch1)) { // ( \" [ / `\n                        nextValue = this.matchUntil(this.current, this.current + 2, this.getTerminators(ch1, false), last);\n                        length = last.value - this.current;\n                    }\n                    else {\n                        nextValue = this.matchSimpleValue(this.current + 1);\n                        length = !!nextValue ? nextValue.length : 0;\n                    }\n                    if (!!nextValue) {\n                        sbCurrentValue.push(nextValue);\n                        this.current += length;\n                        continue;\n                    }\n                }\n                return \"bad operator: \" + ch;\n            }\n            else if (\"\\\"[{/`\".includes(ch)) { // \" [ { / `\n                const last: IRef<number> = {value: 0};\n                nextValue = this.matchUntil(this.current, this.current + 1, this.getTerminators(ch, true), last);\n                if (!!nextValue) {\n                    const forceRange = (fieldSpecified && \"[{\".includes(ch) && sbCurrentValue.length === 0);\n                    sbCurrentValue.push(nextValue);\n                    this.current = last.value;\n                    if (forceRange && this.getTokValue(sbCurrentValue)) {\n                        return undefined;\n                    }\n                    continue;\n                }\n                return \"bad operator: \" + ch;\n            }\n            else {\n                if (ch === \":\") { // Field\n                    // Pick out previous value and/or field name\n                    // Field specifier can be:\n                    // field:value\n                    // field`display`:value\n                    // `display`:value\n                    const currentValue = sbCurrentValue.join(\"\");\n                    if (candidateFieldPos === -1) {\n                        // Check for display\n                        candidateFieldPos = this.findDisplay(currentValue);\n                        if (candidateFieldPos === -1) {\n                            this.op = ExprParserOperator.invalid;\n                            return \"invalid token\";\n                        }\n                    }\n                    let field = currentValue.substr(candidateFieldPos).trim();\n                    let display = \"\";\n                    // Extract display\n                    const displayStart = this.findDisplay(field);\n                    if (displayStart !== -1) {\n                        display = ExprParser.unescape(field.substr(displayStart, field.length - displayStart));\n                        field = field.substr(0, displayStart);\n                    }\n                    if (this.isValidFieldName(field) || (Utils.isEmpty(field) && !Utils.isEmpty(display))) {\n                        const value = currentValue.substr(0, candidateFieldPos);\n                        if (this.canBeTokValue(value.trim())) {\n                            this.current -= (sbCurrentValue.join(\"\").length - candidateFieldPos); // back up to field\n                            this._getTokValue(value);\n                            return undefined;\n                        }\n                        if (!Utils.isEmpty(field)) {\n                            let forcePartname = false;\n                            if (this.current + 1 < this.length && this.text[this.current + 1] === \":\") {\n                                // :: => force partname over column\n                                forcePartname = true;\n                                this.current++;\n                            }\n                            const isPartname: IRef<boolean> = { value: false };\n                            if (!this.isAllowedField(field, forcePartname, isPartname)) {\n                                candidateFieldPos = -1;\n                                sbCurrentValue.push(\":\");\n                                if (forcePartname) {\n                                    sbCurrentValue.push(\":\");\n                                }\n                                this.current++;\n                                continue;\n                            }\n                            if (isPartname.value) {\n                                field = ExprParser.fieldPartnamePrefix + field;\n                            }\n                        }\n                        if (!Utils.isEmpty(field)) {\n                            this.field = field;\n                            fieldSpecified = true;\n                        }\n                        if (!Utils.isEmpty(display)) {\n                            this.display = display;\n                        }\n                        sbCurrentValue.length = 0;\n                        this.current++;\n                        continue;\n                    }\n                }\n                if (\" \\r\\n\\t)\".includes(ch)) {\n                    candidateFieldPos = -1;\n                }\n                else if (candidateFieldPos === -1) {\n                    candidateFieldPos = sbCurrentValue.join(\"\").length;\n                }\n                sbCurrentValue.push(ch);\n                this.current++;\n            }\n        }\n    }\n\n    private clear() {\n        this.text = \"\";\n        this.current = 0;\n        this.length = 0;\n        this.operators.length = 0;\n        this.expressions.length = 0;\n        this.fields.length = 0;\n        this.displays.length = 0;\n    }\n\n    /**\n     * Parse some text using the Sinequa fielded search syntax\n     *\n     * @return The parsed `Expr` or an error string\n     */\n    public static parse(text: string, context: ExprContext, options?: ExprParserOptions): Expr | string {\n        const parser = new ExprParser(context, options);\n        const error = parser.parse(text);\n        if (error) {\n            return error;\n        }\n        return parser.parseResult();\n    }\n\n    private parseResult(): Expr | string {\n        if (this.expressions.length !== 1) {\n            return \"no expression found\";\n        }\n        return this.expressions[0];\n    }\n\n    private get contextField(): string {\n        let field = this.field;\n        if (Utils.isEmpty(field)) {\n            field = this.peekField();\n        }\n        return field;\n    }\n\n    private get contextDisplay(): string {\n        let display = this.display;\n        if (Utils.isEmpty(display)) {\n            display = this.peekDisplay();\n        }\n        return display;\n    }\n\n    private parse(text: string): string {\n        this.clear();\n        if (this.options.allowEmptyValues && !Utils.len(text.trim())) {\n            const expr = Expr.makeExpr(this.exprContext, \"\", this.contextField, this.contextDisplay, this.options.allowEmptyValues);\n            if (expr) {\n                expr.start = 0;\n                expr.length = 0;\n                this.expressions.push(expr);\n            }\n            return \"\";\n        }\n        this.text = text || \"\";\n        this.length = this.text.length;\n        this.operators.push(ExprParserOperator.eof);\n        let err = this.readToken();\n        if (err) {\n            return err;\n        }\n        while (true) {\n            if ((this.op.tok === Token.value || this.op.tok === Token.lPar || this.op.tok === Token.not || this.op.tok === Token.near) &&\n                (this.prevOp.tok === Token.value || this.prevOp.tok === Token.rPar)) {\n                // Default to AND for space separated terms\n                // NOT xxx => AND NOT xxx\n                this.saveOp = this.op;\n                this.op = ExprParserOperator.and;\n            }\n\n            let a: Act;\n            if (this.op.tok === Token.value) {\n                a = Act.s;\n            }\n            else {\n                a = ExprParser.parsetbl[this.operators[this.operators.length - 1].tok][this.op.tok];\n            }\n            switch (a) {\n                case Act.r:\n                    err = this.reduce();\n                    if (err) {\n                        return err;\n                    }\n                    break;\n                case Act.s:\n                    err = this.shift();\n                    if (err) {\n                        return err;\n                    }\n                    break;\n                case Act.a:\n                    if (this.expressions.length !== 1) {\n                        return \"syntax error\";\n                    }\n                    return \"\";\n                case Act.e1:\n                    return \"missing ')'\";\n                case Act.e2:\n                    return \"missing operator (AND,OR,NOT)\";\n                case Act.e3:\n                    return \"missing '('\";\n                case Act.e4:\n                    return \"invalid argument\";\n            }\n        }\n    }\n\n    private shift(): string | undefined {\n        if (this.op.tok === Token.value) {\n            const value = this.op.tokValue.trim();\n            if (Utils.isEmpty(value) && !this.options.allowEmptyValues) {\n                return \"empty token\";\n            }\n            const expr = Expr.makeExpr(this.exprContext, value, this.contextField, this.contextDisplay, !!this.options.allowEmptyValues);\n            if (!expr) {\n                return \"invalid expression\";\n            }\n            expr.start = this.op.tokValuePos;\n            expr.length = this.op.tokValueLen;\n            if (!!expr.operands) {\n                expr.operands.forEach(operand => {\n                    operand.start = this.op.tokValuePos;\n                    operand.length = this.op.tokValueLen;\n                });\n            }\n            this.expressions.push(expr);\n            this.field = \"\";\n            this.display = \"\";\n        }\n        else {\n            this.operators.push(this.op);\n            if (this.op.tok === Token.lPar) {\n                if (Utils.isEmpty(this.field)) {\n                    this.fields.push(this.peekField());\n                }\n                else {\n                    this.fields.push(this.field);\n                }\n                this.field = \"\";\n                if (Utils.isEmpty(this.display)) {\n                    this.displays.push(this.peekDisplay());\n                }\n                else {\n                    this.displays.push(this.display);\n                }\n                this.display = \"\";\n            }\n        }\n        return this.readToken();\n    }\n\n    private peekField(): string {\n        if (this.fields.length === 0) {\n            return \"\";\n        }\n        return this.fields[this.fields.length - 1];\n    }\n\n    private peekDisplay(): string {\n        if (this.displays.length === 0) {\n            return \"\";\n        }\n        return this.displays[this.displays.length - 1];\n    }\n\n    private canBeMergeTarget(e: Expr, and: boolean): boolean {\n        if (e.isLeaf) {\n            return false;\n        }\n        if (e.near >= 0) {\n            return false;\n        }\n        if (e.and !== and) {\n            return false;\n        }\n        if (e.not) {\n            return false;\n        }\n        return true;\n    }\n\n    private mergeExpr(e1: Expr, e2: Expr, and: boolean): Expr {\n        let source: Expr, target: Expr;\n        let prepend = false;\n        if (this.canBeMergeTarget(e1, and)) {\n            target = e1;\n            source = e2;\n        }\n        else if (this.canBeMergeTarget(e2, and)) {\n            target = e2;\n            source = e1;\n            prepend = true; // to keep the same order as in the input text\n        }\n        else {\n            return new Expr({\n                exprContext: e1.exprContext,\n                op1: e1,\n                and,\n                op2: e2,\n                field: this.peekField(),\n                display: this.peekDisplay()\n            });\n        }\n        if (source.isLeaf || source.and !== and || source.not || !Utils.eq(source.display || \"\", target.display || \"\")) {\n            target.addOperand(source, this.peekField(), prepend);\n        }\n        else {\n            if (source.operands) {\n                for (const operand of source.operands) {\n                    target.addOperand(operand, this.peekField(), prepend);\n                }\n            }\n        }\n        return target;\n    }\n\n    private reduce(): string | undefined {\n        let e: Expr | undefined;\n        let e1: Expr | undefined;\n        let e2: Expr | undefined;\n        const op: ExprParserOperator = this.operators[this.operators.length - 1];\n        switch (op.tok) {\n            case Token.not:\n                // Apply E := NOT E\n                e = this.expressions.pop();\n                if (!e) {\n                    return \"syntax error\";\n                }\n                e.not = !e.not;\n                this.expressions.push(e);\n                break;\n            case Token.and:\n                e2 = this.expressions.pop();\n                e1 = this.expressions.pop();\n                if (!e1 || !e2) {\n                    return \"syntax error\";\n                }\n                this.expressions.push(this.mergeExpr(e1, e2, true));\n                break;\n            case Token.or:\n                e2 = this.expressions.pop();\n                e1 = this.expressions.pop();\n                if (!e1 || !e2) {\n                    return \"syntax error\";\n                }\n                this.expressions.push(this.mergeExpr(e1, e2, false));\n                break;\n            case Token.near:\n                e = this.expressions.pop();\n                if (!e) {\n                    return \"syntax error\";\n                }\n                e.near = Utils.toInt(this.ensureNearValue(op.tokValue));\n                this.expressions.push(e);\n                break;\n            case Token.infixNear:\n                e2 = this.expressions.pop();\n                e1 = this.expressions.pop();\n                if (!e1 || !e2) {\n                    return \"syntax error\";\n                }\n                if (!e2.isLeaf || e2.isStructured || !e1.isLeaf || e1.isStructured || e2.not || e1.not || !Utils.eqNC(e2.field || \"\", e1.field || \"\")) {\n                    return \"syntax error\";\n                }\n                e = new Expr({\n                    exprContext: e1.exprContext,\n                    op1: e1,\n                    and: false,\n                    op2: e2,\n                    field: this.peekField(),\n                    display: this.peekDisplay()\n                });\n                e.near = Utils.toInt(this.ensureNearValue(op.tokValue));\n                this.expressions.push(e);\n                break;\n            case Token.rPar:\n                this.operators.pop();\n                if (this.fields.length === 0) {\n                    return \"missing field\";\n                }\n                if (this.expressions.length === 0) {\n                    return \"syntax error\";\n                }\n                const field = this.fields.pop();\n                const display = this.displays.pop();\n                // Set Field for single term bracketed expressions\n                e = this.expressions[this.expressions.length - 1];\n                if (e.isLeaf) {\n                    if (Utils.isEmpty(e.field)) {\n                        e.field = field;\n                    }\n                    if (Utils.isEmpty(e.display)) {\n                        e.display = display;\n                    }\n                }\n                break;\n        }\n        this.operators.pop();\n        return undefined;\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Utils } from '@sinequa/core/base';\nimport { Aggregation, AggregationItem, TreeAggregationNode } from '@sinequa/core/web-services';\nimport { ValueItem } from '../format.service';\nimport { ExprParser } from './expr-parser';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class ExprBuilder {\n\n    /**\n     * Make a standard selection expression\n     * (resulting in a SQL clause like \"company contains 'BOEING'\")\n     * @param field Name of the field to select (eg. \"company\")\n     * @param value Value of the field to select (eg. \"BOEING\")\n     * @param display Optional string to display that value (eg. \"Boeing\")\n     */\n    makeExpr(field: string, value: string, display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: ${ExprParser.escape(value)}`; // company`Boeing`: BOEING\n    }\n\n    /**\n     * Make a boolean expression\n     * @param field Name of the field to select (eg. \"toto\")\n     * @param value Value of the field to select (eg. \"true\")\n     * @param display Optional string to display that value (eg. \"True\")\n     */\n    makeBooleanExpr(field: string, value: boolean, display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: ${ExprParser.escape(Utils.toSqlValue(value))}`; // toto`True`: true\n    }\n\n\n    /**\n     * Make a numerical expression using a comparison operator (>, <, <=, >=, etc.)\n     * @param field Name of the field to select (eg. \"modified\")\n     * @param operator Comparison operator used for that selection (eg. \">\")\n     * @param value Value of the field to select (eg. \"2020-12-15\")\n     * @param display Optional string to display that value (eg. \"After Dec 15 2020\")\n     */\n    makeNumericalExpr(\n        field: string,\n        operator: '>' | '>=' | '<' | '<=' | '=' | '<>',\n        value: number | Date | string,\n        display?: string): string {\n\n        field = this.formatField(field, display);\n\n        if(Utils.isString(value)) {\n            value = ExprParser.escape(value);\n        }\n        if(Utils.isDate(value) || Utils.isNumber(value)) {\n            value = Utils.toSqlValue(value);\n        }\n\n        return `${field}:${operator} ${value}`; // modified`After Dec 15 2020`:> 2020-12-15\n    }\n\n\n    /**\n     * Make a list expression\n     * @param field Name of the field to select (eg. \"docformat\")\n     * @param values Values of the field to select (eg. ['htm','pdf'])\n     * @param display Optional string to display that value (eg. \"htm, pdf\")\n     */\n    makeListExpr(field: string, values: string[], display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: [${values.map(v => ExprParser.escape(v)).join(',')}]`; // docformat`htm, pdf`:[`htm`,`pdf`]\n    }\n\n\n    /**\n     * Make a range expression\n     * @param field Name of the field to select (eg. \"modified\")\n     * @param from Begining of the range (eg. 2020-12-15)\n     * @param to End of the range (eg. 2020-12-20)\n     * @param display Optional string to display that value (eg. \"[Dec 15 2020, Dec 20 2020]\")\n     */\n    makeRangeExpr(\n        field: string,\n        from: number | Date | string,\n        to: number | Date | string,\n        display?: string): string {\n\n        field = this.formatField(field, display);\n        return `${field}: [${Utils.toSqlValue(from)}..${Utils.toSqlValue(to)}]`; // modified`[Dec 15 2020, Dec 20 2020]`: [2020-12-15..2020-12-20]\n    }\n\n\n    /**\n     * Make a RegExp expression\n     * @param field Name of the field to select (eg. \"company\")\n     * @param value Value of the regular expression to match (eg. \"BOE.*\")\n     * @param display Optional string to display that value (eg. \"Boe...\")\n     */\n    makeRegexpExpr(field: string, value: string, display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}:~ ${ExprParser.escape(value)}`; // company`Boe...`:~ BOE.*\n    }\n\n\n    /**\n     * Make a refine expression\n     * @param text The text to add to the query\n     */\n    makeRefineExpr(text: string): string {\n        return `refine: ${ExprParser.escape(text)}`;\n    }\n\n\n    /**\n     * Return an expression that selects multiple values for a field\n     * (All values are ANDed)\n     * @param field Name of the field to select (eg. \"company\")\n     * @param values Values of the field to select (eg. ['IBM','APPLE'])\n     * @param display Optional string to display that value (eg. \"IBM and Apple\")\n     */\n    makeAndExpr(field: string, values: (string | ValueItem)[], display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: (${this.concatWithOperator(values, 'AND')})`; // company: (IBM AND APPLE AND GOOGLE)\n    }\n\n\n    /**\n     * Return an expression that selects multiple values for a field\n     * (All values are ORed)\n     * This function should be equivalent to using makeListExpr\n     * @param field Name of the field to select (eg. \"company\")\n     * @param values Values of the field to select (eg. ['IBM','APPLE'])\n     * @param display Optional string to display that value (eg. \"IBM and Apple\")\n     */\n    makeOrExpr(field: string, values: (string | ValueItem)[], display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: (${this.concatWithOperator(values, 'OR')})`; // company: (IBM OR APPLE OR GOOGLE)\n    }\n\n    /**\n     * Combine a list of values with AND or OR operators\n     * @param values the list of values\n     * @param operator the operator\n     */\n    private concatWithOperator(values: (string | ValueItem)[], operator: 'AND' | 'OR') {\n        return values.map(v => {\n            if (Utils.isString(v)){\n                return ExprParser.escape(v);\n            }\n            if (v.display) {\n                return `${ExprParser.escape(v.display)}:${ExprParser.escape(Utils.toSqlValue(v.value))}`;\n            }\n            return ExprParser.escape(Utils.toSqlValue(v.value));\n        }).join(' '+operator+' ');\n    }\n\n    /**\n     * Returns the negative expression of the given expression\n     * eg. NOT(person:Bill GATES)\n     * @param expr\n     */\n    makeNotExpr(expr: string): string {\n        return `NOT (${expr})`;\n    }\n\n    /**\n     * Returns an expression that is the union of given expressions\n     * eg. person:Bill GATES OR company:MICROSOFT\n     * @param exprs\n     */\n    concatOrExpr(exprs: string[]): string {\n        if (exprs.length <= 1) {\n            return exprs[0] || '';\n        }\n        return `(${exprs.join(') OR (')})`;\n    }\n\n\n    /**\n     * Returns an expression that is the intersection of given expressions\n     * eg. person:Bill GATES AND company:MICROSOFT\n     * @param exprs\n     */\n    concatAndExpr(exprs: string[]): string {\n        if (exprs.length <= 1) {\n            return exprs[0] || '';\n        }\n        return `(${exprs.join(') AND (')})`;\n    }\n\n\n    /**\n     * Returns an expression to select the given item\n     * @param field Name of the field to select (eg. \"company\")\n     * @param items A single or list of ValueItem object(s) (eg. content of a record)\n     */\n    makeFieldExpr(field: string, items: ValueItem | ValueItem[], combineWithAnd?: boolean): string {\n        if(!Utils.isArray(items)) {\n            items = [items];\n        }\n        if(items.length === 0) {\n            return \"\"; // Return a falsy string instead of \"()\" or \"``\" which would be truthy\n        }\n        return combineWithAnd? this.makeAndExpr(field, items) : this.makeOrExpr(field, items);\n    }\n\n    /**\n     * Create an expression for the given aggregation item\n     * @param aggregation The aggregation containing this object\n     * @param items The AggregationItem(s) to select\n     * @param combineWithAnd If there are multiple values, combine them with AND (instead of OR)\n     */\n    makeAggregationExpr(aggregation: Aggregation, items: AggregationItem | AggregationItem[], combineWithAnd?: boolean): string {\n        if(!Utils.isArray(items)) {\n            items = [items];\n        }\n        if(aggregation.valuesAreExpressions) {\n            const exprs = items.map(i => i.value.toString()); // .toString() is to avoid typing issues. With valuesAreExpressions = true, item.value is expected to be a string\n            return combineWithAnd? this.concatAndExpr(exprs) : this.concatOrExpr(exprs);\n        }\n        else {\n            const _items = this.asValueItems(items, aggregation.isTree);\n            return this.makeFieldExpr(aggregation.column, _items, combineWithAnd);\n        }\n    }\n\n\n    /**\n     * Combines the field with the optional display value(s)\n     * @param field\n     * @param display\n     */\n    private formatField(field: string, display?: string): string {\n        if(display) {\n            field = `${field}${ExprParser.escape(display)}`;\n        }\n        return field;\n    }\n\n\n    /**\n     * Return the AggregationItem list as a ValueItem list\n     * @param items\n     * @param isTree\n     */\n    private asValueItems(items: AggregationItem[], isTree?: boolean): ValueItem[] {\n        if(isTree) {\n            return items.map(i => {\n                return {\n                    value: (i as TreeAggregationNode).$path + \"*\",\n                    display: i.display || i.value as string\n                };\n            });\n        }\n        return items; // This works because ValueItem and AggregationItem share the value and display properties\n    }\n}\n","import {Utils, MapOf} from \"@sinequa/core/base\";\nimport {IQuery, Select, Open, SpellingCorrectionMode, AggregationOptions} from \"@sinequa/core/web-services\";\n\n\nexport const advancedFacetPrefix = \"advanced_\";\n\n/**\n * Represents a query for retrieving search results from a Sinequa search engine.\n *\n * The properties are described in the {@link IQuery} interface\n */\nexport class Query implements IQuery {\n    text?: string;\n    action: \"\" | \"search\" | \"open\" | \"aggregate\";\n    select?: Select[];\n    open?: Open[];\n    page?: number;\n    pageSize?: number;\n    tab?: string;\n    scope?: string;\n    sort?: string;\n    basket?: string;\n    isFirstPage?: boolean;\n    strictRefine?: boolean;\n    globalRelevance?: number;\n    questionLanguage?: string;\n    questionDefaultLanguage?: string;\n    spellingCorrectionMode?: SpellingCorrectionMode;\n    spellingCorrectionFilter?: string;\n    documentWeight?: string;\n    textPartWeights?: string;\n    relevanceTransforms?: string;\n    removeDuplicates?: boolean;\n    queryId?: string;\n    aggregations: MapOf<AggregationOptions> | string[];\n    orderBy?: string;\n    groupBy?: string;\n\n    /**\n     * Return a copy of the passed query\n     */\n    static copy(query: Query): Query {\n        if (!query) {\n            return query;\n        }\n        return query.copy();\n    }\n\n    constructor(\n        public name: string) {\n    }\n\n    /**\n     * Return `true` if the query has fulltext search elements\n     */\n    get hasRelevance(): boolean {\n        if (!Utils.isEmpty(this.text)) {\n            return true;\n        }\n        if (this.findSelect(\"refine\")) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Add a select filter to the query\n     *\n     * @param expr The fielded search expression to filter the results\n     * @param facet The name of the associated facet\n     */\n    addSelect(expr: string, facet?: string): number {\n        return this.pushSelect({\n            expression: expr,\n            facet: facet || \"\"\n        });\n    }\n\n    /**\n     * Adds a new `Select` object to the end of the query's `selects`\n     */\n    pushSelect(select: Select): number {\n        if (!this.select) {\n            this.select = [];\n        }\n        return this.select.push(select);\n    }\n\n    /**\n     * Remove the last `Select` object from the `selects` and return it\n     */\n    popSelect(): Select | undefined {\n        if (!this.select) {\n            return undefined;\n        }\n        return this.select.pop();\n    }\n\n    /**\n     * Remove the `Select` object identified by `indexOrFacet`\n     *\n     * @param indexOrFacet either an index in the `selects` array or a facet name\n     * @param all If `true` and `indexOrFacet` is a facet name then all `Select` objects with a matching facet name will be removed\n     */\n    removeSelect(indexOrFacet: number | string, all = false): void {\n        if (!this.select) {\n            return;\n        }\n        if (Utils.isString(indexOrFacet)) {\n            // indexOrFacet is a facet name\n            for (let i = this.select.length - 1; i >= 0; i--) {\n                const _select = this.select[i];\n                if (Utils.eqNC(_select.facet, indexOrFacet)) {\n                    this.select.splice(i, 1);\n                    if (this.select.length === 0) {\n                        delete this.select; // Clean the query if no more select\n                        return;\n                    }\n                    if (!all) {\n                        return;\n                    }\n                }\n            }\n        }\n        else {\n            if (indexOrFacet < 0 || indexOrFacet >= this.select.length) {\n                return;\n            }\n            this.select.splice(indexOrFacet, 1);\n            if (this.select.length === 0) {\n                delete this.select;\n            }\n        }\n    }\n\n    /**\n     * Replace a `Select` with another\n     *\n     * @param index The index in the `selects` array of the `Select to replace\n     * @param select The `Select` to use as a replacement\n     */\n    replaceSelect(index: number, select: Select) {\n        if (!this.select) {\n            return;\n        }\n        this.select.splice(index, 1, select);\n    }\n\n    /**\n     * Find the index of the nth `Select` object matching the passed facet name\n     *\n     * @param facet A facet name\n     * @param ordinal Specifies which `Select` object to retrieve among selects with the same facet name\n     */\n    findSelectIndex(facet: string, ordinal = 0): number {\n        if (!this.select) {\n            return -1;\n        }\n        let index = 0;\n        let facetOrdinal = 0;\n        let facetIndex = -1;\n        for (const select of this.select) {\n            if (Utils.eqNC(facet, select.facet)) {\n                facetIndex = index;\n                if (facetOrdinal === ordinal) {\n                    break;\n                }\n                facetOrdinal++;\n            }\n            index++;\n        }\n        return facetIndex;\n    }\n\n    /**\n     * Find the first `Select` matching the passed facet name\n     *\n     * @param facet A facet name\n     * @param fromEnd If `true` start searching backwards from the last `Select`\n     */\n    findSelect(facet: string, fromEnd = true): Select | undefined {\n        const facetSelectIndex = this.findSelectIndex(facet, fromEnd ? -1 : 0);\n        return facetSelectIndex >= 0 ? this.select && this.select[facetSelectIndex] : undefined;\n    }\n\n    /**\n     * Return the last `Select` object\n     */\n    lastSelect(): Select | undefined {\n        if (!this.select) {\n            return undefined;\n        }\n        return this.select[this.select.length - 1];\n    }\n\n    /**\n     * Return the number of `Select` objects\n     */\n    get selectLength(): number {\n        if (!this.select) {\n            return 0;\n        }\n        return this.select.length;\n    }\n\n    /**\n     * Add an `Open` filter to the query. This is typically used to load children of tree nodes\n     *\n     * @param expr The fielded search expression specifying the node to expand\n     * @param aggregation The associated aggregation\n     */\n    addOpen(expr: string, aggregation: string) {\n        if (!this.open || !Utils.isArray(this.open)) {\n            this.open = [];\n        }\n        return this.open.push({\n            expression: expr,\n            aggregation\n        });\n    }\n\n    /**\n     * Clear all fields in the query except the name\n     */\n    clear(): void {\n        const name = this.name;\n        Utils.clearObject(this);\n        this.name = name;\n    }\n\n    /**\n     * Remove advanced search select(s) from the query\n     */\n    toStandard(): Query {\n        const advancedSelect = this.select?.filter(\n          (select: Select) => select.facet && select.facet.startsWith(advancedFacetPrefix)\n        )\n        advancedSelect?.forEach(\n          (select) => this.removeSelect(select.facet, true)\n        )\n        return this;\n    }\n\n    /**\n     * Return a copy of this query\n     */\n    copy(): Query {\n        const query = new Query(this.name);\n        Utils.copy(this, query);\n        return query;\n    }\n\n    /**\n     * Return a copy of this query but without any advanced select\n     */\n    copyStandard(): Query {\n        const query = this.copy();\n        return query.toStandard();\n    }\n\n    /**\n     * Remove all properties from the query except advanced search select(s) and optionally `text`\n     *\n     * @param withText If `true` do not remove the `text` field\n     */\n    toAdvanced(withText: boolean = false): Query {\n        for (const property in this) {\n            if (this.hasOwnProperty(property) && !Utils.eqNC(property, \"select\") && (!withText || !Utils.eqNC(property, \"text\"))) {\n                delete this[property];\n            }\n        }\n        const notAdvancedSelect = this.select?.filter(\n          (select: Select) => select.facet && !select.facet.startsWith(advancedFacetPrefix)\n        )\n        notAdvancedSelect?.forEach(\n          (select) => this.removeSelect(select.facet)\n        )\n        return this;\n    }\n\n    /**\n     * Return a copy of this query including just the advanced fields and optionally `text`\n     *\n     * @param withText If `true` include the `text` field\n     */\n    copyAdvanced(withText: boolean = false): Query {\n        const query = this.copy();\n        return query.toAdvanced(withText);\n    }\n\n    /**\n     * Tests whether this query has advanced search selections\n     */\n    hasAdvanced(): boolean {\n        return !!this.select?.find(s => s.facet && s.facet.startsWith(advancedFacetPrefix));\n    }\n\n    /**\n     * Initialize this query from the passed JSON string\n     *\n     * @param jquery JSON in string form\n     */\n    fromJson(jquery: string): Query {\n        this.clear();\n        const query = Utils.fromJson(jquery);\n        // convert select and open\n        const select = query.select;\n        if (Utils.isArray(select)) {\n            query.select = select.map<Select>((value: Select | string[]) => {\n                if (Utils.isArray(value)) {\n                    return {\n                        expression: value[0],\n                        facet: value[1]\n                    };\n                }\n                else {\n                    return value;\n                }\n            });\n        }\n        const open = query.open;\n        if (Utils.isArray(open)) {\n            query.open = open.map<Open>((value: Open | string[]) => {\n                if (Utils.isArray(value)) {\n                    return {\n                        expression: value[0],\n                        aggregation: value[1]\n                    };\n                }\n                else {\n                    return value;\n                }\n            });\n        }\n        Utils.extend(this, query);\n        return this;\n    }\n\n    /**\n     * Returns a JSON representation of this query where `Select` and `Open` objects are expressed as tuple arrays for conciseness\n     */\n    toJsonForQueryString(): string {\n        const o: any = {};\n        Utils.merge(o, this);\n        if (this.select) {\n            o.select = this.select.map<string[]>((value) => {\n                const a = [value.expression];\n                if (value.facet) {\n                    a.push(value.facet);\n                }\n                return a;\n            });\n        }\n        if (this.open) {\n            o.open = this.open.map<string[]>((value) => [value.expression, value.aggregation]);\n        }\n        return Utils.toJson(o);\n    }\n\n    /**\n     * Return a hash value of this query that excludes any pagination parameters\n     */\n    hash(): string {\n        const obj: any = {};\n        Utils.mergeAndSort(obj, this);\n        // remove pagination\n        delete obj.page;\n        delete obj.pageSize;\n        const str = Utils.toJson(obj);\n        return Utils.sha512(str);\n    }\n}\n","import {Injectable} from \"@angular/core\";\nimport {IntlService} from \"@sinequa/core/intl\";\nimport {Utils, FieldValue} from \"@sinequa/core/base\";\nimport {AppServiceHelpers} from \"./app-service-helpers\";\nimport {CCColumn} from \"@sinequa/core/web-services\";\nimport {format} from \"d3-format\";\n\n/**\n * Describes a value item object that includes a {@link FieldValue} and an optional display value\n * to override standard field value formatting\n */\nexport interface ValueItem {\n    value: FieldValue;\n    display?: string;\n    count?: number; // Following ES-11166, the number of occurrence for an entity can be included\n}\n\n/**\n * This service provides methods for locale-sensitive formatting and parsing of values that can be found in\n * Sinequa search results.\n */\n@Injectable({\n    providedIn: \"root\"\n})\nexport class FormatService {\n    constructor(\n        public intlService: IntlService) {\n    }\n\n    /**\n     * Returns `true` if the passed parameter is a `ValueItem` object\n     */\n    protected isValueItem(valueItem: ValueItem | FieldValue): valueItem is ValueItem {\n        if (Utils.isObject(valueItem) && !Utils.isDate(valueItem) && !Utils.isArray(valueItem)) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Extracts the value and display components from a parameter that can be either a `ValueItem`\n     * object or a simple `FieldValue`, in which case the display will be `undefined`.\n     */\n    protected getValueAndDisplay(valueItem: ValueItem | FieldValue): [FieldValue, string] {\n        let value: FieldValue;\n        let display: string;\n        if (this.isValueItem(valueItem)) {\n            value = valueItem.value;\n            display = valueItem.display || \"\";\n        }\n        else {\n            value = valueItem;\n            display = \"\";\n        }\n        return [value, display];\n    }\n\n    /**\n     * Return the display equivalent of a Sinequa language specifier (`en`, `fr`, ...).\n     * The display values are defined in the {@link IntlModule} message files\n     *\n     * @param value A value containing a Sinequa language specifier\n     */\n    formatLanguage(value: FieldValue): string {\n        return this.intlService.formatMessage(`msg#language.${Utils.toLowerCase(value + \"\")}`);\n    }\n\n    /**\n     * Return the display equivalent of a size value. The units (`kb`, `mb`, ...) are defined\n     * in the {@link IntlModule} message files\n     *\n     * @param size A memory size in bytes\n     */\n    formatMemorySize(size: number): string {\n        const kiloBytes: number = size / 1024;\n        const megaBytes: number = kiloBytes / 1024;\n        const gigaBytes: number = megaBytes / 1024;\n        const teraBytes: number = gigaBytes / 1024;\n        const petaBytes: number = teraBytes / 1024;\n\n        let messageKey = \"msg#system.memorySize.bytes\";\n        const params: any = { value: size };\n        if (Math.abs(petaBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.pb\";\n            params.value = petaBytes;\n        }\n        else if (Math.abs(teraBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.tb\";\n            params.value = teraBytes;\n        }\n        else if (Math.abs(gigaBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.gb\";\n            params.value = gigaBytes;\n        }\n        else if (Math.abs(megaBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.mb\";\n            params.value = megaBytes;\n        }\n        else if (Math.abs(kiloBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.kb\";\n            params.value = kiloBytes;\n        }\n        return this.intlService.formatMessage(messageKey, params);\n    }\n\n    /** D3 formatter for large number: 42096 => 42K */\n    bigNumberFormatter = format(\"~s\");\n\n    /** Similar to bigNumberFormatter, but replaces \"G\" by \"B\" (as in \"$42B\") */\n    moneyFormatter = s => this.bigNumberFormatter(s).replace(/G/, \"B\");\n    \n    /**\n     * Format an amount of money (typically extracted by a Sinequa Text-mining agent)\n     * USD 42069 => USD 42K\n     * @param value \n     * @returns \n     */\n    formatMoney(value: string): string {\n        let [currency, val] = value.split(\" \");\n        return `${currency} ${this.moneyFormatter(+val)}`;\n    }\n\n    /**\n     * Format a value for display according to the passed `column`. Formatters\n     * can be defined in the column's configuration to provide domain-specific\n     * formatting. The standard formatters are `language` and `memorysize`.\n     *\n     * @param valueItem The value to format\n     * @param column The column associated with the value\n     */\n    formatValue(valueItem: ValueItem | FieldValue, column?: CCColumn): string {\n        let [value, display] = this.getValueAndDisplay(valueItem);\n        if (column && column.formatter) {\n            switch (Utils.toLowerCase(column.formatter)) {\n                case \"language\": return this.formatLanguage(value);\n                case \"memorysize\":\n                    if (Utils.isNumber(value)) {\n                        return this.formatMemorySize(value);\n                    }\n                    break;\n                case \"money\":\n                    if(Utils.isString(value)) {\n                        return this.formatMoney(value);\n                    }\n                    else if(Utils.isArray(value)) {\n                        return value.map(v => \n                            this.formatMoney(Utils.isString(v)? v : v.value)\n                        ).join(', ');\n                    }\n                    break;\n            }\n        }\n        if (display) {\n            if (Utils.isDate(display)) { // ES-7785\n                display = Utils.toSysDateStr(display);\n            }\n            return this.intlService.formatMessage(display, {value});\n        }\n        if (Utils.isNumber(value)) {\n            const message = this.intlService.getMessage(\"msg#system.number\");\n            if (message) {\n                return this.intlService.formatText(message, {value});\n            }\n            else {\n                return this.intlService.formatNumber(value);\n            }\n        }\n        if (column && AppServiceHelpers.isDate(column) && Utils.isString(value)) {\n            value = Utils.fromSysDateStr(value) || value;\n        }\n        if (Utils.isDate(value)) {\n            if (column && !AppServiceHelpers.isDate(column)) { // ES-7785\n                value = Utils.toSysDateStr(value);\n            }\n            else {\n                const message = this.intlService.getMessage(\"msg#system.date\");\n                if (message) {\n                    return this.intlService.formatText(message, {date: value, time: Utils.getTime(value)});\n                }\n                else {\n                    let s = this.intlService.formatDate(value);\n                    if (Utils.getTime(value) !== 0) {\n                        s += \", \" + this.intlService.formatTime(value);\n                    }\n                    return s;\n                }\n            }\n        }\n        if (Utils.isBoolean(value)) {\n            const message = this.intlService.getMessage(\"msg#system.boolean\");\n            if (message) {\n                return this.intlService.formatText(message, {value});\n            }\n            else {\n                return value.toString();\n            }\n        }\n        if (Utils.isArray(value)) {\n            const joinValue: string[] = [];\n            value.forEach(v => {\n                if (joinValue.length > 0) {\n                    joinValue.push(\";\");\n                }\n                let _v: string;\n                if (!v) {\n                    _v = \"<null>\";\n                }\n                else if (Utils.isDate(v)) {\n                    _v = Utils.toSysDateStr(v);\n                }\n                else if (Utils.isString(v)) {\n                    _v = v;\n                }\n                else {\n                    _v = v.display || v.value || \"<null>\";\n                }\n                joinValue.push(_v);\n            });\n            value = joinValue.join(\"\");\n        }\n        if (!value) {\n            return value;\n        }\n        return this.intlService.formatMessage(value);\n    }\n\n    /**\n     * Transform a display value. Multiple transformers can be defined on a column and their calls are chained.\n     * The standard formatters are `uppercase`, `upperfirst`, `lowercase`, `lowerfirst`, `startcase`, `kebabcase`,\n     * `snakecase` and `camelcase`.\n     *\n     * @param value The value to transform\n     * @param column The column associated with the value\n     */\n    transformValue(value: string, column?: CCColumn): string {\n        const transforms = column ? Utils.split(column.transforms || \"\", \",\") : undefined;\n        if (!transforms || transforms.length === 0) {\n            return value;\n        }\n        // transforms are composable\n        for (const transform of transforms) {\n            switch (Utils.toLowerCase(transform)) {\n                case \"uppercase\": value = Utils.toUpperCase(value); break;\n                case \"upperfirst\": value = Utils.toUpperFirst(value); break;\n                case \"lowercase\": value = Utils.toLowerCase(value); break;\n                case \"lowerfirst\": value = Utils.toLowerFirst(value); break;\n                case \"startcase\": value = Utils.toStartCase(value); break;\n                case \"kebabcase\": value = Utils.toKebabCase(value); break;\n                case \"snakecase\": value = Utils.toSnakeCase(value); break;\n                case \"camelcase\": value = Utils.toCamelCase(value); break;\n            }\n        }\n        return value;\n    }\n\n    /**\n     * Format a value item for display. This is the standard entry point for formatting a value.\n     * By default, this method calls [formatValue]{@link #formatValue} and [transformValue]{@link #transformValue}.\n     *\n     * @param valueItem The value item to format\n     * @param column The column associated with the value item\n     */\n    formatFieldValue(valueItem: ValueItem | FieldValue, column?: CCColumn): string {\n        let formattedValue = this.formatValue(valueItem, column);\n        formattedValue = this.transformValue(formattedValue, column);\n        return formattedValue;\n    }\n\n    /**\n     * Parse an input value according to the passed `parser`. The standard parser is `memorysize`. Parsers\n     * are configured in the {@link CCColumn} configuration. The parsed value is returned as a string for\n     * processing by the {@link ValidationModule}\n     *\n     * @param value The value to parse\n     * @param parser The parser to use\n     */\n    parseValue(value: any, parser: string): string {\n        if (Utils.isString(value)) {\n            if (parser) {\n                switch (Utils.toLowerCase(parser)) {\n                    case \"memorysize\": {\n                        return this.parseMemorySize(value) + \"\";\n                    }\n                }\n            }\n        }\n        return value;\n    }\n\n    /**\n     * Parse a size string using [Utils.toSize]{@link Utils#toSize}\n     *\n     * @param str The string to parse\n     * @param _default The default value to return if the string cannot be parsed\n     * @return The parsed size in bytes\n     */\n    parseMemorySize(str: string, _default = 0): number {\n        return Utils.toSize(str, _default);\n    }\n\n    /**\n     * Display a raw value without applying any formatting\n     * (besides the native toString() method for non-string values)\n     * @param value \n     * @returns \n     */\n    formatRaw(value: ValueItem | FieldValue): string {\n        let [val] = this.getValueAndDisplay(value);\n        if(Utils.isArray(val)) {\n            return val.map(v => Utils.isString(v)? v : v.value).join(';');\n        }\n        return val?.toString();\n    }\n}\n","import {Injectable, Inject, OnDestroy} from \"@angular/core\";\nimport {Observable, Subject} from \"rxjs\";\nimport {map} from \"rxjs/operators\";\nimport {Utils, MapOf, PatternMatcher} from \"@sinequa/core/base\";\nimport {IntlService} from \"@sinequa/core/intl\";\nimport {FormatService} from \"./format.service\";\nimport {AppWebService, AuditEvents, START_CONFIG, StartConfig,\n    CCApp, CCQuery, CCLabels, CCAutocomplete, CCColumn, CCIndex, CCWebService, CCConfig, CCList, CCAggregation,\n    EngineType, EngineTypeModifier, MINIMUM_COMPATIBLE_SERVER_API_VERSION} from \"@sinequa/core/web-services\";\nimport {ExprParser, ExprParserOptions, Expr} from \"./query/expr-parser\";\nimport {AppServiceHelpers} from \"./app-service-helpers\";\n\n/**\n * A base event from which all events that can be issued by the {@link AppService} are derived\n */\nexport interface AppEvent {\n    type: \"query-changed\";\n}\n\n/**\n * This event is fired each time the [ccquery]{@link AppService#ccquery} member is modified.\n */\nexport interface QueryChangedEvent extends AppEvent {\n    type: \"query-changed\";\n    current?: CCQuery;\n    previous?: CCQuery;\n}\n\n/**\n * A union of the different events that the {@link AppService} can generate\n */\nexport type AppEvents = QueryChangedEvent;\n\n/**\n * A service to manage the Sinequa SBA configuration\n */\n@Injectable({\n    providedIn: \"root\"\n})\nexport class AppService implements OnDestroy {\n    // Should match AdditionalQueryableColumns in Engine.cs\n    private static extraColumns: MapOf<CCColumn> = {\n        id: AppService.makeColumn(\"id\", \"string\"),\n        text: AppService.makeColumn(\"text\", \"varchar\"),\n        documentlanguages: AppService.makeColumn(\"documentlanguages\", \"csv\", \"ci\"),\n        databasealias: AppService.makeColumn(\"databasealias\", \"varchar\"),\n        globalrelevance: AppService.makeColumn(\"globalrelevance\", \"double\"),\n        matchingpartnames: AppService.makeColumn(\"matchingpartnames\", \"csv\"),\n        matchlocations: AppService.makeColumn(\"matchlocations\", \"csv\"),\n        matchlocationsperpartname: AppService.makeColumn(\"matchlocationsperpartname\", \"varchar\"), // json\n        extracts: AppService.makeColumn(\"extracts\", \"csv\"),\n        extractsperpartname: AppService.makeColumn(\"extractsperpartname\", \"varchar\"), // json\n        extractslocations: AppService.makeColumn(\"extractslocations\", \"csv\"),\n        documentweight: AppService.makeColumn(\"documentweight\", \"varchar\"),\n        groupcount: AppService.makeColumn(\"groupcount\", \"integer\"),\n        accesslists: AppService.makeColumn(\"accesslists\", \"varchar\", undefined, [\"accessLists\"]) // json\n    };\n\n    /**\n     * The app configuration\n     */\n    app?: CCApp;\n    /**\n     * The labels configuration\n     */\n    cclabels?: CCLabels;\n    /**\n     * The autocomplete configuration\n     */\n    ccautocomplete?: CCAutocomplete;\n    /**\n     * The suggest queries configured on the application\n     */\n    suggestQueries: string[];\n    private columnsByQuery: MapOf<MapOf<CCColumn>>;\n    private columnsByIndex: MapOf<MapOf<CCColumn>>;\n    private fieldsByQuery: MapOf<string[]>;\n    private _defaultCCQuery?: CCQuery;\n    private _ccquery?: CCQuery;\n\n    protected _events = new Subject<AppEvents>();\n\n    private static toEngineType(type: string): EngineType {\n        if (!type) {\n            return EngineType.none;\n        }\n        switch (Utils.toLowerCase(type)) {\n            case \"bool\"     :\n            case \"boolean\"  : return EngineType.bool;\n            case \"date\"     : return EngineType.date;\n            case \"datetime\" : return EngineType.dateTime;\n            case \"time\"     : return EngineType.time;\n            case \"unsigned\" : return EngineType.unsigned;\n            case \"integer\"  : return EngineType.integer;\n            case \"float\"    : return EngineType.float;\n            case \"double\"   : return EngineType.double;\n            case \"dates\"    : return EngineType.dates;\n            case \"datetimes\": return EngineType.dateTimes;\n            case \"times\"    : return EngineType.times;\n            case \"varchar\"  : return EngineType.varchar;\n            case \"binary\"   : return EngineType.binary;\n            case \"string\"   : return EngineType.string;\n            case \"csv\"      : return EngineType.csv;\n            default         : return EngineType.none;\n        }\n    }\n\n    private static toEngineTypeModifierSimple(c: string): EngineTypeModifier {\n        switch (c) {\n            case 'a': return EngineTypeModifier.a;\n            case 'c': return EngineTypeModifier.c;\n            case 'd': return EngineTypeModifier.d;\n            case 'e': return EngineTypeModifier.e;\n            case 'i': return EngineTypeModifier.i;\n            case 'l': return EngineTypeModifier.l;\n            case 'n': return EngineTypeModifier.n;\n            case 't': return EngineTypeModifier.t;\n            case 'x': return EngineTypeModifier.x;\n            case 'z': return EngineTypeModifier.z;\n            default : return EngineTypeModifier.none;\n        }\n    }\n\n    private static toEngineTypeModifier(eType: EngineType, typeModifier: string): EngineTypeModifier {\n        let etm = EngineTypeModifier.none;\n        if (typeModifier) {\n            for (const c of typeModifier) {\n                etm |= AppService.toEngineTypeModifierSimple(c);\n            }\n        }\n        return etm;\n    }\n\n    private static makeColumn(name: string, type: string, typeModifier?: string, aliases?: string[]) {\n        const eType = AppService.toEngineType(type);\n        const eTypeModifier = AppService.toEngineTypeModifier(eType, typeModifier || \"\");\n        return {\n            name,\n            type,\n            typeModifier,\n            eType,\n            eTypeModifier,\n            aliases\n        };\n    }\n\n    /**\n     * Return `true` if a `column` is a string\n     */\n    static isString(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isString(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a csv\n     */\n    static isCsv(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isCsv(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a tree\n     */\n    static isTree(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isTree(column);\n    }\n\n    /**\n     * Return `true` if a `column` is an entity\n     */\n    static isEntity(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isEntity(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a boolean\n     */\n    static isBoolean(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isBoolean(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a date\n     */\n    static isDate(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isDate(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a double\n     */\n    static isDouble(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isDouble(column);\n    }\n\n    /**\n     * Return `true` if a `column` is an integer\n     */\n    static isInteger(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isInteger(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a number (integer or double)\n     */\n    static isNumber(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isNumber(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a scalar\n     */\n    static isScalar(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isScalar(column);\n    }\n\n    /**\n     * Return `true` if a `column` is sortable\n     */\n    static isSortable(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isSortable(column);\n    }\n\n    constructor(\n        @Inject(START_CONFIG) public startConfig: StartConfig,\n        public appWebService: AppWebService,\n        public intlService: IntlService,\n        public formatService: FormatService) {\n\n        if (!this.appName) {\n            console.error(\"Missing app name!\");\n        }\n    }\n\n    ngOnDestroy() {\n        this._events.complete();\n    }\n\n    /**\n     * Return an `Observable` stream of the events that the `AppService` can generate\n     */\n    get events(): Observable<AppEvents> {\n        return this._events;\n    }\n\n    /**\n     * Return the name of the SBA\n     */\n    get appName(): string {\n        return this.startConfig.app!;\n    }\n\n    /**\n     * Return the origin of the Sinequa server\n     */\n    get origin(): string {\n        return this.startConfig.origin!;\n    }\n\n    private initDefaultQuery() {\n        if (!this.app) {\n            console.warn(\"No app configured\");\n            return;\n        }\n        // If not set explicitly, the default query is the first in the list\n        const defaultQueryName = this.app.defaultQueryName || Utils.split(this.app.queryNames, \",\")[0];\n        this._defaultCCQuery = Utils.getField<CCQuery>(this.app.queries, defaultQueryName);\n        if (!this._defaultCCQuery) {\n            console.warn(`Query not configured for app: ${this.appName}`);\n        }\n        this.ccquery = this._defaultCCQuery;\n    }\n\n    private setApp(app: CCApp) {\n        this.app = app;\n        this.verifyServerApiVersionCompatibility(app);\n        this.cclabels = this.getWebService<CCLabels>(this.app.labels);\n        this.ccautocomplete = this.getWebService<CCAutocomplete>(this.app.autocomplete);\n        this.initDefaultQuery();\n        this.makeMaps();\n        this.suggestQueries = Utils.split(this.ccautocomplete ? this.ccautocomplete.suggestQueries : \"\", \",\");\n    }\n\n    private verifyServerApiVersionCompatibility(app: CCApp): void {\n        if (!app) {\n            console.warn('Unexpected empty app configuration.');\n            return;\n        }\n        if (!app.apiVersion) {\n            console.error(`The App config '${app.name}' is not of 'Angular Workspace application' type.`);\n        } else if (app.apiVersion !== MINIMUM_COMPATIBLE_SERVER_API_VERSION) {\n            console.warn(`This SBA is not compatible with the REST API of Sinequa Server.\\n` +\n                `The SBA expects the server API version to be at least '${MINIMUM_COMPATIBLE_SERVER_API_VERSION}',` +\n                ` whereas the server API version is '${app.apiVersion}'.`);\n        }\n    }\n\n    /**\n     * Initialize this service by retrieving the current application\n     * configuration from the Sinequa server and using it to set up the data structures\n     * on which the service relies\n     */\n    init(): Observable<CCApp> {\n        return this.appWebService.get().pipe(\n            map(app => {\n                this.setApp(app);\n                return app;\n            }\n        ));\n    }\n\n    /**\n     * Initialize this service from an application configuration object. This is typically\n     * used for supporting mutiple concurrent queries within the same application by providing\n     * component level instances of this service.\n     */\n    initFromApp(app: CCApp) {\n        if (app) {\n            this.setApp(app);\n        }\n    }\n\n    /**\n     * Refresh the application configuration, reinitializing the service if it has changed\n     *\n     * @param auditEvents Any associated audit events that should be stored\n     */\n    refresh(auditEvents?: AuditEvents): Observable<CCApp | undefined> {\n        const observable = this.appWebService.refresh(this.app ? this.app.versionId : \"\", auditEvents);\n        observable.subscribe(\n            response => {\n                if (!response.upToDate && response.app) {\n                    this.setApp(response.app);\n                }\n                return response;\n            }\n        );\n        return observable.pipe(map((value) => {\n            return this.app;\n        }));\n    }\n\n    /**\n     * Clear the data associated with the service. Typically used when processing a user logout\n     */\n    clear() {\n        this.app = undefined;\n        this.cclabels = undefined;\n        this._defaultCCQuery = undefined;\n        this.ccquery = undefined;\n        this.clearMaps();\n    }\n\n    private indexIsNormal(ccindex: CCIndex): boolean {\n        return !!ccindex && (!ccindex.indexType || Utils.startsWith(ccindex.indexType, \"normal\"));\n    }\n\n    private getIndexForQuery(ccquery: CCQuery): CCIndex | undefined {\n        if (!ccquery) {\n            return undefined;\n        }\n        const indexes = Utils.split(ccquery.searchIndexes, [\",\"]);\n        if (indexes.length === 0) {\n            return this.app ? this.app.indexes._ : undefined;\n        }\n        else {\n            const ccindex = this.getIndex(indexes[0]);\n            if (ccindex && this.indexIsNormal(ccindex)) {\n                return this.app ? this.app.indexes._ : undefined;\n            }\n            return ccindex;\n        }\n    }\n\n    private _makeColumnMapForIndex(columnMap: MapOf<CCColumn>, ccindex: CCIndex) {\n        if (!ccindex || !ccindex.columns) {\n            return;\n        }\n        for (const columnName of Object.keys(ccindex.columns)) {\n            const column = ccindex.columns[columnName];\n            columnMap[Utils.toLowerCase(column.name)] = column;\n            if (column.aliases) {\n                for (const alias of column.aliases) {\n                    columnMap[Utils.toLowerCase(alias)] = column;\n                }\n            }\n        }\n    }\n\n    private _makeColumnMapForQuery(columnMap: MapOf<CCColumn>, ccquery: CCQuery) {\n        if (!ccquery || !ccquery.columnsInfo || !ccquery.columnsInfo.columns) {\n            return;\n        }\n        const ccindex = this.getIndexForQuery(ccquery);\n        if (!ccindex || !ccindex.columns) {\n            return;\n        }\n        for (const columnInfo of ccquery.columnsInfo.columns) {\n            if (columnInfo.name) {\n                const columnName = Utils.toLowerCase(columnInfo.name);\n                let column = ccindex.columns[columnName];\n                if (!column) {\n                    column = AppService.extraColumns[columnName];\n                }\n                if (column) {\n                    // Copy column so we can add the query specific aliases and labels\n                    column = Utils.copy(column);\n                    columnMap[columnName] = column;\n                    if (columnInfo.aliases) {\n                        column.aliases = Utils.split(columnInfo.aliases, [\",\", \";\"]);\n                        for (const alias of column.aliases) {\n                            columnMap[Utils.toLowerCase(alias)] = column;\n                        }\n                    }\n                    // Overwrite labels if defined on the query\n                    if (columnInfo.label) {\n                        column.label = columnInfo.label;\n                    }\n                    if (columnInfo.labelPlural) {\n                        column.labelPlural = columnInfo.labelPlural;\n                    }\n                    if (columnInfo.formatter) {\n                        column.formatter = columnInfo.formatter;\n                    }\n                    if (columnInfo.transforms) {\n                        column.transforms = columnInfo.transforms;\n                    }\n                    if (columnInfo.parser) {\n                        column.parser = columnInfo.parser;\n                    }\n                    if (columnInfo.description) {\n                        column.description = columnInfo.description;\n                    }\n                }\n            }\n        }\n    }\n\n    protected makeMaps() {\n        this.columnsByQuery = {};\n        this.columnsByIndex = {};\n        this.fieldsByQuery = {};\n        if (!this.app) {\n            return;\n        }\n        let columnMap: MapOf<CCColumn>;\n\n        // Queries\n        if (this.app.queries) {\n            for (const queryName of Object.keys(this.app.queries)) {\n                const ccquery = this.app.queries[queryName];\n                if (ccquery) {\n                    ccquery.$columnFieldsPattern = new PatternMatcher(\"included column fields\", \"excluded column fields\");\n                    ccquery.$columnFieldsPattern.includedPattern.setText(ccquery.columnFieldsIncluded);\n                    ccquery.$columnFieldsPattern.excludedPattern.setText(ccquery.columnFieldsExcluded);\n                    ccquery.$partnameFieldsPattern = new PatternMatcher(\"included part name fields\", \"excluded part name fields\");\n                    ccquery.$partnameFieldsPattern.includedPattern.setText(ccquery.partnameFieldsIncluded);\n                    ccquery.$partnameFieldsPattern.excludedPattern.setText(ccquery.partnameFieldsExcluded);\n                    if (ccquery.columnsInfo) {\n                        columnMap = {};\n                        this.columnsByQuery[Utils.toLowerCase(ccquery.name)] = columnMap;\n                        this._makeColumnMapForQuery(columnMap, ccquery);\n                    }\n                }\n            }\n        }\n\n        // Indexes\n        if (this.app.indexes) {\n            // Special normal index\n            const ccindex = this.app.indexes._;\n            if (ccindex) {\n                columnMap = {};\n                this.columnsByIndex._ = columnMap;\n                this._makeColumnMapForIndex(columnMap, ccindex);\n\n            }\n            for (const indexName of Object.keys(this.app.indexes)) {\n                const ccindex1 = this.app.indexes[Utils.toLowerCase(indexName)];\n                if (ccindex1) {\n                    if (this.indexIsNormal(ccindex1)) {\n                        if (ccindex1.name !== \"_\") {\n                            this.columnsByIndex[Utils.toLowerCase(ccindex1.name)] = this.columnsByIndex._;\n                        }\n                    }\n                    else {\n                        columnMap = {};\n                        this.columnsByIndex[Utils.toLowerCase(ccindex1.name)] = columnMap;\n                        this._makeColumnMapForIndex(columnMap, ccindex1);\n                    }\n                }\n            }\n        }\n\n        // Fields per query (contains aliases for default query and globally defined aliases)\n        const globalFields = new Map<string, string>();\n        const columns = this.columnsByIndex._;\n        if (columns) {\n            for (const key of Object.keys(columns)) {\n                const column = columns[key];\n                if (column.aliases && column.aliases.length > 0) {\n                    const alias = column.aliases[0];\n                    if (alias) {\n                        globalFields.set(alias, alias);\n                    }\n                }\n            }\n        }\n        for (const queryName of Object.keys(this.columnsByQuery)) {\n            const queryFields = new Map<string, string>(globalFields);\n            const columns1 = this.columnsByQuery[Utils.toLowerCase(this.defaultCCQuery ? this.defaultCCQuery.name : \"\")];\n            if (columns1) {\n                for (const key of Object.keys(columns1)) {\n                    const column = columns1[key];\n                    if (column.aliases && column.aliases.length > 0) {\n                        const alias = column.aliases[0];\n                        if (alias) {\n                            queryFields.set(alias, alias);\n                        }\n                    }\n                }\n                this.fieldsByQuery[queryName] = Array.from(queryFields.keys());\n            }\n        }\n    }\n\n    protected clearMaps() {\n        this.columnsByQuery = {};\n        this.columnsByIndex = {};\n        this.fieldsByQuery = {};\n    }\n\n    /**\n     * Get the configuration of the web service with the passed name\n     */\n    getWebService<T extends CCWebService>(name: string): T | undefined {\n        if (!this.app) {\n            return undefined;\n        }\n        return Utils.getField<CCConfig>(this.app.webServices, name) as T;\n    }\n\n    /**\n     * Get the list configuration with the passed name\n     */\n    getList(name: string): CCList | undefined {\n        if (!this.app) {\n            return undefined;\n        }\n        return this.app.lists[name];\n    }\n\n    /**\n     * Return the default {@link CCQuery}\n     */\n    get defaultCCQuery(): CCQuery | undefined {\n        return this._defaultCCQuery;\n    }\n\n    /**\n     * Return the current {@link CCQuery}\n     */\n    get ccquery(): CCQuery | undefined {\n        if (!!this._ccquery) {\n            return this._ccquery;\n        }\n        return this._defaultCCQuery;\n    }\n\n    /**\n     * Set the current {@link CCQuery}\n     */\n    set ccquery(value: CCQuery | undefined) {\n        if (value !== this._ccquery) {\n            const previous = this._ccquery;\n            this._ccquery = value;\n            this._events.next({type: \"query-changed\", current: this._ccquery, previous: previous});\n        }\n    }\n\n    /**\n     * Get the {@link CCQuery} with the passed name\n     */\n    getCCQuery(name: string): CCQuery | undefined {\n        return this.app ? this.app.queries[Utils.toLowerCase(name)] : undefined;\n    }\n\n    /**\n     * Set the current {@link CCQuery} to that with the passed name\n     */\n    setCCQuery(name?: string): boolean {\n        const ccquery = !name ? this.defaultCCQuery : this.getCCQuery(name);\n        if (ccquery) {\n            this.ccquery = ccquery;\n            return true;\n        }\n        else {\n            console.warn(`AppService.setCCQuery - query '${name}' does not exist`);\n            return false;\n        }\n    }\n\n    /**\n     * Return the fields defined on the current {@link CCQuery}\n     */\n    get fields(): string[] {\n        if (!this.ccquery) {\n            return [];\n        }\n        return this.fieldsByQuery[Utils.toLowerCase(this.ccquery.name)] || [];\n    }\n\n    /**\n     * Get the {@link CCAggregation} with the passed name\n     */\n    getCCAggregation(name: string): CCAggregation | undefined {\n        if (!this.ccquery || !this.ccquery.aggregations) {\n            return undefined;\n        }\n        return this.ccquery.aggregations.find((value) => Utils.eqNC(name, value.name));\n    }\n\n    /**\n     * Get the {@link CCIndex} with the passed name\n     */\n    getIndex(name: string): CCIndex | undefined {\n        if (!this.app) {\n            return undefined;\n        }\n        return Utils.getField<CCIndex>(this.app.indexes, name);\n    }\n\n    /**\n     * Get the {@link CCColumn} with the passed name. Aliases are resolved\n     */\n    getColumn(name: string | null | undefined): CCColumn | undefined {\n        if (!name) {\n            return undefined;\n        }\n        if (!this.ccquery) {\n            return undefined;\n        }\n        // First, CCQuery specific aliases\n        let column: CCColumn;\n        let columnAliases = this.columnsByQuery[Utils.toLowerCase(this.ccquery.name)];\n        if (columnAliases) {\n            column = columnAliases[Utils.toLowerCase(name)];\n            if (column) {\n                return column;\n            }\n        }\n        // Second, aliases by index\n        const indexes = Utils.split(this.ccquery.searchIndexes, [\",\"]);\n        const firstIndex = indexes.length === 0 ? undefined : this.getIndex(indexes[0]);\n        if (indexes.length === 0 || (!!firstIndex && this.indexIsNormal(firstIndex))) {\n            columnAliases = this.columnsByIndex._;\n            if (columnAliases) {\n                column = columnAliases[Utils.toLowerCase(name)];\n                if (column) {\n                    return column;\n                }\n            }\n        }\n        else {\n            for (const index of indexes) {\n                columnAliases = this.columnsByIndex[Utils.toLowerCase(index)];\n                if (columnAliases) {\n                    column = columnAliases[Utils.toLowerCase(name)];\n                    if (column) {\n                        return column;\n                    }\n                }\n            }\n        }\n        // Third, extra columns\n        column = AppService.extraColumns[Utils.toLowerCase(name)];\n        if (column) {\n            return column;\n        }\n        return undefined;\n    }\n\n    /**\n     * Get the default alias a column\n     *\n     * @param column The column\n     * @return The default alias or `null` if no alias is defined\n     */\n    getColumnDefaultAlias(column?: CCColumn): string {\n        if (column) {\n            if (column.aliases && column.aliases.length > 0) {\n                return column.aliases[0];\n            }\n        }\n        return \"\";\n    }\n\n    /**\n     * Get the name of a column\n     *\n     * @param column The column\n     * @param _default A default name to return if `column` is empty\n     */\n    private getColumnName(column?: CCColumn, _default = \"\"): string {\n        if (column) {\n            return column.name;\n        }\n        return _default;\n    }\n\n    /**\n     * Get the default alias for a column\n     *\n     * @param column The column\n     * @param _default A default alias name to return if the `column` is empty or no alias is defined\n     */\n    getColumnAlias(column?: CCColumn, _default = \"\"): string {\n        if (column) {\n            const alias = this.getColumnDefaultAlias(column);\n            if (alias) {\n                return alias;\n            }\n        }\n        return _default;\n    }\n\n    /**\n     * Return a column name from a name which can be an alias\n     */\n    resolveColumnName(name: string | null | undefined): string {\n        const column = this.getColumn(name);\n        return this.getColumnName(column, name || \"\");\n    }\n\n    /**\n     * Return a column alias from a name which can be an alias\n     */\n    resolveColumnAlias(name: string | null | undefined): string {\n        const column = this.getColumn(name);\n        return this.getColumnAlias(column, name || \"\");\n    }\n\n    /**\n     * Parse a fielded search expression\n     *\n     * @param text The expression\n     * @param options Options for the parsing\n     * @return The parsed {@link Expr} or an error message\n     */\n    parseExpr(text: string, options?: ExprParserOptions): Expr | string {\n        return ExprParser.parse(text, {appService: this, formatService: this.formatService, intlService: this.intlService}, options);\n    }\n\n    /**\n     * Escape a value for fielded search if necessary. `Date` objects are converted to\n     * Sinequa system date strings and non-scalars fields are escaped\n     * @param field The value's field\n     * @param value The value\n     */\n    escapeFieldValue(field: string, value: string | number | Date | boolean | undefined): string {\n        if (Utils.isDate(value)) {\n            return Utils.toSysDateStr(value);\n        }\n        value = value + \"\";\n        const column = this.getColumn(field);\n        if (column && !AppService.isScalar(column)) {\n            // escaoe columns that might contain search operators in them (treating negative numbers as an ignorable edge case)\n            return ExprParser.escape(value);\n        }\n        return value;\n    }\n\n    /**\n     * Get the label of a column. The plural label is returned for csv-type columns.\n     *\n     * @param name The name of the column which can be an alias\n     * @param _default The default label to return if no label is defined\n     */\n    getLabel(name: string, _default?: string): string {\n        const column = this.getColumn(name);\n        if (column) {\n            const label = AppService.isCsv(column) ? column.labelPlural : column.label;\n            if (label) {\n                return label;\n            }\n        }\n        if (!Utils.isUndefined(_default)) {\n            return _default;\n        }\n        return name;\n    }\n\n    /**\n     * Get the singular label of a column\n     *\n     * @param name The name of the column which can be an alias\n     * @param _default The default label to return if no label is defined\n     */\n    getSingularLabel(name: string, _default?: string): string {\n        const column = this.getColumn(name);\n        if (column && column.label) {\n            return column.label;\n        }\n        if (!Utils.isUndefined(_default)) {\n            return _default;\n        }\n        return name;\n    }\n\n    /**\n     * Get the plural label of a column\n     *\n     * @param name The name of the column which can be an alias\n     * @param _default The default label to return if no label is defined\n     */\n    getPluralLabel(name: string, _default?: string): string {\n        const column = this.getColumn(name);\n        if (column && column.labelPlural) {\n            return column.labelPlural;\n        }\n        if (!Utils.isUndefined(_default)) {\n            return _default;\n        }\n        return name;\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a string\n     */\n    isString(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isString(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a csv\n     */\n    isCsv(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isCsv(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a tree\n     */\n    isTree(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isTree(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is an entity\n     */\n    isEntity(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isEntity(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a boolean\n     */\n    isBoolean(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isBoolean(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a date\n     */\n    isDate(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isDate(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a double\n     */\n    isDouble(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isDouble(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is an integer\n     */\n    isInteger(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isInteger(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a number (integer or double)\n     */\n    isNumber(name: string): boolean {\n        return this.isInteger(name) || this.isDouble(name);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a scalar\n     */\n    isScalar(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isScalar(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is sortable\n     */\n    isSortable(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isSortable(column);\n    }\n\n    /**\n     * If the passed url is relative and CORS is active then\n     * prepend it with the Sinequa server origin\n     */\n    updateUrlForCors(url: string): string {\n        if (this.startConfig.corsActive && !!url && !Utils.isUrlAbsolute(url)) {\n            url = Utils.addUrl(this.origin, url);\n        }\n        return url;\n    }\n\n    /**\n     * Return the url to the Sinequa administration console\n     */\n    get adminUrl(): string {\n        return this.updateUrlForCors(Utils.addUrl(this.startConfig.applicationPath!, \"admin\"));\n    }\n}","import {Injectable, Inject} from \"@angular/core\";\nimport {HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpParams} from \"@angular/common/http\";\nimport {Observable} from \"rxjs\";\nimport {START_CONFIG, StartConfig, AuditRecord, AuditEvent, AuditEvents} from \"@sinequa/core/web-services\";\nimport {Utils} from \"@sinequa/core/base\";\n\n/**\n * An `HttpInterceptor` to process audi events attached to the request body\n * in the `$auditRecord` member.\n */\n@Injectable({\n    providedIn: \"root\"\n})\nexport class AuditInterceptor implements HttpInterceptor {\n    \n    // Store the session id and its datetime of creation/refresh\n    sessionid: string;\n    sessionstart: Date;\n\n    constructor(\n        @Inject(START_CONFIG) private startConfig: StartConfig\n    ) {\n    }\n\n    private shouldIntercept(url: string): boolean {\n        return Utils.startsWith(url, this.startConfig.apiPath!);\n    }\n\n    private isJsonable(obj): boolean {\n        return (Utils.isObject(obj) || Utils.isArray(obj)) && !Utils.isArrayBuffer(obj) && !Utils.isBlob(obj) &&\n            !Utils.isString(obj) && !(obj instanceof HttpParams);\n    }\n\n    // Handle legacy calls where auditEvents is either an AuditEvent or AuditEvent[]\n    private ensureAuditRecord(auditEvents: AuditEvents): AuditRecord | undefined{\n        if (!auditEvents) {\n            return undefined;\n        }\n        let auditEvents1: AuditEvent[] | undefined;\n        if (Utils.isArray(auditEvents)) {\n            auditEvents1 = auditEvents;\n        }\n        else if (Utils.isObject(auditEvents)) {\n            const auditRecord = auditEvents as AuditRecord;\n            if (auditRecord.auditEvents || auditRecord.mlAuditEvents) {\n                return auditRecord;\n            }\n            auditEvents1 = [auditEvents as AuditEvent];\n        }\n        return {\n            auditEvents: auditEvents1\n        };\n    }\n\n    /**\n     * Add a sessionid to all the audit events\n     * @param auditRecord \n     */\n    private addSessionId(auditRecord?: AuditRecord) {\n        const sessionid = this.getSessionId();\n        auditRecord?.auditEvents?.forEach(event => {\n            if(!event.detail) {\n                event.detail = {};\n            }\n            event.detail['session-id'] = sessionid;\n        });\n    }\n\n    /**\n     * Get a Session Id initialized upon login. The session is maintained for 10 minutes\n     * after the last call to this method.\n     */\n    private getSessionId(): string {\n        if(!this.sessionid || this.isSessionStale()) {\n            this.sessionid = Utils.guid();\n        }\n        this.sessionstart = new Date();\n        return this.sessionid;\n    }\n\n    /**\n     * Test whether the current session id valid or stale (need to be refreshed)\n     */\n    private isSessionStale(): boolean {\n        const lastSession = new Date().getTime() - this.sessionstart.getTime();\n        // Consider the session stale after 10 minutes\n        return lastSession > 10 * 60 * 1000;\n    }\n\n    /**\n     * Called once the `$auditRecord` member has been standardized, this method\n     * can be overidden to update fields in the audit events associated with a\n     * web service call.\n     */\n    protected updateAuditRecord(auditRecord?: AuditRecord) {\n    }\n\n    /**\n     * Intercept requests with a JSON body and standardize the format of the\n     * `$auditRecord` member.\n     */\n    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n        if (this.shouldIntercept(request.url) && this.isJsonable(request.body)) {\n            request.body.$auditRecord = this.ensureAuditRecord(request.body.$auditRecord);\n            this.addSessionId(request.body.$auditRecord);\n            this.updateAuditRecord(request.body.$auditRecord);\n        }\n        return next.handle(request);\n    }\n}\n","const APP_UTILS_MODULE_PROVIDERS = [];\n\nexport {APP_UTILS_MODULE_PROVIDERS};\n","import {NgModule} from \"@angular/core\";\nimport {BaseModule} from \"@sinequa/core/base\";\nimport {IntlModule} from \"@sinequa/core/intl\";\nimport {WebServicesModule} from \"@sinequa/core/web-services\";\n\nimport {APP_UTILS_MODULE_PROVIDERS} from \"./module.providers\";\n\n/**\n * This module contains a utility {@link AppService} for managing the configuration of a Sinequa SBA and a {@link FormatService}\n * for handling the formatting and parsing of Sinequa field values. It also contains an implementation of a {@link Query} class\n * as well as classes for manipulating Sinequa fielded search expressions.\n *\n * The {@link AuditInterceptor} in this module should be registered using `HTTP_INTERCEPTORS` in your app module.\n */\n@NgModule({\n    imports: [\n        BaseModule,\n        IntlModule,\n        WebServicesModule\n    ],\n    declarations: [\n    ],\n    exports: [\n    ],\n    providers: [\n        ...APP_UTILS_MODULE_PROVIDERS\n    ]\n})\nexport class AppUtilsModule {\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}