{"version":3,"file":"sinequa-core-validation.js","sources":["../../../projects/core/validation/validation.service.ts","../../../projects/core/validation/validation.directive.ts","../../../projects/core/validation/validation-error.pipe.ts","../../../projects/core/validation/validation-message.component.ts","../../../projects/core/validation/module.providers.ts","../../../projects/core/validation/validation.module.ts","../../projects/core/validation/messages/en.ts","../../projects/core/validation/messages/fr.ts","../../projects/core/validation/messages/de.ts","../../projects/core/validation/messages/index.ts","../../../projects/core/validation/sinequa-core-validation.ts"],"sourcesContent":["import {Injectable} from \"@angular/core\";\nimport {Validators, ValidatorFn, AbstractControl, ValidationErrors} from \"@angular/forms\";\nimport {IntlService} from \"@sinequa/core/intl\";\nimport {FormatService} from \"@sinequa/core/app-utils\";\nimport {Utils} from \"@sinequa/core/base\";\n\n/**\n * @ignore\n */\nfunction isEmptyInputValue(value: any): boolean {\n    // we don't check for string here so it also works with arrays\n    return value === null || value === undefined || value.length === 0;\n}\n\nconst processInputValue = (value: any) => { // add support for object values of the advanced search\n  if (Utils.isArray(value)) {\n    return value.map(\n      (val) => {\n        if (Utils.isObject(val) && val.hasOwnProperty(\"value\")) {\n          return val.value;\n        }\n        return val;\n      }\n    )\n  } else {\n    if (Utils.isObject(value) && value.hasOwnProperty(\"value\")) {\n      return [value.value];\n    }\n    return [value];\n  }\n}\n\n// Email regular expression, taken from built-in Angular validators.\n/**\n * @ignore\n */\nconst EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n\n/**\n * Enumerates the supported validator types.\n */\nexport enum ValidatorType {\n    Min = \"Min\",\n    Max = \"Max\",\n    Required = \"Required\",\n    Email = \"Email\",\n    Pattern = \"Pattern\",\n    Integer = \"Integer\",\n    Number = \"Number\",\n    Date = \"Date\",\n    Range = \"Range\",\n}\n\n/**\n * Describes a `Validator` object.\n */\nexport interface Validator {\n    /**\n     * The validator's type.\n     */\n    type: ValidatorType;\n    /**\n     * The validator's name.\n     */\n    name: string;\n    /**\n     * The validator's error message to be displayed when a value is invalid.\n     */\n    errorMessage: string;\n    /**\n     * `true` if the validator is to be applied.\n     */\n    active: boolean;\n}\n\n/**\n * Defines the default error messages for each validator.\n */\nconst errorMessagesMap = {\n    // Built-in Angular validators\n    min: \"msg#validation.min\",\n    max: \"msg#validation.max\",\n    required: \"msg#validation.required\",\n    requiredTrue: \"msg#validation.requiredTrue\",\n    email: \"msg#validation.email\",\n    minlength: \"msg#validation.minLength\",\n    maxlength: \"msg#validation.maxLength\",\n    pattern: \"msg#validation.pattern\",\n\n    // Custom\n    unique: \"msg#validation.unique\",\n    integer: \"msg#validation.integer\",\n    number: \"msg#validation.number\",\n    date: \"msg#validation.date\",\n    range: \"msg#validation.range\"\n};\n\n\n/**\n * This service provides a set of locale-sensitive validators with support for arrays.\n * The validator error messages are {@link IntlService} `msg#` messages of the form:\n * `msg#validation.<validator name>`.\n */\n@Injectable({\n    providedIn: \"root\"\n})\nexport class ValidationService {\n    constructor(\n        protected formatService: FormatService,\n        protected intlService: IntlService) {\n    }\n\n    /**\n     * A pattern validator based on Angular's `Validators.pattern` with support for value arrays.\n     *\n     * @param pattern The pattern.\n     * @returns The validation function.\n     */\n    static patternValidator(pattern: string | RegExp): ValidatorFn {\n        // #region This code region is based on Validators.pattern()\n        if (!pattern) {\n            return Validators.nullValidator;\n        }\n\n        let regex: RegExp;\n        let regexStr: string;\n        if (typeof pattern === 'string') {\n            regexStr = '';\n\n            if (pattern.charAt(0) !== '^') {\n                regexStr += '^';\n            }\n\n            regexStr += pattern;\n\n            if (pattern.charAt(pattern.length - 1) !== '$') {\n                regexStr += '$';\n            }\n\n            regex = new RegExp(regexStr);\n        } else {\n            regexStr = pattern.toString();\n            regex = pattern;\n        }\n        // #endregion\n\n        return (control: AbstractControl): ValidationErrors | null => {\n            if (isEmptyInputValue(control.value)) {\n                return null;  // don't validate empty values to allow optional controls\n            }\n\n            let values: any[] = [];\n            values = processInputValue(control.value);\n\n            for (const value of values) {\n                if (!regex.test(value)) {\n                    return {pattern: {requiredPattern: pattern.toString(), actualValue: value}};\n                }\n            }\n\n            return null;\n        };\n    }\n\n    /**\n     * A pattern validator based on Angular's `Validators.email` with support for value arrays.\n     *\n     * @param control The control to validate.\n     * @returns The result.\n     */\n    static emailValidation(control: AbstractControl): ValidationErrors | null {\n        if (isEmptyInputValue(control.value)) {\n            return null;  // don't validate empty values to allow optional controls\n        }\n\n        let values: any[] = [];\n        values = processInputValue(control.value);\n\n        for (const value of values) {\n            if (!EMAIL_REGEXP.test(value)) {\n                return {email: true};\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Get the name of the first validator in a map of validation errors.\n     * @param errors The validation errors\n     * @returns The name of the first validator, if any - `undefined` otherwise.\n     */\n    getFirstError(errors: ValidationErrors): string | undefined {\n        if (errors) {\n            return Object.keys(errors)[0];\n        }\n        return undefined;\n    }\n\n    /**\n     * Get the error message associated with the passed validator.\n     * @param name The name of a validator.\n     * @returns The error message.\n     */\n    getErrorText(name?: string): string {\n        const text = name ? errorMessagesMap[name] : undefined;\n        if (!text) {\n            return \"Unknown validator: \" + name;\n        }\n        return text;\n    }\n\n    /**\n     * Get the error message associated with first validator in a map of validation errors.\n     * @param errors The validation errors.\n     * @returns The error message.\n     */\n    getFirstErrorText(errors: ValidationErrors): string | undefined {\n        if (errors) {\n            const error = this.getFirstError(errors);\n            if (error) {\n                return this.getErrorText(error);\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Get the data held for the first error in a map of validation errors\n     * @param errors The validation errors.\n     */\n    getFirstErrorInfo(errors: ValidationErrors): any {\n        if (errors) {\n            const error = this.getFirstError(errors);\n            if (error) {\n                return errors[error];\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Get a validator function that validates that values are greater than or equal\n     * to the passed `min` value. The function supports single values and arrays of\n     * values and will optionally parse the values using the {@link FormatService} if\n     * a parser is passed. Dates will be parsed according to the current locale.\n     *\n     * @param min The minimum value to test against. The type determines\n     * how the test will be made.\n     * @param parser An optional parser name.\n     */\n    minValidator(min: string | number | Date, parser?: string): ValidatorFn {\n        return (control: AbstractControl): ValidationErrors | null => {\n            if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n                return null;  // don't validate empty values to allow optional controls\n            }\n\n            let values: any[] = [];\n            values = processInputValue(control.value);\n\n            for (const value of values) {\n                if (!isEmptyInputValue(value)) {\n                    let value1 = value;\n                    if (parser) {\n                        value1 = this.formatService.parseValue(value1, parser);\n                    }\n                    let cmp = 0;\n                    if (Utils.isNumber(min)) {\n                        if (Utils.testFloat(value1)) {\n                            value1 = Utils.toNumber(value1);\n                            cmp = value1 - min;\n                        }\n                    }\n                    else if (Utils.isString(min)) {\n                        cmp = Utils.compare(value1, min);\n                    }\n                    else if (Utils.isDate(min)) {\n                        if (Utils.isString(value1)) {\n                            value1 = this.intlService.parseDate(value1);\n                            if (value1) {\n                                cmp = value1.getTime() - min.getTime();\n                            }\n                        }\n                        else if (Utils.isDate(value1)) { // ngx-bootstrap returns date values (new Date(NaN) if invalid)\n                            cmp = value1.getTime() - min.getTime();\n                        }\n                    }\n                    if (cmp < 0) {\n                        return {min: {min, actual: value}};\n                    }\n                }\n            }\n            return null;\n        };\n    }\n\n    /**\n     * Get a validator function that validates that values are less than or equal\n     * to the passed `max` value. The function supports single values and arrays of\n     * values and will optionally parse the values using the {@link FormatService} if\n     * a parser is passed. Dates will be parsed according to the current locale.\n     *\n     * @param max The maximum value to test against. The type determines\n     * how the test will be made.\n     * @param parser An optional parser name.\n     */\n    maxValidator(max: string | number | Date, parser?: string): ValidatorFn {\n        return (control: AbstractControl): ValidationErrors | null => {\n            if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n                return null;  // don't validate empty values to allow optional controls\n            }\n            let values: any[] = [];\n            values = processInputValue(control.value);\n\n            for (const value of values) {\n                if (!isEmptyInputValue(value)) {\n                    let value1 = value;\n                    if (parser) {\n                        value1 = this.formatService.parseValue(value1, parser);\n                    }\n                    let cmp = 0;\n                    if (Utils.isNumber(max)) {\n                        if (Utils.testFloat(value1)) {\n                            value1 = Utils.toNumber(value1);\n                            cmp = value1 - max;\n                        }\n                    }\n                    else if (Utils.isString(max)) {\n                        cmp = Utils.compare(value1, max);\n                    }\n                    else if (Utils.isDate(max)) {\n                        if (Utils.isString(value1)) {\n                            value1 = this.intlService.parseDate(value1);\n                            if (value1) {\n                                cmp = value1.getTime() - max.getTime();\n                            }\n                        }\n                        else if (Utils.isDate(value1)) { // ngx-bootstrap returns date values (new Date(NaN) if invalid)\n                            cmp = value1.getTime() - max.getTime();\n                        }\n                    }\n                    if (cmp > 0) {\n                        return {max: {max, actual: value}};\n                    }\n                }\n            }\n            return null;\n        };\n    }\n\n    /**\n     * Get a validator function that validates that values are integers. The function\n     * supports single values and arrays of values and will optionally parse the values\n     * using the {@link FormatService} if a parser is passed.\n     *\n     * @param parser An optional parser name.\n     */\n    integerValidator(parser?: string): ValidatorFn {\n        return (control: AbstractControl): ValidationErrors | null => {\n            if (isEmptyInputValue(control.value)) {\n                return null;  // don't validate empty values to allow optional controls\n            }\n            let values: any[] = [];\n            values = processInputValue(control.value);\n\n            for (const value of values) {\n                if (!isEmptyInputValue(value)) {\n                    let value1 = value;\n                    if (parser) {\n                        value1 = this.formatService.parseValue(value1, parser);\n                    }\n                    if (!Utils.testInteger(value1)) {\n                        return {integer: {value}};\n                    }\n                }\n            }\n            return null;\n        };\n    }\n\n    /**\n     * Get a validator function that validates that values are numeric. The function\n     * supports single values and arrays of values and will optionally parse the values\n     * using the {@link FormatService} if a parser is passed.\n     *\n     * @param parser An optional parser name.\n     */\n    numberValidator(parser?: string): ValidatorFn {\n        return (control: AbstractControl): ValidationErrors | null => {\n            if (isEmptyInputValue(control.value)) {\n                return null;  // don't validate empty values to allow optional controls\n            }\n            let values: any[] = [];\n            values = processInputValue(control.value);\n\n            for (const value of values) {\n                if (!isEmptyInputValue(value)) {\n                    let value1 = value;\n                    if (parser) {\n                        value1 = this.formatService.parseValue(value1, parser);\n                    }\n                    if (!Utils.testFloat(value1)) {\n                        return {number: {value}};\n                    }\n                }\n            }\n            return null;\n        };\n    }\n\n    /**\n     * Get a validator function that validates that values are dates. The function\n     * supports single values and arrays of values and will optionally parse the values\n     * using the {@link FormatService} if a parser is passed. Dates will be parsed according\n     * to the current locale.\n     *\n     * @param parser An optional parser name.\n     */\n    dateValidator(parser?: string): ValidatorFn {\n        return (control: AbstractControl): ValidationErrors | null => {\n            if (isEmptyInputValue(control.value)) {\n                return null;  // don't validate empty values to allow optional controls\n            }\n            let values: any[] = [];\n            values = processInputValue(control.value);\n\n            for (const value of values) {\n                if (!isEmptyInputValue(value)) {\n                    if (Utils.isString(value)) {\n                        let value1 = value;\n                        if (parser) {\n                            value1 = this.formatService.parseValue(value1, parser);\n                        }\n                        if (!this.intlService.parseDate(value1)) {\n                            return {date: {value}};\n                        }\n                    }\n                    else if (Utils.isDate(value)) { // ngx-bootstrap returns date values (new Date(NaN) if invalid)\n                        if (isNaN(value.getTime())) {\n                            return {date: {value}};\n                        }\n                    }\n                }\n            }\n            return null;\n        };\n    }\n\n    /**\n     * Get a validator function that validates that, for pair of values, the second value is\n     * greater than the first. If one or both values are empty then the validation passes.\n     * The validator function supports single values and arrays of values and will optionally\n     * parse the values using the {@link FormatService} if a parser is passed. Dates will be\n     * parsed according to the current locale.\n     *\n     * @param type A value whose type indicates how the range test will be made.\n     * @param parser An optional parser name.\n     */\n    rangeValidator(type: string | number | Date, parser?: string): ValidatorFn {\n        return (control: AbstractControl): ValidationErrors | null => {\n            if (isEmptyInputValue(control.value) || !Utils.isArray(control.value) || control.value.length !== 2) {\n                return null;  // don't validate empty values to allow optional controls\n            }\n            let value1 = control.value[0];\n            let value2 = control.value[1];\n            if (isEmptyInputValue(value1) || isEmptyInputValue(value2)) {\n                return null;\n            }\n            if (parser) {\n                value1 = this.formatService.parseValue(value1, parser);\n                value2 = this.formatService.parseValue(value2, parser);\n            }\n            let cmp = 0;\n            if (Utils.isString(type)) {\n                cmp = Utils.compare(value2, value1);\n            }\n            else if (Utils.isDate(type)) {\n                let date1: Date | undefined;\n                let date2: Date | undefined;\n                if (Utils.isString(value1)) {\n                    date1 = this.intlService.parseDate(value1);\n                }\n                else if (Utils.isDate(value1)) { // ngx-bootstrap returns date values (new Date(NaN) if invalid)\n                    date1 = value1;\n                }\n                if (Utils.isString(value2)) {\n                    date2 = this.intlService.parseDate(value2);\n                }\n                else if (Utils.isDate(value2)) { // ngx-bootstrap returns date values (new Date(NaN) if invalid)\n                    date2 = value2;\n                }\n                if (date1 && date2) {\n                    cmp = date2.getTime() - date1.getTime();\n                }\n            }\n            else if (Utils.isNumber(type)) {\n                if (Utils.testFloat(value1) && Utils.testFloat(value2)) {\n                    const num1 = Utils.toNumber(value1);\n                    const num2 = Utils.toNumber(value2);\n                    if (num1 !== null && num2 !== null) {\n                        cmp = num2 - num1;\n                    }\n                }\n            }\n            return cmp < 0 ? {range: {value1, value2}} : null;\n        };\n    }\n}\n","import {Directive, Input, OnInit, DoCheck, InjectionToken, Type, Inject, ViewContainerRef} from \"@angular/core\";\nimport {FormGroup, AbstractControl} from \"@angular/forms\";\nimport {Utils, MapOf} from \"@sinequa/core/base\";\nimport {LoadComponentService, LoadedComponent} from \"@sinequa/core/load-component\";\nimport {ValidationService} from \"./validation.service\";\n\n/**\n * Describes the options that can be passed to {@link ValidationDirective}.\n */\nexport interface ValidationOptions {\n    /**\n     * The `FormGroup` container.\n     */\n    form: FormGroup;\n    /**\n     * Identifies the control to validate. Defaults to the value of the `formControlName`\n     * attribute on the element to which the `ValidationDirective` is attached.\n     */\n    controlName?: string;\n    /**\n     * The class name to set on the element if validation passes. Defaults to `is-valid`.\n     */\n    validClass?: string;\n    /**\n     * The class name to set on the element if validation fails. Defaults to `is-invalid`.\n     */\n    invalidClass?: string;\n    /**\n     * The selector to identify children of the element to which to also apply the validity\n     * classes. Defaults to `.form-control`. Set to `null` to not select any children.\n     */\n    childSelector?: string;\n    /**\n     * Custom error messages to use for the validators. By default the messages defined in\n     * {@link ValidationService} are used.\n     */\n    errorMessages?: MapOf<string>;\n}\n\n/**\n * An injection token that can be provided to override the component loaded by {@link ValidationDirective}\n * to display validation error messages. The default component is {@link ValidationMessageComponent}.\n */\nexport const VALIDATION_MESSAGE_COMPONENT = new InjectionToken<Type<any>>(\"VALIDATION_MESSAGE_COMPONENT\");\n\n/**\n * A directive to automatically add validity classes to the element to which it is attached. In addition,\n * when the associated `FormControl` is invalid a component is dynamically loaded after the element to display\n * the validation message.\n * The component to load can be specified by providing the {@link VALIDATION_MESSAGE_COMPONENT} injection token.\n * By default, the {@link ValidationMessageComponent} component is used.\n */\n@Directive({\n    selector: \"[sqValidation]\"\n})\nexport class ValidationDirective implements OnInit, DoCheck {\n    @Input(\"sqValidation\") options: FormGroup | ValidationOptions;\n    private element: HTMLElement;\n    private form: FormGroup;\n    private control: AbstractControl;\n    private validClass?: string;\n    private invalidClass?: string;\n    private childSelector?: string;\n    private errorMessages?: MapOf<string>;\n    private validationMessage: LoadedComponent;\n    private active: boolean;\n    private valid: boolean;\n    private dirty: boolean;\n    private error?: string;\n    private errorInfo?: string;\n\n    constructor(\n        @Inject(VALIDATION_MESSAGE_COMPONENT) private validationMessageComponent: Type<any>,\n        private viewContainerRef: ViewContainerRef,\n        private loadComponentService: LoadComponentService,\n        private validationService: ValidationService) {\n        this.element = viewContainerRef.element.nativeElement;\n    }\n\n    ngOnInit() {\n        if (!this.options) {\n            console.log(\"Validation.ngOnInit - no options\");\n            return;\n        }\n        let controlName;\n        if (this.options instanceof FormGroup) {\n            this.form = this.options;\n        }\n        else {\n            this.form = this.options.form;\n            controlName = this.options.controlName;\n            this.validClass = this.options.validClass;\n            this.invalidClass = this.options.invalidClass;\n            this.childSelector = this.options.childSelector;\n            this.errorMessages = this.options.errorMessages;\n        }\n        if (!this.form) {\n            console.log(\"Validation.ngOnInit - no form model\");\n            return;\n        }\n        if (!this.form.controls) {\n            console.log(\"Validation.ngOnInit - no form controls\");\n            return;\n        }\n        if (controlName) {\n            this.control = this.form.controls[controlName];\n        }\n        else {\n            const formControlName = this.element.getAttribute(\"formControlName\");\n            if (formControlName) {\n                this.control = this.form.controls[formControlName];\n            }\n        }\n        if (!this.control) {\n            console.log(\"Validation.ngOnInit - no control\");\n            return;\n        }\n        if (!this.validClass) {\n            this.validClass = \"is-valid\";\n        }\n        if (!this.invalidClass) {\n            this.invalidClass = \"is-invalid\";\n        }\n        if (Utils.isUndefined(this.childSelector)) {\n            this.childSelector = \".form-control\";\n        }\n        this.valid = this.control.valid;\n        this.dirty = this.control.dirty;\n        this.active = true;\n        this.error = undefined;\n    }\n\n    private getFirstError(): string | undefined {\n        if (this.control.errors) {\n            return Object.keys(this.control.errors)[0];\n        }\n        return undefined;\n    }\n\n    private getErrorText(error?: string): string {\n        if (error && this.errorMessages && !!this.errorMessages[error]) {\n            return this.errorMessages[error];\n        }\n        return this.validationService.getErrorText(error);\n    }\n\n    private getErrorInfo(error?: string): any {\n        if (error && this.control.errors) {\n            return this.control.errors[error];\n        }\n        return undefined;\n    }\n\n    private setValidityClasses() {\n        const add = this.control.valid ? this.validClass : this.invalidClass;\n        const remove = this.control.valid ? this.invalidClass : this.validClass;\n        if (remove) {\n            this.element.classList.remove(remove);\n        }\n        if (add) {\n            this.element.classList.add(add);\n        }\n        if (this.childSelector) {\n            const children = Array.from(this.element.querySelectorAll(this.childSelector));\n            children.forEach(element => {\n                if (remove) {\n                    element.classList.remove(remove);\n                }\n                if (add) {\n                    element.classList.add(add);\n                }\n            });\n        }\n    }\n\n    private removeValidityClasses() {\n        if (this.validClass) {\n            this.element.classList.remove(this.validClass);\n        }\n        if (this.invalidClass) {\n            this.element.classList.remove(this.invalidClass);\n        }\n        if (this.childSelector) {\n            const children = Array.from(this.element.querySelectorAll(this.childSelector));\n            children.forEach(element => {\n                if (this.validClass) {\n                    element.classList.remove(this.validClass);\n                }\n                if (this.invalidClass) {\n                    element.classList.remove(this.invalidClass);\n                }\n            });\n        }\n    }\n\n    /**\n     * Update the validity classes on the element depending on the validity state of the\n     * associated `FormControl`. If the control is invalid then the validation message component\n     * is loaded to display an error message.\n     */\n    ngDoCheck() {\n        if (!this.active) {\n            return;\n        }\n        if (this.valid === this.control.valid && this.dirty === this.control.dirty) {\n            const firstError = this.getFirstError();\n            const errorInfo = this.getErrorInfo(firstError);\n            if (firstError === this.error && errorInfo === this.errorInfo) {\n                return;\n            }\n            this.error = firstError;\n            this.errorInfo = errorInfo;\n        }\n        this.valid = this.control.valid;\n        this.dirty = this.control.dirty;\n        if (this.control.dirty) {\n            this.setValidityClasses();\n            if (this.control.valid) {\n                if (this.validationMessage) {\n                    this.validationMessage.componentRef.instance.text = \"\";\n                }\n            }\n            else {\n                if (!this.validationMessage) {\n                    this.validationMessage =\n                        this.loadComponentService.loadComponent({component: this.validationMessageComponent}, this.viewContainerRef);\n                }\n                const error = this.getFirstError();\n                this.validationMessage.componentRef.instance.text = this.getErrorText(error);\n                this.validationMessage.componentRef.instance.info = this.getErrorInfo(error);\n            }\n        }\n        else {\n            this.removeValidityClasses();\n            if (this.validationMessage) {\n                this.validationMessage.componentRef.instance.text = \"\";\n            }\n        }\n    }\n}\n","import {Pipe, ChangeDetectorRef} from \"@angular/core\";\nimport {ValidationErrors} from \"@angular/forms\";\nimport {AbstractIntlPipe, IntlService} from \"@sinequa/core/intl\";\nimport {ValidationService} from \"./validation.service\";\n\n/**\n * A pipe to display the first error in a `ValidationErrors` map.\n */\n@Pipe({name: \"sqValidationError\", pure: false})\nexport class ValidationErrorPipe extends AbstractIntlPipe {\n    constructor(\n        intlService: IntlService,\n        changeDetectorRef: ChangeDetectorRef,\n        protected validationService: ValidationService) {\n        super(intlService, changeDetectorRef);\n    }\n\n    updateValue(key: ValidationErrors, params: any): void {\n        super.updateValue(key, params);\n        const text = this.validationService.getFirstErrorText(key);\n        const info = this.validationService.getFirstErrorInfo(key);\n        this.value = text ? this.intlService.formatMessage(text, {values: info}) : undefined;\n    }\n}\n","import {Component, Input} from \"@angular/core\";\n\n/**\n * A default component to be used by the {@link ValidationDirective} directive to display\n * a validation error message using {@link MessagePipe}.\n */\n@Component({\n    selector: \"sq-validation-message\",\n    template: `\n        <div class=\"sq-validation-message\">{{text | sqMessage:{values: info} }}</div>\n    `\n})\nexport class ValidationMessageComponent {\n    /**\n     * The error message text passed to the `sqMessage` pipe.\n     */\n    @Input() text: string;\n    /**\n     * The entry for the validator in a `ValidationErrors` object. This is passed\n     * as the values to the `sqMessage` pipe.\n     */\n    @Input() info: any;\n}\n","const VALIDATION_MODULE_PROVIDERS = [];\n\nexport {VALIDATION_MODULE_PROVIDERS};\n","import {NgModule} from \"@angular/core\";\nimport {CommonModule} from \"@angular/common\";\n\nimport {BaseModule} from \"@sinequa/core/base\";\nimport {AppUtilsModule} from \"@sinequa/core/app-utils\";\nimport {IntlModule} from \"@sinequa/core/intl\";\nimport {LoadComponentModule} from \"@sinequa/core/load-component\";\n\nimport {ValidationDirective, VALIDATION_MESSAGE_COMPONENT} from \"./validation.directive\";\nimport {ValidationErrorPipe} from \"./validation-error.pipe\";\nimport {ValidationMessageComponent} from \"./validation-message.component\";\n\nimport {VALIDATION_MODULE_PROVIDERS} from \"./module.providers\";\n\n/**\n * This module contains facilities for working with Angular's form validation. It provides a\n * {@link ValidationService} that works with {@link IntlService} and {@link FormatService} to\n * support locale-sensitive validators.\n */\n@NgModule({\n    imports: [\n        CommonModule,\n        BaseModule,\n        AppUtilsModule,\n        IntlModule,\n        LoadComponentModule\n    ],\n    declarations: [\n        ValidationDirective, ValidationMessageComponent, ValidationErrorPipe,\n    ],\n    exports: [\n        ValidationDirective, ValidationMessageComponent, ValidationErrorPipe,\n    ],\n    providers: [\n        {provide: VALIDATION_MESSAGE_COMPONENT, useValue: ValidationMessageComponent},\n\n        ...VALIDATION_MODULE_PROVIDERS\n    ]\n})\nexport class ValidationModule {\n}\n","export default {\n    \"validation\": {\n        \"min\": \"The value must be at least {min}\",\n        \"max\": \"The value can be no more than {max}\",\n        \"required\": \"This field is required\",\n        \"requiredTrue\": \"This field must be set\",\n        \"email\": \"A valid email address is required\",\n        \"minLength\": \"The value must have at least {requiredLength, plural, one {# character} other {# characters}}\",\n        \"maxLength\": \"The value can have no more than {requiredLength, plural, one {# character} other {# characters}}\",\n        \"pattern\": \"The value is invalid\",\n        \"unique\": \"This field must be unique\",\n        \"integer\": \"The value must be an integer\",\n        \"number\": \"The value must be a number\",\n        \"date\": \"\",\n        \"range\": \"The first value must be less than or equal to the second\"\n    }\n};\n","export default {\n    \"validation\": {\n        \"min\": \"La valeur doit être supérieure ou égale à {min}\",\n        \"max\": \"La valeur ne peut pas être supérieure à {max}\",\n        \"required\": \"Ce champ est obligatoire\",\n        \"requiredTrue\": \"Ce champ doit être positionné\",\n        \"email\": \"Une adresse e-mail valide est exigée\",\n        \"minLength\": \"La valeur doit comporter au moins {requiredLength, plural, one {# caractère} autre que {# caractère}}\",\n        \"maxLength\": \"La valeur ne peut comporter plus de {requiredLength, plural, one {# caractère} autre que {# caractères}}\",\n        \"pattern\": \"La valeur est invalide\",\n        \"unique\": \"Ce champ doit être unique\",\n        \"integer\": \"La valeur doit être un entier\",\n        \"number\": \"La valeur doit être un nombre\",\n        \"date\": \"\",\n        \"range\": \"La première valeur doit être inférieure ou égale à la seconde\"\n    }\n};\n","export default {\n    \"validation\": {\n        \"min\": \"Der Mindestwert ist {min}\",\n        \"max\": \"Der Wert kann nicht größer sein als {max}\",\n        \"required\": \"Dies ist ein Mussfeld\",\n        \"requiredTrue\": \"Dieses Feld muss ausgefüllt werden\",\n        \"email\": \"Eine gültige E-Mail-Adresse ist einzutragen\",\n        \"minLength\": \"Die Mindestlänge des Wertes beträgt {requiredLength, plural, one {# Zeichen} other {# Zeichen}}\",\n        \"maxLength\": \"Der Wert darf nicht mehr als {requiredLength, plural, one {# Zeichen} other {# Zeichen}} haben\",\n        \"pattern\": \"Der Wert ist ungültig\",\n        \"unique\": \"Dieses Feld muss eindeutig sein\",\n        \"integer\": \"Der Wert muss eine ganze Zahl sein\",\n        \"number\": \"Der Wert muss eine Nummer sein\",\n        \"date\": \"\",\n        \"range\": \"Der erste Wert muss kleiner oder gleich dem zweiten Wert sein\"\n    }\n};\n","import {Utils} from \"@sinequa/core/base\";\nimport {enIntl, frIntl, deIntl} from \"@sinequa/core/intl\";\nimport _enValidation from \"./en\";\nimport _frValidation from \"./fr\";\nimport _deValidation from \"./de\";\n\nconst enValidation = Utils.merge({}, _enValidation, enIntl);\nconst frValidation = Utils.merge({}, _frValidation, frIntl);\nconst deValidation = Utils.merge({}, _deValidation, deIntl);\n\nexport { enValidation, frValidation, deValidation };\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["i0.ɵɵelementStart","i0.ɵɵtext","i0.ɵɵelementEnd","i0.ɵɵadvance","i0.ɵɵtextInterpolate"],"mappings":"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"}