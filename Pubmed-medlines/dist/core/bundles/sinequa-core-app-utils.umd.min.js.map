{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/core/app-utils/app-service-helpers.ts","../../projects/core/app-utils/query/expr-parser.ts","../../projects/core/app-utils/query/expr-builder.ts","../../projects/core/app-utils/query/query.ts","../../../projects/core/app-utils/format.service.ts","../../../projects/core/app-utils/app.service.ts","../../../projects/core/app-utils/audit.interceptor.ts","../../../projects/core/app-utils/module.providers.ts","../../../projects/core/app-utils/app-utils.module.ts"],"names":["Object","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","__spread","arguments","concat","AppServiceHelpers","isString","column","eType","eTypeModifier","isCsv","isTree","isEntity","isBoolean","isDate","isDouble","isInteger","isNumber","isScalar","isSortable","Expr","init","this","_field","undefined","_display","_displayObj","values","op1","opsInit","exprContext","field","display","addOperand","op2","and","near","start","valueInit","Utils","isUndefined","ExprParser","unescapeList","unescape","locations","operator","defineProperty","prototype","expr","isEmpty","parent","fromJson","_evaluationRegExps","operand","contextField","prepend","operands","isStructured","_c","_d","eqNC","unshift","makeExpr","text","allowEmptyValue","getIsStructuredField","resolveField","range","parseValue","value1","value2","location1","location2","expr1","expr2","appService","resolveColumnName","getColumn","disallowFulltext","eqNCN","isLeaf","mergedStructured","isStructuredField","positive","current","not","getValueAndLocation","trimStart","trimEnd","vl","first","last","includes","sepLen","sep","substr","indexOf","vls","valuesAndLocationsFromText","forEach","vl1","startsWith","endsWith","getOperatorText","findValue","ic","location","combine","expr3","normalizeField","fieldPartnamePrefix","shouldDisplayField","getOperatorString","escapeValue","escape","getValueString","sb","join","addFieldToString","added","_toString","withFields","inner","bracketed","toString","addDisplay","options","ctxt","_addValue","encodeHTML","asHTML","message","valueId","valueIndex","_value","testFloat","fromSysDateStr","isTrue","formatService","formatFieldValue","addValue","addOperator","addText","addFieldLabel","_this","displayObj","label","getLabel","getFields","index","addField","_toMessage","useDisplay","showNot","hideOuterNot","showField","toMessage","matchNode","context","resolveColumnAlias","expr1StructuredCount_1","expr1UnstructuredCount_1","expr2StructuredCount_1","expr2UnstructuredCount_1","values1Length","_e","found","_f","e_10","_g","find","filter","child1","e_12","_h","child2","_j","_k","child","action","some","callback","every","isPositive","fields","field1","getValues","column1","apply","getDataValue","data","defaultScope","split","fields_1","fields_1_1","getWildcardRegExp","regExp","evaluationRegExps","haveWildcards","escaping","value_1","value_1_1","ch","RegExp","compare","dataValue","equality","isArray","NaN","value_2","value_2_1","dataValue_1","e_20","dataValue_1_1","dataValue1","parser","toNumber","toDate","intlService","parseDate","getTime","test","evaluate","ret","ret1","tok","valuePos","valueLen","tokValue","tokValuePos","tokValueLen","ExprParserOperator","invalid","or","lPar","rPar","eof","expressions","operators","displays","op","prevOp","saveOp","String","search","isEscaped","values1","_i","_a","separator","currentStart","ch1","matchUntil","matchKeyword","keyword","sbCurrentValue","suffixCh","currentValue","keywordLen","nch","endChars","matchSimpleValue","getTerminators","allowRanges","canBeTokValue","canBeEmpty","allowEmptyValues","_getTokValue","pos","trim","getTokValue","ensureNearValue","defaultNearValue","ccquery","toInt","findDisplay","lastIndexOf","escapes","pos1","isValidFieldName","name","allowScopedFields","isValidScopedSimpleName","isValidSimpleName","isAllowedField","forcePartname","isPartname","$columnFieldsPattern","hasPatterns","isIncluded","$partnameFieldsPattern","readToken","nextValue","candidateFieldPos","fieldSpecified","infix","forceRange","displayStart","clear","parse","parseResult","peekField","peekDisplay","len","contextDisplay","err","parsetbl","reduce","shift","canBeMergeTarget","mergeExpr","e1","e2","source","target","eq","pop","ExprBuilder","formatField","makeBooleanExpr","toSqlValue","makeNumericalExpr","makeListExpr","map","v","makeRangeExpr","from","to","makeRegexpExpr","makeRefineExpr","makeAndExpr","concatWithOperator","makeOrExpr","makeNotExpr","concatOrExpr","exprs","concatAndExpr","makeFieldExpr","items","combineWithAnd","makeAggregationExpr","aggregation","valuesAreExpressions","_items","asValueItems","$path","factory","ɵfac","providedIn","advancedFacetPrefix","Query","copy","query","findSelect","addSelect","facet","pushSelect","expression","select","popSelect","removeSelect","indexOrFacet","all","_select","splice","replaceSelect","findSelectIndex","ordinal","facetOrdinal","facetIndex","fromEnd","facetSelectIndex","lastSelect","addOpen","open","clearObject","toStandard","advancedSelect","copyStandard","toAdvanced","withText","property","hasOwnProperty","notAdvancedSelect","copyAdvanced","hasAdvanced","jquery","extend","toJsonForQueryString","merge","a","toJson","hash","obj","mergeAndSort","page","pageSize","str","sha512","FormatService","bigNumberFormatter","format","moneyFormatter","replace","isValueItem","valueItem","isObject","getValueAndDisplay","formatLanguage","formatMessage","toLowerCase","formatMemorySize","size","kiloBytes","megaBytes","gigaBytes","teraBytes","petaBytes","messageKey","params","Math","abs","formatMoney","currency","val","formatValue","formatter","toSysDateStr","getMessage","formatText","formatNumber","date","time","formatDate","formatTime","joinValue_1","_v","transformValue","transforms","transforms_1","transforms_1_1","transform","toUpperCase","toUpperFirst","toLowerFirst","toStartCase","toKebabCase","toSnakeCase","toCamelCase","formattedValue","parseMemorySize","_default","toSize","formatRaw","i0","ɵɵinject","i1","IntlService","AppService","startConfig","appWebService","_events","Subject","appName","console","toEngineType","type","toEngineTypeModifierSimple","c","toEngineTypeModifier","typeModifier","etm","typeModifier_1","typeModifier_1_1","makeColumn","aliases","ngOnDestroy","complete","app","origin","initDefaultQuery","defaultQueryName","queryNames","_defaultCCQuery","getField","queries","warn","setApp","verifyServerApiVersionCompatibility","cclabels","getWebService","labels","ccautocomplete","autocomplete","makeMaps","suggestQueries","apiVersion","MINIMUM_COMPATIBLE_SERVER_API_VERSION","get","pipe","initFromApp","refresh","auditEvents","observable","versionId","subscribe","response","upToDate","clearMaps","indexIsNormal","ccindex","indexType","getIndexForQuery","indexes","searchIndexes","_","getIndex","_makeColumnMapForIndex","columnMap","columns","keys","columnName","e_3","alias","_makeColumnMapForQuery","columnsInfo","columnInfo","extraColumns","e_5","labelPlural","description","columnsByQuery","columnsByIndex","fieldsByQuery","queryName","PatternMatcher","includedPattern","setText","columnFieldsIncluded","excludedPattern","columnFieldsExcluded","partnameFieldsIncluded","partnameFieldsExcluded","indexName","ccindex1","globalFields","Map","_l","set","_m","_o","queryFields","columns1","defaultCCQuery","_p","_q","Array","webServices","getList","lists","_ccquery","previous","getCCQuery","setCCQuery","getCCAggregation","aggregations","columnAliases","firstIndex","indexes_1","indexes_1_1","getColumnDefaultAlias","getColumnName","getColumnAlias","parseExpr","escapeFieldValue","getSingularLabel","getPluralLabel","updateUrlForCors","url","corsActive","isUrlAbsolute","addUrl","applicationPath","id","documentlanguages","databasealias","globalrelevance","matchingpartnames","matchlocations","matchlocationsperpartname","extracts","extractsperpartname","extractslocations","documentweight","groupcount","accesslists","START_CONFIG","i1$1","AppWebService","AuditInterceptor","shouldIntercept","apiPath","isJsonable","isArrayBuffer","isBlob","HttpParams","ensureAuditRecord","auditEvents1","auditRecord","mlAuditEvents","addSessionId","sessionid","getSessionId","event","detail","isSessionStale","guid","sessionstart","Date","updateAuditRecord","intercept","request","body","$auditRecord","handle","APP_UTILS_MODULE_PROVIDERS","AppUtilsModule","providers","imports","BaseModule","IntlModule","WebServicesModule"],"mappings":";;;;;;;;;;;;;;oFAyG6BA,OAAOC,gBAYpBC,EAASC,GACrB,IAAIC,EAAsB,mBAAXC,QAAyBA,OAAOC,SAAUC,EAAIH,GAAKD,EAAEC,GAAII,EAAI,EAC5E,GAAID,EAAG,OAAOA,EAAEE,KAAKN,GACrB,GAAIA,GAAyB,iBAAbA,EAAEO,OAAqB,MAAO,CAC1CC,KAAM,WAEF,OADIR,GAAKK,GAAKL,EAAEO,SAAQP,OAAI,GACrB,CAAES,MAAOT,GAAKA,EAAEK,KAAMK,MAAOV,KAG5C,MAAM,IAAIW,UAAUV,EAAI,0BAA4B,4CAGxCW,EAAOZ,EAAGa,GACtB,IAAIT,EAAsB,mBAAXF,QAAyBF,EAAEE,OAAOC,UACjD,IAAKC,EAAG,OAAOJ,EACf,IAAmBc,EAAYC,EAA3BV,EAAID,EAAEE,KAAKN,GAAOgB,EAAK,GAC3B,IACI,WAAc,IAANH,GAAgBA,KAAM,MAAQC,EAAIT,EAAEG,QAAQE,MAAMM,EAAGC,KAAKH,EAAEL,OAExE,MAAOS,GAASH,EAAI,CAAEG,MAAOA,WAEzB,IACQJ,IAAMA,EAAEJ,OAASN,EAAIC,EAAU,SAAID,EAAEE,KAAKD,WAExC,GAAIU,EAAG,MAAMA,EAAEG,OAE7B,OAAOF,WAGKG,IACZ,IAAK,IAAIH,EAAK,GAAIX,EAAI,EAAGA,EAAIe,UAAUb,OAAQF,IAC3CW,EAAKA,EAAGK,OAAOT,EAAOQ,UAAUf,KACpC,OAAOW,EA8CcnB,OAAOC,OC3LhC,IAAAwB,EAAA,WAAA,SAAAA,YACWA,EAAAC,SAAP,SAAgBC,GACZ,QAAKA,IAGW,KAAZA,EAAOC,OAGK,KAAZD,EAAOC,OAAiD,UAAA,QAApBD,EAAOE,iBAM5CJ,EAAAK,MAAP,SAAaH,GACT,QAAKA,IAGW,KAAZA,EAAOC,OAAiD,UAAA,QAApBD,EAAOE,iBAM5CJ,EAAAM,OAAP,SAAcJ,GACV,QAAKA,IAGW,KAAZA,EAAOC,OAAiD,SAAA,OAApBD,EAAOE,iBAM5CJ,EAAAO,SAAP,SAAgBL,GACZ,QAAKA,IAGW,KAAZA,EAAOC,OAAiG,OAAhD,KAApBD,EAAOE,iBAM5CJ,EAAAQ,UAAP,SAAiBN,GACb,QAAKA,GAGW,IAAZA,EAAOC,OAMRH,EAAAS,OAAP,SAAcP,GACV,QAAKA,IAGW,IAAZA,EAAOC,OAAyC,IAAZD,EAAOC,OAA6C,IAAZD,EAAOC,QAMpFH,EAAAU,SAAP,SAAgBR,GACZ,QAAKA,IAGW,IAAZA,EAAOC,OAA2C,IAAZD,EAAOC,QAM9CH,EAAAW,UAAP,SAAiBT,GACb,QAAKA,IAGW,IAAZA,EAAOC,OAA4C,IAAZD,EAAOC,QAM/CH,EAAAY,SAAP,SAAgBV,GACZ,OAAOF,EAAkBW,UAAUT,IAAWF,EAAkBU,SAASR,IAGtEF,EAAAa,SAAP,SAAgBX,GACZ,OAAOF,EAAkBY,SAASV,IAAWF,EAAkBS,OAAOP,IAAWF,EAAkBQ,UAAUN,IAG1GF,EAAAc,WAAP,SAAkBZ,GACd,OAAOF,EAAkBC,SAASC,IAAWF,EAAkBa,SAASX,IACnEF,EAAkBK,MAAMH,MAAaA,GAAgC,OAAA,KAApBA,EAAOE,kBA9FrE,gBCgWI,SAAAW,EAAYC,GACR,GArKIC,KAAAC,YAA6BC,EAwB7BF,KAAAG,cAA+BD,EAC/BF,KAAAI,iBAA8DF,EA2D/DF,KAAAK,YAA+BH,EAiFHH,EAAMO,IAiBhC,CACD,IAAMC,EAAmCR,EACzCC,KAAKQ,YAAcD,EAAQC,YAC3BR,KAAKS,MAAQF,EAAQE,MACrBT,KAAKU,QAAUH,EAAQG,QACvBV,KAAKW,WAAWJ,EAAQD,KACxBN,KAAKW,WAAWJ,EAAQK,KACxBZ,KAAKa,IAAMN,EAAQM,IACnBb,KAAKc,MAAQ,EACbd,KAAKe,OAAS,EACdf,KAAKhC,OAAS,MA3BwB,CACtC,IAAMgD,EAAwDjB,EAC9DC,KAAKQ,YAAcQ,EAAUR,YACxBS,EAAAA,MAAMC,YAAYF,EAAU9C,OAGvB+C,EAAAA,MAAMC,YAAYF,EAAUX,UAClCL,KAAKK,OAASc,EAAWC,aAAaJ,EAAUX,SAHhDL,KAAK9B,MAAQiD,EAAWE,SAASL,EAAU9C,OAK/C8B,KAAKsB,UAAYN,EAAUM,UAC3BtB,KAAKS,MAAQO,EAAUP,MACvBT,KAAKU,QAAUM,EAAUN,QACzBV,KAAKuB,SAAYN,EAAAA,MAAMC,YAAYF,EAAUO,UAA8B,EAAlBP,EAAUO,SACnEvB,KAAKc,MAAQ,EACbd,KAAKe,OAAS,EACdf,KAAKhC,OAAS,UA9KtBV,OAAAkE,eAAW1B,EAAA2B,UAAA,QAAK,KAAhB,WAEI,IADA,IAAIC,EAAa1B,KACV0B,GAAM,CACT,IAAKT,EAAAA,MAAMU,QAAQD,EAAKzB,QACpB,OAAOyB,EAAKzB,OAEhByB,EAAOA,EAAKE,aAQpB,SAAiB1D,GACb8B,KAAKC,OAAS/B,mCAUlBZ,OAAAkE,eAAW1B,EAAA2B,UAAA,UAAO,KAAlB,WAEI,IADA,IAAIC,EAAa1B,KACV0B,GAAM,CACT,IAAKT,EAAAA,MAAMU,QAAQD,EAAKvB,UACpB,OAAOuB,EAAKvB,SAEhBuB,EAAOA,EAAKE,aASpB,SAAmB1D,GAEf,GADA8B,KAAKG,SAAWjC,EACX8B,KAAKG,SAIN,GAAyB,MAArBH,KAAKG,SAAS,IAA0D,MAA5CH,KAAKG,SAASH,KAAKG,SAASnC,OAAS,GACjE,IACIgC,KAAKI,YAAca,EAAAA,MAAMY,SAAS7B,KAAKG,UAE3C,MAAO3B,GACHwB,KAAKI,iBAAcF,OAIvBF,KAAKI,iBAAcF,OAZvBF,KAAKI,iBAAcF,mCAqB3B5C,OAAAkE,eAAW1B,EAAA2B,UAAA,aAAU,KAArB,WAEI,IADA,IAAIC,EAAa1B,KACV0B,GAAM,CACT,GAAIA,EAAKtB,YACL,OAAOsB,EAAKtB,YAEhBsB,EAAOA,EAAKE,yCAiBpBtE,OAAAkE,eAAW1B,EAAA2B,UAAA,QAAK,KAAhB,WACI,GAAKzB,KAAKK,QAAiC,IAAvBL,KAAKK,OAAOrC,OAGhC,OAAOgC,KAAKK,OAAO,QAMvB,SAAiBnC,QACCgC,IAAVhC,EACA8B,KAAKK,YAASH,GAGTF,KAAKK,SACNL,KAAKK,OAAS,IAElBL,KAAKK,OAAO,GAAKnC,EACjB8B,KAAKK,OAAOrC,OAAS,oCA6C7BV,OAAAkE,eAAY1B,EAAA2B,UAAA,oBAAiB,KAA7B,WAII,OAHKzB,KAAK8B,qBACN9B,KAAK8B,mBAAqB,IAEvB9B,KAAK8B,oDA0CThC,EAAA2B,UAAAd,WAAA,SAAWoB,EAAeC,EAAuBC,WAOpD,QAPoD,IAAAA,IAAAA,GAAA,GAChDhB,EAAAA,MAAMC,YAAYc,KAClBA,EAAehC,KAAKS,OAEnBT,KAAKkC,WACNlC,KAAKkC,SAAW,KAEfjB,EAAAA,MAAMU,QAAQ3B,KAAKS,QAAUQ,EAAAA,MAAMU,QAAQI,EAAQtB,SAAWsB,EAAQI,cACnElB,EAAAA,MAAMU,QAAQK,GAAe,KAG7B,IAAmB,IAAAI,EAAA5E,EAAAwC,KAAKkC,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAA7B,IAAMyD,EAAIW,EAAAnE,MACP+C,EAAAA,MAAMU,QAAQD,EAAKzB,UACnByB,EAAKzB,OAASD,KAAKS,yGAG3BT,KAAKS,WAAQP,EAGhBe,EAAAA,MAAMqB,KAAKtC,KAAKS,OAAS,GAAIsB,EAAQtB,OAAS,IAI/CsB,EAAQ9B,YAASC,EAHjB6B,EAAQ9B,OAAS8B,EAAQtB,MAKxBQ,EAAAA,MAAMU,QAAQ3B,KAAKU,WACpBqB,EAAQ5B,cAAWD,GAEnB+B,EACAjC,KAAKkC,SAASK,QAAQR,GAGtB/B,KAAKkC,SAASxD,KAAKqD,GAEvBA,EAAQH,OAAS5B,MAMrB1C,OAAAkE,eAAW1B,EAAA2B,UAAA,SAAM,KAAjB,WAEI,QAASzB,KAAK9B,uCAYJ4B,EAAA0C,SAAP,SAAgBhC,EAA0BiC,EAAchC,EAAeC,EAAiBgC,GAC3F,IAAK5C,EAAK6C,qBAAqBnC,EAAaV,EAAK8C,aAAapC,EAAaC,IACvE,OAAO,IAAIX,EAAK,CACZU,YAAaA,EACbtC,MAAOuE,EACPhC,MAAOA,EACPC,QAASA,IAIjB,IAAML,EAAqC,CAACnC,WAAOgC,GAC7CoB,EAA8C,CAACpD,WAAOgC,GACtDqB,EAA+B,CAACrD,MAAK,GACrC2E,EAAyB,CAAC3E,MAAK,GAErC,GADA4B,EAAKgD,WAAWtC,EAAaiC,EAAMhC,EAAOiC,EAAiBrC,EAAQiB,EAAWC,EAAUsB,GACzE,IAAXA,EAAM3E,OAA4BmC,EAAOnC,OAASoD,EAAUpD,MAAO,CACnE,IAAM6E,EAAS1C,EAAOnC,MAAM,GACtB8E,EAAS3C,EAAOnC,MAAM,GACtB+E,EAAY3B,EAAUpD,MAAM,GAC5BgF,EAAY5B,EAAUpD,MAAM,GAClC,GAAe,IAAX2E,EAAM3E,QAA+B+C,EAAAA,MAAMqB,KAAKS,EAAQ,OAAS9B,EAAAA,MAAMqB,KAAKU,EAAQ,KACpF,OAAO,IAAIlD,EAAK,CACZU,YAAaA,EACbH,OAAQA,EAAOnC,MACfoD,UAAWA,EAAUpD,MACrBuC,MAAOA,EACPC,QAASA,EACTa,SAAQ,KAGhB,IAAM4B,EAASlC,EAAAA,MAAMqB,KAAKS,EAAQ,KAO7B,KAPoC,IAAIjD,EAAK,CAC9CU,YAAaA,EACbtC,MAAO6E,EACPzB,UAAW,CAAC2B,GACZxC,MAAOA,EACPC,QAASA,EACTa,SAAqB,IAAXsB,EAAM3E,OAAwC,IAAX2E,EAAM3E,MAAK,EAAA,IAEtDkF,EAASnC,EAAAA,MAAMqB,KAAKU,EAAQ,UAO7B9C,EAPoC,IAAIJ,EAAK,CAC9CU,YAAaA,EACbtC,MAAO8E,EACP1B,UAAW,CAAC4B,GACZzC,MAAOA,EACPC,QAASA,EACTa,SAAqB,IAAXsB,EAAM3E,OAAyC,IAAX2E,EAAM3E,MAAK,EAAA,IAE7D,IAAKiF,IAAUC,EACX,OAEJ,OAAQD,GAAWC,EACZ,IAAItD,EAAK,CACZU,YAAaA,EACbF,IAAK6C,EACLtC,KAAK,EACLD,IAAKwC,EACL1C,QAASA,IANuByC,GAAgBC,EASxD,OAAO,IAAItD,EAAK,CACZU,YAAaA,EACbH,OAAQA,EAAOnC,MACfoD,UAAWA,EAAUpD,MACrBuC,MAAOA,EACPC,QAASA,EACTa,SAAUA,EAASrD,SAIZ4B,EAAA8C,aAAP,SAAoBpC,EAA0BC,GAClD,OAAIQ,EAAAA,MAAMjC,SAASyB,GACRD,EAAY6C,WAAWC,kBAAkB7C,GAE7C,IAGIX,EAAAyD,UAAP,SAAiB/C,EAA0BC,GAC/C,OAAOD,EAAY6C,WAAWE,UAAU9C,IAM5CnD,OAAAkE,eAAI1B,EAAA2B,UAAA,SAAM,KAAV,WACI,OAAO3B,EAAKyD,UAAUvD,KAAKQ,YAAaR,KAAKS,wCAGlCX,EAAA6C,qBAAP,SAA4BnC,EAA0BC,GAC1D,QAAKA,MAGDD,EAAYgD,kBAIK,MAAb/C,EAAM,OAGNQ,EAAAA,MAAMwC,MAAMhD,EAAO,SAAU,cAGxBX,EAAKyD,UAAU/C,EAAaC,MAO7CnD,OAAAkE,eAAI1B,EAAA2B,UAAA,oBAAiB,KAArB,WACI,QAAKzB,KAAK0D,QAGH5D,EAAK6C,qBAAqB3C,KAAKQ,YAAaR,KAAKS,wCAM5DnD,OAAAkE,eAAW1B,EAAA2B,UAAA,eAAY,KAAvB,mBACI,GAAIzB,KAAK2D,iBACL,OAAO,EAEX,GAAI3D,KAAK0D,OACL,OAAO1D,KAAK4D,kBAEhB,IAAK5D,KAAKkC,SACN,OAAO,MAEX,IAAsB,IAAAE,EAAA5E,EAAAwC,KAAKkC,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CACjC,IADcoE,EAAAnE,MACDiE,aACT,OAAO,oGAGf,OAAO,mCAMX7E,OAAAkE,eAAW1B,EAAA2B,UAAA,aAAU,KAArB,WAGI,IAFA,IAAIoC,GAAW,EACXC,EAAgB9D,KACF,MAAX8D,GACHD,EAAWA,IAAaC,EAAQC,IAChCD,EAAUA,EAAQlC,OAEtB,OAAOiC,mCAOJ/D,EAAAkE,oBAAP,SAA2BvB,GACvB,IAAI1B,EAAQ,EACR/C,EAASyE,EAAKzE,OACZ+E,EAAS9B,EAAAA,MAAMgD,UAAUxB,GAC/B1B,GAAS/C,EAAS+E,EAAO/E,OACzBA,GAAUA,EAAS+E,EAAO/E,OAC1B,IAAMgF,EAAS/B,EAAAA,MAAMiD,QAAQnB,GAE7B,MAAO,CACH7E,MAAO8E,EACPjC,MAAOA,EACP/C,OAJJA,GAAUA,EAASgF,EAAOhF,SAQf8B,EAAAgD,WAAP,SAAkBtC,EAA0BiC,EAAchC,EAAeiC,EAA0BrC,EAAoCiB,EAA6CC,EAA8BsB,GACtN,IAAI5B,EAAAA,MAAMU,QAAQc,IAAUC,EAA5B,CAGA,IAEIyB,EAFEC,EAAQ3B,EAAK,GACb4B,EAAO5B,EAAKA,EAAKzE,OAAS,GAEhC,GAAI,KAAKsG,SAASF,IAAU,KAAKE,SAASD,GAAO,CAE7C,IAAIE,EAAS,EACTC,GAFJ/B,EAAOA,EAAKgC,OAAO,EAAGhC,EAAKzE,OAAS,IAErB0G,QAAQ,QAKvB,IAJa,IAATF,IACAD,EAAS,EACTC,EAAM/B,EAAKiC,QAAQ,QAEV,IAATF,EAAY,CACZ,IAAMG,EAAMxD,EAAWyD,2BAA2BnC,EAAM,KAQxD,OAPApC,EAAOnC,MAAQ,GACfoD,EAAUpD,MAAQ,GAClByG,EAAIE,SAAQ,SAAAC,GACRzE,EAAOnC,MAAOQ,KAAKoG,EAAI5G,OACvBoD,EAAUpD,MAAOQ,KAAK,CAACqC,MAAO,EAAI+D,EAAI/D,MAAO/C,OAAQ8G,EAAI9G,iBAE7DuD,EAASrD,MAAK,IAelB,OAZAiG,EAAKrE,EAAKkE,oBAAoBvB,EAAKgC,OAAO,EAAGD,IAC7CnE,EAAOnC,MAAQ,CAACiG,EAAGjG,OACnBoD,EAAUpD,MAAQ,CAAC,CAAC6C,MAAO,EAAIoD,EAAGpD,MAAO/C,OAAQmG,EAAGnG,SACpDmG,EAAKrE,EAAKkE,oBAAoBvB,EAAKgC,OAAOD,EAAMD,IAChDlE,EAAOnC,MAAMQ,KAAKyF,EAAGjG,OACrBoD,EAAUpD,MAAMQ,KAAK,CAACqC,MAAO,EAAIyD,EAAMD,EAASJ,EAAGpD,MAAO/C,OAAQmG,EAAGnG,cAEjE6E,EAAM3E,MADI,MAAVkG,EACuB,MAATC,EAAY,EAAA,EAGH,MAATA,EAAY,EAAA,GAIlCF,EAAK,CACDjG,MAAOuE,EACP1B,MAAO,EACP/C,OAAQyE,EAAKzE,QAEbyE,EAAKsC,WAAW,MAChBxD,EAASrD,MAAK,GACdiG,EAAKrE,EAAKkE,oBAAoBvB,EAAKgC,OAAO,KACvC1D,OAAS,GAEP0B,EAAKsC,WAAW,OACrBxD,EAASrD,MAAK,GACdiG,EAAKrE,EAAKkE,oBAAoBvB,EAAKgC,OAAO,KACvC1D,OAAS,GAEP0B,EAAKsC,WAAW,MACrBxD,EAASrD,MAAK,GACdiG,EAAKrE,EAAKkE,oBAAoBvB,EAAKgC,OAAO,KACvC1D,OAAS,GAEP0B,EAAKsC,WAAW,OACrBxD,EAASrD,MAAK,GACdiG,EAAKrE,EAAKkE,oBAAoBvB,EAAKgC,OAAO,KACvC1D,OAAS,GAEP0B,EAAKsC,WAAW,OACrBxD,EAASrD,MAAK,GACdiG,EAAKrE,EAAKkE,oBAAoBvB,EAAKgC,OAAO,KACvC1D,OAAS,GAEP0B,EAAKsC,WAAW,MACrBxD,EAASrD,MAAK,GACdiG,EAAKrE,EAAKkE,oBAAoBvB,EAAKgC,OAAO,KACvC1D,OAAS,GAEP0B,EAAKsC,WAAW,MACrBxD,EAASrD,MAAK,GACdiG,EAAKrE,EAAKkE,oBAAoBvB,EAAKgC,OAAO,KACvC1D,OAAS,GAEP0B,EAAKzE,OAAS,GAAKyE,EAAKsC,WAAW,MAAQtC,EAAKuC,SAAS,OAC9DzD,EAASrD,MAAK,EACdiG,EAAGjG,MAAQuE,EAAKgC,OAAO,EAAGhC,EAAKzE,OAAS,GACxCmG,EAAGpD,MAAQ,EACXoD,EAAGnG,OAASmG,EAAGjG,MAAMF,QAErByE,EAAKsC,WAAW,MAAStC,EAAKuC,SAAS,OACvCb,EAAGjG,MAAQuE,EAAKgC,OAAO,EAAGhC,EAAKzE,OAAS,GACxCmG,EAAGpD,MAAQ,EACXoD,EAAGnG,OAASmG,EAAGjG,MAAMF,QAEzBqC,EAAOnC,MAAQ,CAACiG,EAAGjG,OACnBoD,EAAUpD,MAAQ,CAAC,CAAC6C,MAAOoD,EAAGpD,MAAO/C,OAAQmG,EAAGnG,WAGrC8B,EAAAmF,gBAAP,SAAuB1D,GAC3B,OAAQA,GACJ,KAAA,EAAsB,MAAO,IAC7B,KAAA,EAAsB,MAAO,IAC7B,KAAA,EAAuB,MAAO,KAC9B,KAAA,EAAsB,MAAO,IAC7B,KAAA,EAAuB,MAAO,KAC9B,KAAA,EAAuB,MAAO,KAC9B,KAAA,EAAyB,MAAO,SAChC,KAAA,EAAwB,MAAO,OAC/B,KAAA,EAA4B,MAAO,WACnC,KAAA,GAAsB,MAAO,KAC7B,KAAA,GAA2B,MAAO,UAClC,QAAS,MAAO,MASxBzB,EAAA2B,UAAAyD,UAAA,SAAUnE,WACN,GAAIf,KAAK0D,QACL,GAAI3C,GAASf,KAAKe,OAASA,GAASf,KAAKe,MAAQf,KAAKhC,OAAQ,CAC1D,IAAKgC,KAAKmC,aACN,MAAO,CAEHjE,MAAO8B,KAAK9B,MAEZuC,MAAOT,KAAKS,MACZM,MAAOf,KAAKe,MACZ/C,OAAQgC,KAAKhC,QAGhB,GAAMgC,KAAKsB,WAAatB,KAAKK,QAAUL,KAAKK,OAAOrC,SAAWgC,KAAKsB,UAAUtD,OAC9E,IAAK,IAAIF,EAAI,EAAGqH,EAAKnF,KAAKK,OAAOrC,OAAQF,EAAIqH,EAAIrH,IAAK,CAClD,IAAMI,EAAQ8B,KAAKK,OAAOvC,GACpBsH,EAAWpF,KAAKsB,UAAUxD,GAChC,GAAIiD,GAASf,KAAKe,MAAQqE,EAASrE,OAASA,GAASf,KAAKe,MAAQqE,EAASrE,MAAQqE,EAASpH,OACxF,MAAO,CACHE,MAAKA,EAELuC,MAAOT,KAAKS,MACZM,MAAOf,KAAKe,MAAQqE,EAASrE,MAC7B/C,OAAQoH,EAASpH,eAOpC,GAAMgC,KAAKkC,aACZ,IAAmB,IAAAE,EAAA5E,EAAAwC,KAAKkC,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAE9B,GADMC,EADKmE,EAAAnE,MACQgH,UAAUnE,GAEzB,OAAO7C,sGAahB4B,EAAAuF,QAAP,SAAelC,EAAaC,WACxB,IAAKD,EACD,OAAOC,EAEX,IAAKA,EACD,OAAOD,EAEX,IAAKA,EAAMO,QAAUP,EAAMtC,MAAQsC,EAAMY,IAAK,CAC1C,GAAIZ,EAAMO,SAAWN,EAAMvC,KAAOuC,EAAMW,IACpCZ,EAAMxC,WAAWyC,YAGjB,IAAoB,IAAAhB,EAAA5E,EAAA4F,EAAMlB,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAA/B,IAAMqH,EAAKjD,EAAAnE,MACZiF,EAAMxC,WAAW2E,qGAGzB,OAAOnC,EAEX,OAAO,IAAIrD,EAAK,CACZU,YAAa2C,EAAM3C,YACnBF,IAAK6C,EACLtC,KAAK,EACLD,IAAKwC,KAILtD,EAAA2B,UAAA8D,eAAA,SAAe9E,GACnB,OAAIA,GAASA,EAAM,KAAOU,EAAWqE,oBAC1B/E,EAAMgE,OAAO,GAEjBhE,GAGHX,EAAA2B,UAAAgE,mBAAA,WACJ,OAAKzF,KAAKS,QAAUT,KAAK4B,WAGhB5B,KAAKS,OAAWT,KAAK4B,QAAWX,EAAAA,MAAMqB,KAAKtC,KAAKS,MAAOT,KAAK4B,OAAOnB,OAAS,MAGjFX,EAAA2B,UAAAiE,kBAAA,WACJ,OAAiB,IAAb1F,KAAKuB,UAA+C,IAAbvB,KAAKuB,SACrC,GAEJzB,EAAKmF,gBAAgBjF,KAAKuB,WAG7BzB,EAAA2B,UAAAkE,YAAA,SAAYzH,GAChB,OAAMA,GAAW8B,KAAKf,SAAWF,EAAkBC,SAASgB,KAAKf,SAAWF,EAAkBK,MAAMY,KAAKf,SAC9FkC,EAAWyE,OAAO1H,GAEtBA,GAAS,IAGZ4B,EAAA2B,UAAAoE,eAAA,mBACJ,GAAiB,KAAb7F,KAAKuB,UAAqCvB,KAAKK,QAAiC,IAAvBL,KAAKK,OAAOrC,OACrE,MAAO,IAAIgC,KAAK2F,YAAY3F,KAAKK,OAAO,IAAG,KAAKL,KAAK2F,YAAY3F,KAAKK,OAAO,IAAG,IAEpF,GAAIL,KAAKK,QAAUL,KAAKK,OAAOrC,OAAS,EAAG,CACvC,IAAM8H,EAAe,OACrB,IAAoB,IAAA1D,EAAA5E,EAAAwC,KAAKK,QAAMgC,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAA5B,IAAMC,EAAKmE,EAAAnE,MACR4H,EAAG9H,OAAS,GACZ8H,EAAGpH,KAAK,MAEZoH,EAAGpH,KAAKsB,KAAK2F,YAAYzH,sGAI7B,OAFA4H,EAAGvD,QAAQ,KACXuD,EAAGpH,KAAK,KACDoH,EAAGC,KAAK,IAEnB,OAAO/F,KAAK2F,YAAY3F,KAAK9B,QAGzB4B,EAAA2B,UAAAuE,iBAAA,SAAiBF,GACrB,IAAIG,GAAQ,EAYZ,OAXIjG,KAAKyF,uBACLK,EAAGpH,KAAKsB,KAAKuF,eAAevF,KAAKS,QAAU,QAC3CwF,GAAQ,GAERjG,KAAKU,UACLoF,EAAGpH,KAAKyC,EAAWyE,OAAO5F,KAAKU,UAC/BuF,GAAQ,GAERA,GACAH,EAAGpH,KAAK,KAELuH,GAGHnG,EAAA2B,UAAAyE,UAAA,SAAUC,EAAqBC,WAC7BN,EAAe,GACrB,GAAI9F,KAAK0D,OACD1D,KAAK+D,KACL+B,EAAGpH,KAAK,QAERyH,GACAnG,KAAKgG,iBAAiBF,GAE1BA,EAAGpH,KAAKsB,KAAK0F,qBACbI,EAAGpH,KAAKsB,KAAK6F,sBAEZ,CACD,IAAK7F,KAAKkC,SACN,MAAO,GAEPlC,KAAK+D,KACL+B,EAAGpH,KAAK,QAEZ,IAAI2H,EAAYD,EACZpG,KAAKgG,iBAAiBF,KACtBO,GAAY,GAEZA,GACAP,EAAGpH,KAAK,KAEZ,IAAI0F,GAAQ,MACZ,IAAsB,IAAAhC,EAAA5E,EAAAwC,KAAKkC,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAAhC,IAAM8D,EAAOM,EAAAnE,MACTkG,IACGpE,KAAKa,IACLiF,EAAGpH,KAAK,SAGRoH,EAAGpH,KAAK,SAGhB0F,GAAQ,EACR0B,EAAGpH,KAAKqD,EAAQmE,UAAUC,GAAY,sGAEtCE,GACAP,EAAGpH,KAAK,KAGhB,OAAOoH,EAAGC,KAAK,KAQnBjG,EAAA2B,UAAA6E,SAAA,SAASH,GACL,YADK,IAAAA,IAAAA,GAAA,GACEnG,KAAKkG,UAAUC,GAAY,IAG9BrG,EAAA2B,UAAA8E,WAAA,SAAWC,EAA6BC,EAAuB/F,GACnEV,KAAK0G,UAAUF,EAASC,EAAMzG,KAAK9B,OAAS,GAAIwC,IAG5CZ,EAAA2B,UAAAkF,WAAA,SAAWlE,EAAc+D,GAC7B,OAAIA,GAAWA,EAAQI,OACZ3F,EAAAA,MAAM0F,WAAWlE,GAGjBA,GAIP3C,EAAA2B,UAAAiF,UAAA,SAAUF,EAA6BC,EAAuBvI,EAAewC,GAC7E8F,EAAQI,QACRH,EAAKI,QAAQnI,KAAK,2BAEtB,IAGIyB,EAHElB,EAASe,KAAKQ,YAAY6C,WAAWE,UAAUvD,KAAKS,OACpDqG,EAAU,QAAQL,EAAKM,aACzBC,EAAqB9I,EAErBwC,IACAP,EAAWH,KAAK2G,WAAWxF,EAAWE,SAASX,GAAU8F,IAEzDvH,GAAUF,EAAkBY,SAASV,IAAWgC,EAAAA,MAAMgG,UAAU/I,GAChE8I,GAAU9I,EAELe,GAAUF,EAAkBS,OAAOP,GACxC+H,EAAS/F,EAAAA,MAAMiG,eAAehJ,IAAUA,EAEnCe,GAAUF,EAAkBQ,UAAUN,GAC3C+H,EAAS/F,EAAAA,MAAMkG,OAAOjJ,GAEjB+C,EAAAA,MAAMjC,SAASgI,KACpBA,EAAShH,KAAK2G,WAAWK,EAAQR,IAErCC,EAAKI,QAAQnI,KAAK,IAAIoI,EAAO,KAC7BL,EAAKpG,OAAOyG,GAAW7H,EACjBe,KAAKQ,YAAY4G,cAAcC,iBAAiB,CAACnJ,MAAO8I,EAAQtG,QAASP,GAAWlB,GACpFkB,GAAY6G,EACdR,EAAQI,QACRH,EAAKI,QAAQnI,KAAK,YAIlBoB,EAAA2B,UAAA6F,SAAA,SAASd,EAA6BC,WAC1C,GAAIzG,KAAKK,OACL,GAAiB,KAAbL,KAAKuB,UAA4D,IAAvBvB,KAAKK,OAAOrC,OACtDgC,KAAK0G,UAAUF,EAASC,EAAMzG,KAAKK,OAAO,IAC1CoG,EAAKI,QAAQnI,KAAK,KAClBsB,KAAKuH,YAAY,MAAOf,EAASC,GACjCA,EAAKI,QAAQnI,KAAK,KAClBsB,KAAK0G,UAAUF,EAASC,EAAMzG,KAAKK,OAAO,SAEzC,GAAIL,KAAKK,OAAOrC,OAAS,EAAG,CAC7B,IAAIoG,GAAQ,MACZ,IAAoB,IAAAhC,EAAA5E,EAAAwC,KAAKK,QAAMgC,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAA5B,IAAMC,EAAKmE,EAAAnE,MACZuI,EAAKI,QAAQnI,KAAK0F,EAAQ,IAAM,MAChCA,GAAQ,EACRpE,KAAK0G,UAAUF,EAASC,EAAMvI,qGAElCuI,EAAKI,QAAQnI,KAAK,UAGlBsB,KAAK0G,UAAUF,EAASC,EAAMzG,KAAKK,OAAO,KAK9CP,EAAA2B,UAAA+F,QAAA,SAAQhB,EAA6BC,EAAuBhE,GAChE,IAAMqE,EAAU,QAAQL,EAAKM,aACvBF,EAAU,IAAIC,EAAO,IAC3BL,EAAKI,QAAQnI,KAAKmI,GAClBJ,EAAKpG,OAAOyG,GAAW9G,KAAK2G,WAAWlE,EAAM+D,IAGzC1G,EAAA2B,UAAAgG,cAAA,SAAcjB,EAA6BC,GAA3C,IAAAiB,EAAA1H,KACE2H,EAAa3H,KAAK2H,WACxB,GAAIA,GAAcA,EAAWC,MACzB5H,KAAKwH,QAAQhB,EAASC,EAAMkB,EAAWC,YAEtC,GAAI5H,KAAKS,MAAO,CACjB,IAAMmH,EAAQ5H,KAAKQ,YAAY6C,WAAWwE,SAAS7H,KAAKuF,eAAevF,KAAKS,QAAU,IACtFT,KAAKwH,QAAQhB,EAASC,EAAMmB,QAG5B,GAAK5H,KAAKmC,aAIL,CACcnC,KAAK8H,YACbjD,SAAQ,SAACpE,EAAOsH,GACL,IAAVA,GACAL,EAAKF,QAAQhB,EAASC,EAAM,KAEhC,IAAMmB,EAAQF,EAAKlH,YAAY6C,WAAWwE,SAASpH,GACnDiH,EAAKF,QAAQhB,EAASC,EAAMmB,UAXZ,CACdA,EAAQ5H,KAAKQ,YAAY6C,WAAWwE,SAAS,QACnD7H,KAAKwH,QAAQhB,EAASC,EAAMmB,KAehC9H,EAAA2B,UAAAuG,SAAA,SAASxB,EAA6BC,GACtCD,EAAQI,QACRH,EAAKI,QAAQnI,KAAK,2BAEtBsB,KAAKyH,cAAcjB,EAASC,GACxBD,EAAQI,SACRH,EAAKI,QAAQnI,KAAK,WAClB+H,EAAKI,QAAQnI,KAAK,gCAEtBsB,KAAKwH,QAAQhB,EAASC,EAAM,6BACxBD,EAAQI,QACRH,EAAKI,QAAQnI,KAAK,YAIlBoB,EAAA2B,UAAA8F,YAAA,SAAYhG,EAAkBiF,EAA6BC,GAC1DlF,IAGDiF,EAAQI,QACRH,EAAKI,QAAQnI,KAAK,8BAEtB+H,EAAKI,QAAQnI,KAAKsB,KAAK2G,WAAWpF,EAAUiF,IACxCA,EAAQI,QACRH,EAAKI,QAAQnI,KAAK,aAIlBoB,EAAA2B,UAAAwG,WAAA,SAAWxB,EAAuBD,WAChCJ,EAAQK,EAAKL,MACnBK,EAAKL,OAAQ,EACRI,IACDA,EAAU,IAEVvF,EAAAA,MAAMC,YAAYsF,EAAQ0B,cAC1B1B,EAAQ0B,YAAa,GAGzB,IAAMP,EAAa3H,KAAK2H,WAClBjH,GAAWiH,EAAaA,EAAWjH,aAAUR,IAAcF,KAAKU,QAChEyH,EAAUnI,KAAK+D,MAAQqC,IAAUI,EAAQ4B,cACzCC,GAAa7B,EAAQL,YAAcC,IAAUpG,KAAKyF,qBACxD,GAAIe,EAAQ0B,YAAgBxH,EACpByH,IACAnI,KAAKuH,YAAY,MAAOf,EAASC,GACjCA,EAAKI,QAAQnI,KAAK,MAElB2J,GACArI,KAAKgI,SAASxB,EAASC,GAE3BzG,KAAKuG,WAAWC,EAASC,EAAM/F,QAE9B,GAAIV,KAAK0D,OAAQ,CACdyE,IACAnI,KAAKuH,YAAY,MAAOf,EAASC,GACjCA,EAAKI,QAAQnI,KAAK,MAElB2J,GACArI,KAAKgI,SAASxB,EAASC,GAE3B,IAAMlF,EAAWvB,KAAK0F,oBAClBnE,IACAvB,KAAKuH,YAAYhG,EAAUiF,EAASC,GACpCA,EAAKI,QAAQnI,KAAK,MAEtBsB,KAAKsH,SAASd,EAASC,OAEtB,CACD,IAAKzG,KAAKkC,SACN,MAAO,CAAC2E,QAAS,IAEjBsB,IACAnI,KAAKuH,YAAY,MAAOf,EAASC,GACjCA,EAAKI,QAAQnI,KAAK,MAEtB,IAAI2H,EAAYD,EACZiC,IACArI,KAAKgI,SAASxB,EAASC,GACvBJ,GAAY,GAEZA,GACAI,EAAKI,QAAQnI,KAAK,KAEtB,IAAI0F,GAAQ,MACZ,IAAsB,IAAAhC,EAAA5E,EAAAwC,KAAKkC,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAAhC,IAAM8D,EAAOM,EAAAnE,MACTkG,IACGpE,KAAKa,KACL4F,EAAKI,QAAQnI,KAAK,KAClBsB,KAAKuH,YAAY,MAAOf,EAASC,GACjCA,EAAKI,QAAQnI,KAAK,OAGlB+H,EAAKI,QAAQnI,KAAK,KAClBsB,KAAKuH,YAAY,KAAMf,EAASC,GAChCA,EAAKI,QAAQnI,KAAK,OAG1B0F,GAAQ,EACRrC,EAAQkG,WAAWxB,EAAMD,qGAEzBH,GACAI,EAAKI,QAAQnI,KAAK,KAG1B,OAAI0H,EACO,CAACS,QAAS,IAEd,CACHA,QAASJ,EAAKI,QAAQd,KAAK,IAC3B1F,OAAQoG,EAAKpG,SAQrBP,EAAA2B,UAAA6G,UAAA,SAAU9B,GACN,OAAOxG,KAAKiI,WAAW,CACnB7B,OAAO,EACPS,QAAS,CAAC,QACVxG,OAAQ,GACR0G,WAAY,GACbP,IAGQ1G,EAAAyI,UAAP,SAAiBC,EAAsBrF,EAAaC,eACxD,GAAID,EAAMO,SAAWN,EAAMM,OACvB,OAAO,EAEX,GAAIP,EAAMO,OAAQ,CACd,GAAIP,EAAMhB,eAAiBiB,EAAMjB,aAC7B,OAAO,EAEX,GAAIgB,EAAMY,MAAQX,EAAMW,IACpB,OAAO,EAIX,GAFeyE,EAAQnF,WAAWoF,mBAAmBtF,EAAM1C,SAC5C+H,EAAQnF,WAAWoF,mBAAmBrF,EAAM3C,OAEvD,OAAO,EAIX,IAFgC,IAAd0C,EAAM5B,SAAQ,EAA2C4B,EAAM5B,aACjD,IAAd6B,EAAM7B,SAAQ,EAA2C6B,EAAM7B,UAE7E,OAAO,EAGf,IAAK4B,EAAMO,OAAQ,CACf,GAAIP,EAAMtC,MAAQuC,EAAMvC,IACpB,OAAO,EAIX,IAAKsC,EAAMjB,WAAckB,EAAMlB,SAC3B,OAAO,EAEX,IAAIwG,EAAuB,EAAGC,EAAyB,EAAGC,EAAuB,EAAGC,EAAyB,EAG7G,GAFA1F,EAAMjB,SAAS2C,SAAQ,SAAC9C,GAAkBA,EAAQI,aAAgBuG,IAAiCC,OACnGvF,EAAMlB,SAAS2C,SAAQ,SAAC9C,GAAkBA,EAAQI,aAAgByG,IAAiCC,OAC9FD,EAAuBF,GAA0BG,EAAyBF,EAC3E,OAAO,EAGf,IAAMG,EAAgB3F,EAAM9C,OAAS8C,EAAM9C,OAAOrC,OAAS,EAE3D,GAAI8K,KADkB1F,EAAM/C,OAAS+C,EAAM/C,OAAOrC,OAAS,GAEvD,OAAO,EAEX,GAAI8K,GAAiB3F,EAAM9C,QAAU+C,EAAM/C,WACvC,IAAqB,IAAAgC,EAAA7E,EAAA2F,EAAM9C,QAAM0I,EAAA1G,EAAApE,QAAA8K,EAAA5K,KAAA4K,EAAA1G,EAAApE,OAAE,CAA9B,IAAM8E,EAAMgG,EAAA7K,MACT8K,GAAQ,MACZ,IAAqB,IAAAC,GAAAC,OAAA,EAAA1L,EAAA4F,EAAM/C,SAAM8I,EAAAF,EAAAhL,QAAAkL,EAAAhL,KAAAgL,EAAAF,EAAAhL,OAAE,CAA9B,IAAM+E,EAAMmG,EAAAjL,MACT+C,EAAAA,MAAMqB,KAAKS,EAAQC,KACnBgG,GAAQ,qGAGhB,IAAKA,EACD,OAAO,oGAInB,OAAO,GAMXlJ,EAAA2B,UAAA8G,UAAA,SAAU7G,GACN,OAAO5B,EAAKyI,UAAUvI,KAAKQ,YAAaR,KAAM0B,IAUlD5B,EAAA2B,UAAA2H,KAAA,SAAK1H,EAAY2H,mBACb,GAAIrJ,KAAKuI,UAAU7G,GAAO,CACtB,IAAK1B,KAAK0D,QAAU1D,KAAKkC,aACrB,IAAqB,IAAA6G,EAAAvL,EAAAkE,EAAKQ,UAAQ+G,EAAAF,EAAA9K,QAAAgL,EAAA9K,KAAA8K,EAAAF,EAAA9K,OAAE,CAA/B,IAAMqL,EAAML,EAAA/K,MACT8K,GAAQ,MACZ,IAAqB,IAAAG,GAAAI,OAAA,EAAA/L,EAAAwC,KAAKkC,WAAQsH,EAAAL,EAAAlL,QAAAuL,EAAArL,KAAAqL,EAAAL,EAAAlL,OAAE,CAA/B,IAAMwL,EAAMD,EAAAtL,MACb,KAAImL,IAAUA,EAAOI,KAGjBA,EAAOL,KAAKE,GAAS,CACrBN,GAAQ,EACR,yGAGR,IAAKA,EACD,OAAO,uGAInB,OAAOhJ,KAGP,IAAKA,KAAK0D,QAAU1D,KAAKkC,aACrB,IAAoB,IAAAwH,EAAAlM,EAAAwC,KAAKkC,UAAQyH,EAAAD,EAAAzL,QAAA0L,EAAAxL,KAAAwL,EAAAD,EAAAzL,OAAE,CAA9B,IAAM2L,EAAKD,EAAAzL,MACZ,KAAImL,IAAUA,EAAOO,KAGjBA,EAAMR,KAAK1H,GACX,OAAOkI,oGAKvB,OAAO,MAQX9J,EAAA2B,UAAAoD,QAAA,SAAQgF,WAEJ,GADAA,EAAO7J,MACHA,KAAKkC,aACL,IAAsB,IAAAE,EAAA5E,EAAAwC,KAAKkC,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAAnBoE,EAAAnE,MACN2G,QAAQgF,uGAS5B/J,EAAA2B,UAAAqI,KAAA,SAAKC,WACD,GAAIA,EAAS/J,MACT,OAAO,EAEX,GAAIA,KAAKkC,aACL,IAAsB,IAAAE,EAAA5E,EAAAwC,KAAKkC,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CACjC,GADcoE,EAAAnE,MACF4L,KAAKC,GACb,OAAO,oGAInB,OAAO,GAOXjK,EAAA2B,UAAAuI,MAAA,SAAMD,WACF,IAAKA,EAAS/J,MACV,OAAO,EAEX,GAAIA,KAAKkC,aACL,IAAsB,IAAAE,EAAA5E,EAAAwC,KAAKkC,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CACjC,IADcoE,EAAAnE,MACD8L,MAAMD,GACf,OAAO,oGAInB,OAAO,GASXzM,OAAAkE,eAAI1B,EAAA2B,UAAA,eAAY,KAAhB,WACI,OAAOzB,KAAK8J,MAAK,SAAApI,GAAQ,OAAAA,EAAKgC,SAAWhC,EAAKS,cAAgBT,EAAKuI,+CAMvEnK,EAAA2B,UAAAqG,UAAA,WAAA,IAAAJ,EAAA1H,KACUkK,EAAmB,GASzB,OARAlK,KAAK6E,SAAQ,SAACnD,GACV,IAAMjB,EAAQiH,EAAKlH,YAAY6C,WAAWoF,mBAAmB/G,EAAKjB,OAC9DA,IACKyJ,EAAOd,MAAK,SAACe,GAAW,OAAAlJ,EAAAA,MAAMqB,KAAK7B,EAAO0J,OAC3CD,EAAOxL,KAAK+B,OAIjByJ,GAUXpK,EAAA2B,UAAA2I,UAAA,SAAU3J,EAAeoD,GAAzB,IAAA6D,EAAA1H,UAAyB,IAAA6D,IAAAA,GAAA,GACrB,IAAMxD,EAAmB,GACnBpB,EAASe,KAAKQ,YAAY6C,WAAWC,kBAAkB7C,GAY7D,OAXAT,KAAK6E,SAAQ,SAACnD,GACV,GAAIzC,EAAQ,CACR,IAAMoL,EAAU3C,EAAKlH,YAAY6C,WAAWC,kBAAkB5B,EAAKjB,OACnE,IAAKQ,EAAAA,MAAMqB,KAAKrD,EAAQoL,GACpB,OAGJ3I,EAAKgC,QAAUhC,EAAKuI,aAAepG,GAAYnC,EAAKrB,QACpDA,EAAO3B,KAAI4L,MAAXjK,EAAMzB,EAAS8C,EAAKrB,YAGrBA,GAGHP,EAAA2B,UAAA8I,aAAA,SAAaC,EAA6B/J,EAAgBgK,WAC9D,GAAKD,EAAL,CAGA,IAAMN,EAASjJ,EAAAA,MAAMyJ,MAAMjK,GAAS,GAAI,KACpCyJ,EAAOlM,QAAU,GAAKiD,EAAAA,MAAMC,YAAYsJ,EAAKN,EAAO,MAAUO,GAE9DP,EAAO3H,QAAO+H,MAAdJ,EAAMtL,EAAYqC,EAAAA,MAAMyJ,MAAMD,EAAc,OAEhD,IAAIvM,EAAasM,MACjB,IAAqB,IAAAG,EAAAnN,EAAA0M,GAAMU,EAAAD,EAAA1M,QAAA2M,EAAAzM,KAAAyM,EAAAD,EAAA1M,OAAE,CAAxB,IAAMgC,EAAM2K,EAAA1M,MACb,IAAKA,EACD,MAEJA,EAAQA,EAAM+B,qGAElB,OAAO/B,IAGH4B,EAAA2B,UAAAoJ,kBAAA,SAAkB3M,WACtB,GAAIA,EAAO,CACP,IAAI4M,EAAS9K,KAAK+K,kBAAkB7M,GACpC,IAAK+C,EAAAA,MAAMC,YAAY4J,GACnB,OAAOA,EAEX,IAAIE,GAAgB,EAChBC,GAAW,EACTnF,EAAe,OACrB,IAAiB,IAAAoF,EAAA1N,EAAAU,GAAKiN,EAAAD,EAAAjN,QAAAkN,EAAAhN,KAAAgN,EAAAD,EAAAjN,OAAE,CAAnB,IAAMmN,EAAED,EAAAjN,MACT,OAAQkN,GAEJ,IAAK,KACGH,GACAnF,EAAGpH,KAAK,QACRuM,GAAW,GAGXA,GAAW,EAEf,MACJ,IAAK,IACGA,GACAnF,EAAGpH,KAAK,MACRoH,EAAGpH,KAAK0M,GACRH,GAAW,IAGXD,GAAgB,EAChBlF,EAAGpH,KAAK,QAEZ,MACJ,IAAK,IACGuM,GACAnF,EAAGpH,KAAK,MACRoH,EAAGpH,KAAK0M,GACRH,GAAW,IAGXD,GAAgB,EAChBlF,EAAGpH,KAAK,MAEZ,MAEJ,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACDoH,EAAGpH,KAAK,MACRoH,EAAGpH,KAAK0M,GACRH,GAAW,EACX,MAEJ,QACInF,EAAGpH,KAAK0M,GACRH,GAAW,qGAIvB,GAAID,EAGA,OAFAF,EAAS,IAAIO,OAAO,IAAMvF,EAAGC,KAAK,IAAM,IAAK,KAC7C/F,KAAK+K,kBAAkB7M,GAAS4M,EACzBA,EAGP9K,KAAK+K,kBAAkB7M,QAASgC,IAOpCJ,EAAA2B,UAAA6J,QAAA,SAAQpN,EAAsCqN,EAAgBC,eAClE,GAAIvK,EAAAA,MAAMwK,QAAQF,IAAmC,IAArBA,EAAUvN,OACtC,OAAO0N,IAEX,IAAMzM,EAASa,EAAKyD,UAAUvD,KAAKQ,YAAaR,KAAKS,OAAS,IAC9D,GAAIQ,EAAAA,MAAMwK,QAAQF,IAActK,EAAAA,MAAMwK,QAAQvN,GAAQ,CAKlD,GAHK+C,EAAAA,MAAMwK,QAAQF,KACfA,EAAY,CAACA,IAEbtK,EAAAA,MAAMwK,QAAQvN,IACd,GAAqB,IAAjBA,EAAMF,OACN,OAAO0N,SAIXxN,EAAQ,CAACA,EAAQ,QAGrB,IAAqB,IAAAyN,EAAAnO,EAAAU,GAAK0N,EAAAD,EAAA1N,QAAA2N,EAAAzN,KAAAyN,EAAAD,EAAA1N,OAAE,CAAvB,IAAM8E,EAAM6I,EAAA1N,UACb,IAAyB,IAAA2N,GAAAC,OAAA,EAAAtO,EAAA+N,IAASQ,EAAAF,EAAA5N,QAAA8N,EAAA5N,KAAA4N,EAAAF,EAAA5N,OAAE,CAA/B,IAAM+N,EAAUD,EAAA7N,MACjB,GAA+C,IAA3C8B,KAAKsL,QAAQvI,EAAQiJ,GAAY,GACjC,OAAO,uMAInB,OAAON,IAEX,IAAKzK,EAAAA,MAAMwK,QAAQvN,GAAQ,CAKvB,GAJAA,EAAQiD,EAAWE,SAASnD,GAAS,IACjCe,GAAUA,EAAOgN,SACjB/N,EAAQ8B,KAAKQ,YAAY4G,cAActE,WAAW5E,EAAOe,EAAOgN,SAEhElN,EAAkBY,SAASV,GAK3B,OAJKgC,EAAAA,MAAMtB,SAAS4L,KAChBA,EAAY,GAGTA,GADDvE,EAAS/F,EAAAA,MAAMiL,SAAShO,IAGlC,GAAIa,EAAkBS,OAAOP,GAAS,CAK9B,IAAM+H,EADV,GAHI/F,EAAAA,MAAMjC,SAASuM,KACfA,EAAYtK,EAAAA,MAAMkL,OAAOZ,IAEzBtK,EAAAA,MAAMzB,OAAO+L,GAEb,GADMvE,EAAShH,KAAKQ,YAAY4L,YAAYC,UAAUnO,GAElD,OAAOqN,EAAUe,UAAYtF,EAAOsF,UAG5C,OAAOZ,IAEX,GAAI3M,EAAkBQ,UAAUN,GAE5B,OAAQsM,EAAY,EAAI,IADlBvE,EAAS/F,EAAAA,MAAMkG,OAAOjJ,GAAS,EAAI,GAI7C,GADAqN,EAAYA,GAAa,GACrBtK,EAAAA,MAAMjC,SAASuM,GAAY,CAE3B,GADAA,EAAYpK,EAAWE,SAASkK,GAC5BC,EAAU,CACV,IAAMV,EAAS9K,KAAK6K,kBAAkB3M,GACtC,GAAI4M,EACA,OAAOA,EAAOyB,KAAKhB,GAAa,GAAK,EAG7C,OAAOtK,EAAAA,MAAMqK,QAAQC,EAAWrN,IAGxC,OAAOwN,KAYX5L,EAAA2B,UAAA+K,SAAA,SAAShC,EAA6BC,WAC9BgC,EACJ,GAAIzM,KAAK0D,OACL,GAAK1D,KAAKmC,aAIN,GAAIlB,EAAAA,MAAMqB,KAAKtC,KAAKS,OAAS,GAAI,UAAW,CACxC,IAAM8K,EAAYvL,KAAKuK,aAAaC,EAAMxK,KAAK9B,MAAOuM,GACtDgC,GAAOxL,EAAAA,MAAMC,YAAYqK,QAExB,GAAItK,EAAAA,MAAMqB,KAAKtC,KAAKS,OAAS,GAAI,WAAY,CACxC8K,EAAYvL,KAAKuK,aAAaC,EAAMxK,KAAK9B,MAAOuM,GACtDgC,EAAMxL,EAAAA,MAAMC,YAAYqK,OAEvB,CACKA,EAAYvL,KAAKuK,aAAaC,EAAMxK,KAAKS,MAAOgK,GACtD,OAAQzK,KAAKuB,UACT,KAAA,EACA,KAAA,EACIkL,EAAoD,IAA9CzM,KAAKsL,QAAQtL,KAAK9B,MAAOqN,GAAW,GAC1C,MACJ,KAAA,EACIkB,EAAMzM,KAAKsL,QAAQtL,KAAK9B,MAAOqN,GAAa,EAC5C,MACJ,KAAA,EACIkB,EAAMzM,KAAKsL,QAAQtL,KAAK9B,MAAOqN,IAAc,EAC7C,MACJ,KAAA,EACIkB,EAAMzM,KAAKsL,QAAQtL,KAAK9B,MAAOqN,GAAa,EAC5C,MACJ,KAAA,EACIkB,EAAMzM,KAAKsL,QAAQtL,KAAK9B,MAAOqN,IAAc,EAC7C,MACJ,KAAA,EACIkB,EAAoD,IAA9CzM,KAAKsL,QAAQtL,KAAK9B,MAAOqN,GAAW,GAC1C,MACJ,KAAA,EAEIkB,EADe,IAAIpB,OAAOrL,KAAK9B,OAAS,IAC3BqO,KAAKhB,EAAY,IAC9B,MAEJ,KAAA,EACIkB,EAA0D,IAApDzM,KAAKsL,QAAQtL,KAAK9B,MAAQ,IAAKqN,GAAW,GAChD,MACJ,KAAA,GACIkB,EAAqD,IAA/CzM,KAAKsL,QAAQtL,KAAKK,OAAQkL,GAAW,GAC3C,MACJ,KAAA,EACIkB,EAAoD,IAA9CzM,KAAKsL,QAAQtL,KAAK9B,MAAOqN,GAAW,GAC1C,MACJ,KAAA,GACIkB,IAAQzM,KAAKK,QACTL,KAAKsL,QAAQtL,KAAKK,OAAO,GAAIkL,IAAc,GAAKvL,KAAKsL,QAAQtL,KAAKK,OAAO,GAAIkL,IAAc,QAjD3GkB,GAAM,MAuDT,CACDA,IAAQzM,KAAKa,QACb,IAAsB,IAAAuB,EAAA5E,EAAAwC,KAAKkC,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAAhC,IACKyO,EADQrK,EAAAnE,MACOsO,SAAShC,EAAMC,GACpC,GAAIzK,KAAKa,KAEL,KADA4L,EAAMA,GAAOC,GAET,WAIJD,EAAMA,GAAOC,qGAOzB,OAHI1M,KAAK+D,MACL0I,GAAOA,GAEJA,UAqEX,SAAYE,EAAYzO,EAAoB0O,EAAuBC,QAA3C,IAAA3O,IAAAA,EAAA,SAAoB,IAAA0O,IAAAA,GAAoB,QAAG,IAAAC,IAAAA,GAAoB,GACnF7M,KAAK2M,IAAMA,EACX3M,KAAK8M,SAAW5O,EAChB8B,KAAK+M,YAAcH,EACnB5M,KAAKgN,YAAcH,GAjBTI,EAAAC,QAA8B,IAAID,GAAkB,GACpDA,EAAAE,GAAyB,IAAIF,EAAkB,GAC/CA,EAAApM,IAA0B,IAAIoM,EAAkB,GAChDA,EAAAlJ,IAA0B,IAAIkJ,EAAkB,GAChDA,EAAAG,KAA2B,IAAIH,EAAkB,GACjDA,EAAAI,KAA2B,IAAIJ,EAAkB,GACjDA,EAAAK,IAA0B,IAAIL,EAAkB,oBA+E9D,SAAA9L,EAAoBX,EAA0BgG,GAC1CxG,KAAKQ,YAAcA,EACnBR,KAAKwG,QAAUA,GAAW,GAC1BxG,KAAKQ,YAAYgD,iBAAmBxD,KAAKwG,QAAQhD,iBACjDxD,KAAKuN,YAAc,GACnBvN,KAAKwN,UAAY,GACjBxN,KAAKkK,OAAS,GACdlK,KAAKyN,SAAW,GAChBzN,KAAKyC,KAAO,GACZzC,KAAK8D,QAAU,EACf9D,KAAKhC,OAAS,EACdgC,KAAK0N,GAAK1N,KAAK2N,OAAS3N,KAAK4N,OAASX,EAAmBC,eAa/C/L,EAAAyE,OAAP,SAAc1H,GACjB,IAAKA,EACD,MAAO,KAGX,IAA+B,KAD/BA,EAAQ2P,OAAO3P,IACL4P,OAAO,SACb,MAAO,IAAM5P,EAAQ,IAGzB,IADA,IAAM4H,EAAe,CAAC,KACbhI,EAAI,EAAGqH,EAAKjH,EAAMF,OAAQF,EAAIqH,EAAIrH,IAAK,CAC5C,IAAMsN,EAAKlN,EAAMJ,GACN,OAAPsN,GAAsB,MAAPA,GACftF,EAAGpH,KAAK,MAEZoH,EAAGpH,KAAK0M,GAGZ,OADAtF,EAAGpH,KAAK,KACDoH,EAAGC,KAAK,KAGJ5E,EAAA4M,UAAP,SAAiB7P,GACrB,QAASA,GAASA,EAAMF,QAAU,GAAkB,MAAbE,EAAM,IAA0C,MAA5BA,EAAMA,EAAMF,OAAS,IAStEmD,EAAAE,SAAP,SAAgBnD,GACnB,IAAKiD,EAAW4M,UAAU7P,GACtB,OAAOA,EAGX,IADA,IAAM4H,EAAe,GACZhI,EAAI,EAAGqH,EAAKjH,EAAMF,OAAS,EAAGF,EAAIqH,EAAIrH,IAAK,CAChD,IAAIsN,EAAKlN,EAAMJ,GACf,GAAW,OAAPsN,EAAa,CACb,GAAItN,GAAKqH,EAAK,EACV,SAEJiG,EAAKlN,IAAQJ,GAEjBgI,EAAGpH,KAAK0M,GAEZ,OAAOtF,EAAGC,KAAK,KAML5E,EAAAC,aAAP,SAAoBf,GACvB,IAAKA,EACD,OAAOA,EAGX,IADA,IAAM2N,EAAoB,GACjBC,EAAK,EAAGC,EAAK7N,EAAQ4N,EAAKC,EAAGlQ,OAAQiQ,IAAM,CAChD,IAAM/P,EAAQgQ,EAAGD,GACjBD,EAAQtP,KAAKyC,EAAWE,SAASnD,IAErC,OAAO8P,GAMG7M,EAAAyD,2BAAP,SAAkCnC,EAAc0L,GACnD,GAAIlN,EAAAA,MAAMU,QAAQc,GACd,MAAO,GAEX,IAAKA,EAAK6B,SAAS6J,GACf,MAAO,CAAC,CAACjQ,MAAOuE,EAAM1B,MAAO,EAAG/C,OAAQyE,EAAKzE,SAQjD,IANA,IAKIE,EALEmC,EAA8B,GAC9BrC,EAASyE,EAAKzE,OAChB8F,EAAU,EACVsK,EAAe,EACbtI,EAAe,KAER,CACT,GAAIhC,GAAW9F,EAAQ,EACnBE,EAAQ4B,EAAKkE,oBAAoB8B,EAAGC,KAAK,MACnChF,OAASqN,EACVnN,EAAAA,MAAMU,QAAQzD,EAAMA,QACrBmC,EAAO3B,KAAKR,GAEhB,MAEJ,IAAMkN,EAAK3I,EAAKqB,GAChB,GAAW,OAAPsH,GAGA,GAFAtF,EAAGpH,KAAK0M,KACRtH,EACc9F,EAAQ,CAClB,IAAMqQ,EAAM5L,EAAKqB,GACL,OAARuK,GAAwB,MAARA,IAChBvI,EAAGpH,KAAK2P,GACRvK,WAIP,GAAW,MAAPsH,EAAY,CACjB,IAAM/G,EAAqB,CAACnG,MAAO,GAC7BR,EAAIyD,EAAWmN,WAAW7L,EAAMzE,EAAQ8F,EAASA,EAAU,EAAG,IAAKO,GACnE3G,GACFoI,EAAGpH,KAAKhB,GACRoG,EAAUO,EAAKnG,QAGf4H,EAAGpH,KAAK0M,GACRtH,UAGCsH,IAAO+C,IACZjQ,EAAQ4B,EAAKkE,oBAAoB8B,EAAGC,KAAK,MACnChF,OAASqN,EACftI,EAAG9H,OAAS,EACPiD,EAAAA,MAAMU,QAAQzD,EAAMA,QACrBmC,EAAO3B,KAAKR,GAGhBkQ,IADAtK,IAIAgC,EAAGpH,KAAK0M,GACRtH,KAGR,OAAOzD,GAGHc,EAAAM,UAAA8M,aAAA,SAAaC,EAAiBC,EAA0BC,GAC5D,GAA8B,IAA1BD,EAAezQ,OAAc,CAC7B,IAAM2Q,EAAeF,EAAe1I,KAAK,IACzC,GAAM4I,IAAiB,UAAUrK,SAASqK,EAAaA,EAAa3Q,OAAS,IACzE,OAAO,EAGf,GAAIiD,EAAAA,MAAMU,QAAQ6M,GACd,OAAO,EAEX,IAAMI,EAAaJ,EAAQxQ,OAC3B,GAAIgC,KAAK8D,QAAU8K,EAAa5O,KAAKhC,OACjC,OAAO,EAEX,IAAK,IAAIF,EAAI,EAAGqH,EAAKyJ,EAAY9Q,EAAIqH,EAAIrH,IAAK,CAG1C,GAFWkC,KAAKyC,KAAKzC,KAAK8D,QAAUhG,KACzB0Q,EAAQ1Q,GAEf,OAAO,EAGf,GAAIkC,KAAK8D,QAAU8K,EAAa5O,KAAKhC,OAAQ,CACzC,IAAM6Q,EAAM7O,KAAKyC,KAAKzC,KAAK8D,QAAU8K,GACrC,GAAIC,IAAQH,IAAa,WAAWpK,SAASuK,GACzC,OAAO,EAGf,OAAO,GAGH1N,EAAAM,UAAA6M,WAAA,SAAWlK,EAAerD,EAAe+N,EAAkBzK,GAC/D,OAAOlD,EAAWmN,WAAWtO,KAAKyC,KAAMzC,KAAKhC,OAAQoG,EAAOrD,EAAO+N,EAAUzK,IAGlElD,EAAAmN,WAAP,SAAkB7L,EAAczE,EAAgBoG,EAAerD,EAAe+N,EAAkBzK,GACpGA,EAAKnG,MAAQ6C,EAGb,IAFA,IAAIiI,GAAQ,EACNlD,EAAe,CAACrD,EAAKgC,OAAOL,EAAOrD,EAAQqD,IAC1CC,EAAKnG,MAAQF,GAAQ,CACxB,IAAIoN,EAAK3I,EAAK4B,EAAKnG,SACnB,GAAW,OAAPkN,IACAtF,EAAGpH,KAAK0M,GACJ/G,EAAKnG,MAAQF,IAEF,QADXoN,EAAK3I,EAAK4B,EAAKnG,WACW,MAAPkN,IACftF,EAAGpH,KAAK0M,QAMpB,GADAtF,EAAGpH,KAAK0M,GACJ0D,EAASxK,SAAS8G,GAAK,CACvBpC,GAAQ,EACR,OAGR,GAAKA,EAGL,OAAOlD,EAAGC,KAAK,KAGX5E,EAAAM,UAAAsN,iBAAA,SAAiBhO,GAGrB,IAFA,IAAMqD,EAAQpE,KAAK8D,QACfO,EAAOtD,EACJsD,EAAOrE,KAAKhC,QAAQ,CACvB,IAAMoN,EAAKpL,KAAKyC,KAAK4B,GACrB,GAAI,WAAWC,SAAS8G,GACpB,MAEJ/G,IAEJ,OAAIA,IAAStD,EACF,GAEJf,KAAKyC,KAAKgC,OAAOL,EAAOC,EAAOD,IAGlCjD,EAAAM,UAAAuN,eAAA,SAAe5D,EAAY6D,GAC/B,MAAW,MAAP7D,EAAoB,IACb,MAAPA,EAAmB6D,EAAc,KAAO,IACjC,MAAP7D,EAAmB6D,EAAc,KAAO,IACjC,MAAP7D,EAAmB,IACZ,MAAPA,EAAmB,IACZ,MAAPA,EAAmB,IAChB,IAGHjK,EAAAM,UAAAyN,cAAA,SAAchR,EAAeiR,GACjC,YADiC,IAAAA,IAAAA,GAAA,IACzBlO,EAAAA,MAAMU,QAAQzD,IAAWiR,GAAcnP,KAAKwG,QAAQ4I,mBAAqBnO,EAAAA,MAAMU,QAAQ3B,KAAKS,QAGhGU,EAAAM,UAAA4N,aAAA,SAAanR,EAAeiR,GAEhC,QAFgC,IAAAA,IAAAA,GAAA,GAElB,OAAVjR,EAAgB,OAAO,EAC3B,IAAIoR,EAAMtP,KAAK8D,QAKf,OAFAwL,GAFYpR,EAAMF,QAClBE,EAAQ+C,EAAAA,MAAMiD,QAAQhG,IACHF,OACnBE,EAAQA,EAAMqR,SACVvP,KAAKkP,cAAchR,EAAOiR,KAC1BnP,KAAK0N,GAAK,IAAIT,EAAkB,EAAc/O,EAAOoR,EAAMpR,EAAMF,OAAQE,EAAMF,SACxE,IAKPmD,EAAAM,UAAA+N,YAAA,SAAY1J,EAAcqJ,GAC9B,YAD8B,IAAAA,IAAAA,GAAA,KACzBrJ,GAGE9F,KAAKqP,aAAavJ,EAAGC,KAAK,IAAKoJ,IAGlChO,EAAAM,UAAAgO,gBAAA,SAAgBvR,GACpB,IAAMwR,EAAmB1P,KAAKQ,YAAY6C,WAAWsM,QAAU3P,KAAKQ,YAAY6C,WAAWsM,QAAQD,iBAAmB,EAClH5O,EAAOG,EAAAA,MAAM2O,MAAM1R,EAAOwR,GAI9B,OAHI5O,EAAO,IACPA,EAAO4O,GAEJ5O,EAAKwF,YAGRnF,EAAAM,UAAAoO,YAAA,SAAY3R,GAChB,IAAKA,GAASA,EAAMF,OAAS,EACzB,OAAQ,EAEZ,GAAgC,MAA5BE,EAAMA,EAAMF,OAAS,GACrB,OAAQ,EAGZ,IADA,IAAIsR,EAAMpR,EAAMF,OAAS,GACT,IAATsR,GAEH,IAAa,KADbA,EAAMpR,EAAM4R,YAAY,IAAKR,IACb,CAGZ,IAFA,IAAIS,EAAU,EACVC,EAAOV,EAAM,EACVU,GAAQ,GACS,OAAhB9R,EAAM8R,IAGVD,IACAC,IAEJ,GAAID,EAAU,GAAM,EAChB,OAAOT,EAEXA,IAGR,OAAQ,GAGJnO,EAAAM,UAAAwO,iBAAA,SAAiBC,GACrB,OAAOlQ,KAAKwG,QAAQ2J,kBAAoBlP,EAAAA,MAAMmP,wBAAwBF,GAAQjP,EAAAA,MAAMoP,kBAAkBH,IAGlG/O,EAAAM,UAAA6O,eAAA,SAAe7P,EAAe8P,EAAwBC,GAE1D,GADAA,EAAWtS,OAAQ,EACf+C,EAAAA,MAAMwC,MAAMhD,EAAO,SAAU,WAC7B,OAAO,EAEX,GAAIQ,EAAAA,MAAMwC,MAAMhD,EAAO,OAAQ,WAAY,SAAU,qBAGjD,OADA+P,EAAWtS,OAAQ,GACZ,EAEX,IAAMyR,EAAU3P,KAAKQ,YAAY6C,WAAWsM,QAC5C,GAAIA,EAAS,CAET,IAAI1Q,GADJsR,EAAgBA,IAAkBvQ,KAAKQ,YAAYgD,uBACtBtD,EAAYF,KAAKQ,YAAY6C,WAAWE,UAAU9C,GAW/E,GAVMxB,IACc,KAAZA,EAAOC,OAGDyQ,EAAQc,sBAAwBd,EAAQc,qBAAqBC,gBAClEf,EAAQc,qBAAqBE,WAAWlQ,KACxCkP,EAAQc,qBAAqBE,WAAW1R,EAAOiR,SAJhDjR,OAASiB,IAQZF,KAAKQ,YAAYgD,mBAAqBvE,IACvCuR,EAAWtS,OAAQ,EACdyR,EAAQiB,wBAA0BjB,EAAQiB,uBAAuBF,gBACjEf,EAAQiB,uBAAuBD,WAAWlQ,IAC3C,OAAO,EAInB,OAAO,GAGHU,EAAAM,UAAAoP,UAAA,WACJ,GAAI7Q,KAAK4N,SAAWX,EAAmBC,QAInC,OAHAlN,KAAK2N,OAAS3N,KAAK0N,GACnB1N,KAAK0N,GAAK1N,KAAK4N,YACf5N,KAAK4N,OAASX,EAAmBC,SAGrC,IAAI9B,EAEA0F,EADJ9Q,KAAK2N,OAAS3N,KAAK0N,GAKnB,IAHA,IAAMe,EAA2B,GAC7BsC,GAAqB,EACrBC,GAAiB,IACR,CACT,GAAIhR,KAAK8D,SAAW9D,KAAKhC,OAAQ,CAC7B,GAAIgC,KAAKwP,YAAYf,GACjB,OAGJ,YADAzO,KAAK0N,GAAKT,EAAmBK,KAIjC,GAAW,QADXlC,EAAKpL,KAAKyC,KAAKzC,KAAK8D,UACH,CAGb,GAFA2K,EAAe/P,KAAK0M,GACpBpL,KAAK8D,UACD9D,KAAK8D,QAAU9D,KAAKhC,OAER,QADNqQ,EAAMrO,KAAKyC,KAAKzC,KAAK8D,WACC,MAARuK,IAChBI,EAAe/P,KAAK2P,GACpBrO,KAAK8D,eAIZ,CAAA,GAAW,MAAPsH,EAAY,CACjB,GAAIpL,KAAKwP,YAAYf,GAAgB,GACjC,OAIJ,OAFAzO,KAAK0N,GAAKT,EAAmBG,UAC7BpN,KAAK8D,UAGJ,GAAW,MAAPsH,EAAY,CACjB,GAAIpL,KAAKwP,YAAYf,GACjB,OAIJ,OAFAzO,KAAK0N,GAAKT,EAAmBI,UAC7BrN,KAAK8D,UAGJ,GAAI9D,KAAKuO,aAAa,MAAOE,GAAiB,CAC/C,GAAIzO,KAAKwP,YAAYf,GACjB,OAIJ,OAFAzO,KAAK0N,GAAKT,EAAmBpM,SAC7Bb,KAAK8D,SAAW,GAGf,GAAI9D,KAAKuO,aAAa,KAAME,GAAiB,CAC9C,GAAIzO,KAAKwP,YAAYf,GACjB,OAIJ,OAFAzO,KAAK0N,GAAKT,EAAmBE,QAC7BnN,KAAK8D,SAAW,GAGf,GAAI9D,KAAKuO,aAAa,MAAOE,GAAiB,CAC/C,GAAIzO,KAAKwP,YAAYf,GACjB,OAIJ,OAFAzO,KAAK0N,GAAKT,EAAmBlJ,SAC7B/D,KAAK8D,SAAW,GAGf,GAAI9D,KAAKuO,aAAa,OAAQE,EAAgB,KAAM,CACrD,GAAIzO,KAAKwP,YAAYf,GACjB,OAIJ,GAFAzO,KAAK8D,SAAW,EAChBgN,OAAY5Q,EACRF,KAAK8D,QAAU9D,KAAKhC,QAAsC,MAA5BgC,KAAKyC,KAAKzC,KAAK8D,SAAkB,CAC/D,IAAMO,EAAqB,CAACnG,MAAO,GAE/B4C,GAAQ,EAKZ,QAJkBZ,KAFlB4Q,EAAY9Q,KAAKsO,WAAWtO,KAAK8D,QAAU,EAAG9D,KAAK8D,QAAU,EAAG,eAAiBO,MAG7EyM,EAAYA,EAAUrM,OAAO,EAAGqM,EAAU9S,OAAS,GACnD8C,EAAOG,EAAAA,MAAM2O,MAAMkB,GAAY,IAE/BhQ,EAAO,EACP,MAAO,eAEXd,KAAK8D,QAAUO,EAAKnG,MAAQ,EAEhC4S,EAAY9Q,KAAKyP,gBAAgBqB,GAAa,IAC9C,IAAMG,EAAQjR,KAAK8D,SAAW9D,KAAKhC,QAAsC,MAA5BgC,KAAKyC,KAAKzC,KAAK8D,SAM5D,YAHA9D,KAAK0N,GAAKuD,EACN,IAAIhE,EAAkB,GAAmBhM,EAAAA,MAAM2O,MAAMkB,GAAa,GAAGxK,YACrE,IAAI2G,EAAkB,EAAa6D,IAGtC,GAAW,MAAP1F,GAAqB,MAAPA,EAAY,CAC/B,GAAIpL,KAAK8D,QAAU,EAAI9D,KAAKhC,OAAQ,CAChC,IAAMqQ,EAAMrO,KAAKyC,KAAKzC,KAAK8D,QAAU,GAEjC9F,GADEqG,EAAqB,CAACnG,MAAO,QACjB,GASlB,GARI,QAASoG,SAAS+J,IAClByC,EAAY9Q,KAAKsO,WAAWtO,KAAK8D,QAAS9D,KAAK8D,QAAU,EAAG9D,KAAKgP,eAAeX,GAAK,GAAQhK,GAC7FrG,EAASqG,EAAKnG,MAAQ8B,KAAK8D,SAI3B9F,GADA8S,EAAY9Q,KAAK+O,iBAAiB/O,KAAK8D,QAAU,IAC1BgN,EAAU9S,OAAS,EAExC8S,EAAW,CACbrC,EAAe/P,KAAKoS,GACpB9Q,KAAK8D,SAAW9F,EAChB,UAGR,MAAO,iBAAmBoN,EAEzB,GAAI,QAAS9G,SAAS8G,GAAK,CACtB/G,EAAqB,CAACnG,MAAO,GAEnC,GADA4S,EAAY9Q,KAAKsO,WAAWtO,KAAK8D,QAAS9D,KAAK8D,QAAU,EAAG9D,KAAKgP,eAAe5D,GAAI,GAAO/G,GAC1E,CACb,IAAM6M,EAAcF,GAAkB,KAAK1M,SAAS8G,IAAiC,IAA1BqD,EAAezQ,OAG1E,GAFAyQ,EAAe/P,KAAKoS,GACpB9Q,KAAK8D,QAAUO,EAAKnG,MAChBgT,GAAclR,KAAKwP,YAAYf,GAC/B,OAEJ,SAEJ,MAAO,iBAAmBrD,EAG1B,GAAW,MAAPA,EAAY,CAMZ,IAAMuD,EAAeF,EAAe1I,KAAK,IACzC,IAA2B,IAAvBgL,IAG2B,KAD3BA,EAAoB/Q,KAAK6P,YAAYlB,IAGjC,OADA3O,KAAK0N,GAAKT,EAAmBC,QACtB,gBAGf,IAAIzM,EAAQkO,EAAalK,OAAOsM,GAAmBxB,OAC/C7O,EAAU,GAERyQ,EAAenR,KAAK6P,YAAYpP,GAKtC,IAJsB,IAAlB0Q,IACAzQ,EAAUS,EAAWE,SAASZ,EAAMgE,OAAO0M,EAAc1Q,EAAMzC,OAASmT,IACxE1Q,EAAQA,EAAMgE,OAAO,EAAG0M,IAExBnR,KAAKiQ,iBAAiBxP,IAAWQ,EAAAA,MAAMU,QAAQlB,KAAWQ,EAAAA,MAAMU,QAAQjB,GAAW,CACnF,IAAMxC,EAAQyQ,EAAalK,OAAO,EAAGsM,GACrC,GAAI/Q,KAAKkP,cAAchR,EAAMqR,QAGzB,OAFAvP,KAAK8D,SAAY2K,EAAe1I,KAAK,IAAI/H,OAAS+S,OAClD/Q,KAAKqP,aAAanR,GAGtB,IAAK+C,EAAAA,MAAMU,QAAQlB,GAAQ,CACvB,IAAI8P,GAAgB,EAChBvQ,KAAK8D,QAAU,EAAI9D,KAAKhC,QAA0C,MAAhCgC,KAAKyC,KAAKzC,KAAK8D,QAAU,KAE3DyM,GAAgB,EAChBvQ,KAAK8D,WAET,IAAM0M,EAA4B,CAAEtS,OAAO,GAC3C,IAAK8B,KAAKsQ,eAAe7P,EAAO8P,EAAeC,GAAa,CACxDO,GAAqB,EACrBtC,EAAe/P,KAAK,KAChB6R,GACA9B,EAAe/P,KAAK,KAExBsB,KAAK8D,UACL,SAEA0M,EAAWtS,QACXuC,EAAQU,EAAWqE,oBAAsB/E,GAG5CQ,EAAAA,MAAMU,QAAQlB,KACfT,KAAKS,MAAQA,EACbuQ,GAAiB,GAEhB/P,EAAAA,MAAMU,QAAQjB,KACfV,KAAKU,QAAUA,GAEnB+N,EAAezQ,OAAS,EACxBgC,KAAK8D,UACL,UAGJ,WAAWQ,SAAS8G,GACpB2F,GAAqB,GAEO,IAAvBA,IACLA,EAAoBtC,EAAe1I,KAAK,IAAI/H,QAEhDyQ,EAAe/P,KAAK0M,GACpBpL,KAAK8D,aAKT3C,EAAAM,UAAA2P,MAAA,WACJpR,KAAKyC,KAAO,GACZzC,KAAK8D,QAAU,EACf9D,KAAKhC,OAAS,EACdgC,KAAKwN,UAAUxP,OAAS,EACxBgC,KAAKuN,YAAYvP,OAAS,EAC1BgC,KAAKkK,OAAOlM,OAAS,EACrBgC,KAAKyN,SAASzP,OAAS,GAQbmD,EAAAkQ,MAAP,SAAa5O,EAAc+F,EAAsBhC,GACpD,IAAMyF,EAAS,IAAI9K,EAAWqH,EAAShC,GACjC7H,EAAQsN,EAAOoF,MAAM5O,GAC3B,OAAI9D,GAGGsN,EAAOqF,eAGVnQ,EAAAM,UAAA6P,YAAA,WACJ,OAAgC,IAA5BtR,KAAKuN,YAAYvP,OACV,sBAEJgC,KAAKuN,YAAY,IAG5BjQ,OAAAkE,eAAYL,EAAAM,UAAA,eAAY,KAAxB,WACI,IAAIhB,EAAQT,KAAKS,MAIjB,OAHIQ,EAAAA,MAAMU,QAAQlB,KACdA,EAAQT,KAAKuR,aAEV9Q,mCAGXnD,OAAAkE,eAAYL,EAAAM,UAAA,iBAAc,KAA1B,WACI,IAAIf,EAAUV,KAAKU,QAInB,OAHIO,EAAAA,MAAMU,QAAQjB,KACdA,EAAUV,KAAKwR,eAEZ9Q,mCAGHS,EAAAM,UAAA4P,MAAA,SAAM5O,GAEV,GADAzC,KAAKoR,QACDpR,KAAKwG,QAAQ4I,mBAAqBnO,EAAAA,MAAMwQ,IAAIhP,EAAK8M,QAAS,CAC1D,IAAM7N,EAAO5B,EAAK0C,SAASxC,KAAKQ,YAAa,GAAIR,KAAKgC,aAAchC,KAAK0R,eAAgB1R,KAAKwG,QAAQ4I,kBAMtG,OALI1N,IACAA,EAAKX,MAAQ,EACbW,EAAK1D,OAAS,EACdgC,KAAKuN,YAAY7O,KAAKgD,IAEnB,GAEX1B,KAAKyC,KAAOA,GAAQ,GACpBzC,KAAKhC,OAASgC,KAAKyC,KAAKzE,OACxBgC,KAAKwN,UAAU9O,KAAKuO,EAAmBK,KACvC,IAAIqE,EAAM3R,KAAK6Q,YACf,GAAIc,EACA,OAAOA,EAEX,OAAa,CACO,IAAX3R,KAAK0N,GAAGf,KAAkC,IAAX3M,KAAK0N,GAAGf,KAAiC,IAAX3M,KAAK0N,GAAGf,KAAgC,IAAX3M,KAAK0N,GAAGf,KACnF,IAAf3M,KAAK2N,OAAOhB,KAAsC,IAAf3M,KAAK2N,OAAOhB,MAGhD3M,KAAK4N,OAAS5N,KAAK0N,GACnB1N,KAAK0N,GAAKT,EAAmBpM,KAUjC,OANe,IAAXb,KAAK0N,GAAGf,IACP,EAGGxL,EAAWyQ,SAAS5R,KAAKwN,UAAUxN,KAAKwN,UAAUxP,OAAS,GAAG2O,KAAK3M,KAAK0N,GAAGf,MAG/E,KAAA,EAEI,GADAgF,EAAM3R,KAAK6R,SAEP,OAAOF,EAEX,MACJ,KAAA,EAEI,GADAA,EAAM3R,KAAK8R,QAEP,OAAOH,EAEX,MACJ,KAAA,EACI,OAAgC,IAA5B3R,KAAKuN,YAAYvP,OACV,eAEJ,GACX,KAAA,EACI,MAAO,cACX,KAAA,EACI,MAAO,gCACX,KAAA,EACI,MAAO,cACX,KAAA,EACI,MAAO,sBAKfmD,EAAAM,UAAAqQ,MAAA,WAAA,IAAApK,EAAA1H,KACJ,GAAe,IAAXA,KAAK0N,GAAGf,IAAqB,CAC7B,IAAMzO,EAAQ8B,KAAK0N,GAAGZ,SAASyC,OAC/B,GAAItO,EAAAA,MAAMU,QAAQzD,KAAW8B,KAAKwG,QAAQ4I,iBACtC,MAAO,cAEX,IAAM1N,EAAO5B,EAAK0C,SAASxC,KAAKQ,YAAatC,EAAO8B,KAAKgC,aAAchC,KAAK0R,iBAAkB1R,KAAKwG,QAAQ4I,kBAC3G,IAAK1N,EACD,MAAO,qBAEXA,EAAKX,MAAQf,KAAK0N,GAAGX,YACrBrL,EAAK1D,OAASgC,KAAK0N,GAAGV,YAChBtL,EAAKQ,UACPR,EAAKQ,SAAS2C,SAAQ,SAAA9C,GAClBA,EAAQhB,MAAQ2G,EAAKgG,GAAGX,YACxBhL,EAAQ/D,OAAS0J,EAAKgG,GAAGV,eAGjChN,KAAKuN,YAAY7O,KAAKgD,GACtB1B,KAAKS,MAAQ,GACbT,KAAKU,QAAU,QAGfV,KAAKwN,UAAU9O,KAAKsB,KAAK0N,IACV,IAAX1N,KAAK0N,GAAGf,MACJ1L,EAAAA,MAAMU,QAAQ3B,KAAKS,OACnBT,KAAKkK,OAAOxL,KAAKsB,KAAKuR,aAGtBvR,KAAKkK,OAAOxL,KAAKsB,KAAKS,OAE1BT,KAAKS,MAAQ,GACTQ,EAAAA,MAAMU,QAAQ3B,KAAKU,SACnBV,KAAKyN,SAAS/O,KAAKsB,KAAKwR,eAGxBxR,KAAKyN,SAAS/O,KAAKsB,KAAKU,SAE5BV,KAAKU,QAAU,IAGvB,OAAOV,KAAK6Q,aAGR1P,EAAAM,UAAA8P,UAAA,WACJ,OAA2B,IAAvBvR,KAAKkK,OAAOlM,OACL,GAEJgC,KAAKkK,OAAOlK,KAAKkK,OAAOlM,OAAS,IAGpCmD,EAAAM,UAAA+P,YAAA,WACJ,OAA6B,IAAzBxR,KAAKyN,SAASzP,OACP,GAEJgC,KAAKyN,SAASzN,KAAKyN,SAASzP,OAAS,IAGxCmD,EAAAM,UAAAsQ,iBAAA,SAAiBvT,EAASqC,GAC9B,OAAIrC,EAAEkF,WAGFlF,EAAEsC,MAAQ,KAGVtC,EAAEqC,MAAQA,IAGVrC,EAAEuF,OAMF5C,EAAAM,UAAAuQ,UAAA,SAAUC,EAAUC,EAAUrR,WAC9BsR,EAAcC,EACdnQ,GAAU,EACd,GAAIjC,KAAK+R,iBAAiBE,EAAIpR,GAC1BuR,EAASH,EACTE,EAASD,MAER,CAAA,IAAIlS,KAAK+R,iBAAiBG,EAAIrR,GAM/B,OAAO,IAAIf,EAAK,CACZU,YAAayR,EAAGzR,YAChBF,IAAK2R,EACLpR,IAAGA,EACHD,IAAKsR,EACLzR,MAAOT,KAAKuR,YACZ7Q,QAASV,KAAKwR,gBAXlBY,EAASF,EACTC,EAASF,EACThQ,GAAU,EAYd,GAAIkQ,EAAOzO,QAAUyO,EAAOtR,MAAQA,GAAOsR,EAAOpO,MAAQ9C,EAAAA,MAAMoR,GAAGF,EAAOzR,SAAW,GAAI0R,EAAO1R,SAAW,IACvG0R,EAAOzR,WAAWwR,EAAQnS,KAAKuR,YAAatP,QAG5C,GAAIkQ,EAAOjQ,aACP,IAAsB,IAAAE,EAAA5E,EAAA2U,EAAOjQ,UAAQG,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAAlC,IAAM8D,EAAOM,EAAAnE,MACdkU,EAAOzR,WAAWoB,EAAS/B,KAAKuR,YAAatP,qGAIzD,OAAOmQ,GAGHjR,EAAAM,UAAAoQ,OAAA,WACJ,IAAIrT,EACAyT,EACAC,EACExE,EAAyB1N,KAAKwN,UAAUxN,KAAKwN,UAAUxP,OAAS,GACtE,OAAQ0P,EAAGf,KACP,KAAA,EAGI,KADAnO,EAAIwB,KAAKuN,YAAY+E,OAEjB,MAAO,eAEX9T,EAAEuF,KAAOvF,EAAEuF,IACX/D,KAAKuN,YAAY7O,KAAKF,GACtB,MACJ,KAAA,EAGI,GAFA0T,EAAKlS,KAAKuN,YAAY+E,QACtBL,EAAKjS,KAAKuN,YAAY+E,SACVJ,EACR,MAAO,eAEXlS,KAAKuN,YAAY7O,KAAKsB,KAAKgS,UAAUC,EAAIC,GAAI,IAC7C,MACJ,KAAA,EAGI,GAFAA,EAAKlS,KAAKuN,YAAY+E,QACtBL,EAAKjS,KAAKuN,YAAY+E,SACVJ,EACR,MAAO,eAEXlS,KAAKuN,YAAY7O,KAAKsB,KAAKgS,UAAUC,EAAIC,GAAI,IAC7C,MACJ,KAAA,EAEI,KADA1T,EAAIwB,KAAKuN,YAAY+E,OAEjB,MAAO,eAEX9T,EAAEsC,KAAOG,EAAAA,MAAM2O,MAAM5P,KAAKyP,gBAAgB/B,EAAGZ,WAC7C9M,KAAKuN,YAAY7O,KAAKF,GACtB,MACJ,KAAA,EAGI,GAFA0T,EAAKlS,KAAKuN,YAAY+E,QACtBL,EAAKjS,KAAKuN,YAAY+E,SACVJ,EACR,MAAO,eAEX,IAAKA,EAAGxO,QAAUwO,EAAG/P,eAAiB8P,EAAGvO,QAAUuO,EAAG9P,cAAgB+P,EAAGnO,KAAOkO,EAAGlO,MAAQ9C,EAAAA,MAAMqB,KAAK4P,EAAGzR,OAAS,GAAIwR,EAAGxR,OAAS,IAC9H,MAAO,gBAEXjC,EAAI,IAAIsB,EAAK,CACTU,YAAayR,EAAGzR,YAChBF,IAAK2R,EACLpR,KAAK,EACLD,IAAKsR,EACLzR,MAAOT,KAAKuR,YACZ7Q,QAASV,KAAKwR,iBAEhB1Q,KAAOG,EAAAA,MAAM2O,MAAM5P,KAAKyP,gBAAgB/B,EAAGZ,WAC7C9M,KAAKuN,YAAY7O,KAAKF,GACtB,MACJ,KAAA,EAEI,GADAwB,KAAKwN,UAAU8E,MACY,IAAvBtS,KAAKkK,OAAOlM,OACZ,MAAO,gBAEX,GAAgC,IAA5BgC,KAAKuN,YAAYvP,OACjB,MAAO,eAEX,IAAMyC,EAAQT,KAAKkK,OAAOoI,MACpB5R,EAAUV,KAAKyN,SAAS6E,OAE9B9T,EAAIwB,KAAKuN,YAAYvN,KAAKuN,YAAYvP,OAAS,IACzC0F,SACEzC,EAAAA,MAAMU,QAAQnD,EAAEiC,SAChBjC,EAAEiC,MAAQA,GAEVQ,EAAAA,MAAMU,QAAQnD,EAAEkC,WAChBlC,EAAEkC,QAAUA,IAK5BV,KAAKwN,UAAU8E,YAx3BLnR,EAAAqE,oBAAsB,IACrBrE,EAAAyQ,SAAoB,CAInB,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,qBCzsDpB,SAAAW,YASIA,EAAA9Q,UAAAe,SAAA,SAAS/B,EAAevC,EAAewC,GAEnC,OADAD,EAAQT,KAAKwS,YAAY/R,EAAOC,IACjB,KAAKS,EAAWyE,OAAO1H,IAS1CqU,EAAA9Q,UAAAgR,gBAAA,SAAgBhS,EAAevC,EAAgBwC,GAE3C,OADAD,EAAQT,KAAKwS,YAAY/R,EAAOC,IACjB,KAAKS,EAAWyE,OAAO3E,EAAAA,MAAMyR,WAAWxU,KAW3DqU,EAAA9Q,UAAAkR,kBAAA,SACIlS,EACAc,EACArD,EACAwC,GAWA,OATAD,EAAQT,KAAKwS,YAAY/R,EAAOC,GAE7BO,EAAAA,MAAMjC,SAASd,KACdA,EAAQiD,EAAWyE,OAAO1H,KAE3B+C,EAAAA,MAAMzB,OAAOtB,IAAU+C,EAAAA,MAAMtB,SAASzB,MACrCA,EAAQ+C,EAAAA,MAAMyR,WAAWxU,IAGnBuC,EAAK,IAAIc,EAAQ,IAAIrD,GAUnCqU,EAAA9Q,UAAAmR,aAAA,SAAanS,EAAeJ,EAAkBK,GAE1C,OADAD,EAAQT,KAAKwS,YAAY/R,EAAOC,IACjB,MAAML,EAAOwS,KAAI,SAAAC,GAAK,OAAA3R,EAAWyE,OAAOkN,MAAI/M,KAAK,KAAI,KAWxEwM,EAAA9Q,UAAAsR,cAAA,SACItS,EACAuS,EACAC,EACAvS,GAGA,OADAD,EAAQT,KAAKwS,YAAY/R,EAAOC,IACjB,MAAMO,EAAAA,MAAMyR,WAAWM,GAAK,KAAK/R,EAAAA,MAAMyR,WAAWO,GAAG,KAUxEV,EAAA9Q,UAAAyR,eAAA,SAAezS,EAAevC,EAAewC,GAEzC,OADAD,EAAQT,KAAKwS,YAAY/R,EAAOC,IACjB,MAAMS,EAAWyE,OAAO1H,IAQ3CqU,EAAA9Q,UAAA0R,eAAA,SAAe1Q,GACX,MAAO,WAAWtB,EAAWyE,OAAOnD,IAWxC8P,EAAA9Q,UAAA2R,YAAA,SAAY3S,EAAeJ,EAAgCK,GAEvD,OADAD,EAAQT,KAAKwS,YAAY/R,EAAOC,IACjB,MAAMV,KAAKqT,mBAAmBhT,EAAQ,OAAM,KAY/DkS,EAAA9Q,UAAA6R,WAAA,SAAW7S,EAAeJ,EAAgCK,GAEtD,OADAD,EAAQT,KAAKwS,YAAY/R,EAAOC,IACjB,MAAMV,KAAKqT,mBAAmBhT,EAAQ,MAAK,KAQtDkS,EAAA9Q,UAAA4R,mBAAA,SAAmBhT,EAAgCkB,GACvD,OAAOlB,EAAOwS,KAAI,SAAAC,GACd,OAAI7R,EAAAA,MAAMjC,SAAS8T,GACR3R,EAAWyE,OAAOkN,GAEzBA,EAAEpS,QACQS,EAAWyE,OAAOkN,EAAEpS,SAAQ,IAAIS,EAAWyE,OAAO3E,EAAAA,MAAMyR,WAAWI,EAAE5U,QAE5EiD,EAAWyE,OAAO3E,EAAAA,MAAMyR,WAAWI,EAAE5U,WAC7C6H,KAAK,IAAIxE,EAAS,MAQzBgR,EAAA9Q,UAAA8R,YAAA,SAAY7R,GACR,MAAO,QAAQA,EAAI,KAQvB6Q,EAAA9Q,UAAA+R,aAAA,SAAaC,GACT,OAAIA,EAAMzV,QAAU,EACTyV,EAAM,IAAM,GAEhB,IAAIA,EAAM1N,KAAK,UAAS,KASnCwM,EAAA9Q,UAAAiS,cAAA,SAAcD,GACV,OAAIA,EAAMzV,QAAU,EACTyV,EAAM,IAAM,GAEhB,IAAIA,EAAM1N,KAAK,WAAU,KASpCwM,EAAA9Q,UAAAkS,cAAA,SAAclT,EAAemT,EAAgCC,GAIzD,OAHI5S,EAAAA,MAAMwK,QAAQmI,KACdA,EAAQ,CAACA,IAEO,IAAjBA,EAAM5V,OACE,GAEJ6V,EAAgB7T,KAAKoT,YAAY3S,EAAOmT,GAAS5T,KAAKsT,WAAW7S,EAAOmT,IASnFrB,EAAA9Q,UAAAqS,oBAAA,SAAoBC,EAA0BH,EAA4CC,GAItF,GAHI5S,EAAAA,MAAMwK,QAAQmI,KACdA,EAAQ,CAACA,IAEVG,EAAYC,qBAAsB,CACjC,IAAMP,EAAQG,EAAMf,KAAI,SAAA/U,GAAK,OAAAA,EAAEI,MAAMoI,cACrC,OAAOuN,EAAgB7T,KAAK0T,cAAcD,GAASzT,KAAKwT,aAAaC,GAGrE,IAAMQ,EAASjU,KAAKkU,aAAaN,EAAOG,EAAY1U,QACpD,OAAOW,KAAK2T,cAAcI,EAAY9U,OAAQgV,EAAQJ,IAUtDtB,EAAA9Q,UAAA+Q,YAAA,SAAY/R,EAAeC,GAI/B,OAHGA,IACCD,EAAQ,GAAGA,EAAQU,EAAWyE,OAAOlF,IAElCD,GASH8R,EAAA9Q,UAAAyS,aAAA,SAAaN,EAA0BvU,GAC3C,OAAGA,EACQuU,EAAMf,KAAI,SAAA/U,GACb,MAAO,CACHI,MAAQJ,EAA0BqW,MAAQ,IAC1CzT,QAAS5C,EAAE4C,SAAW5C,EAAEI,UAI7B0V,yCApPFrB,wCAAAA,EAAW6B,QAAX7B,EAAW8B,KAAAC,WAFR,aCHHC,EAAsB,yBA4C/B,SAAAC,EACWtE,GAAAlQ,KAAAkQ,KAAAA,SARJsE,EAAAC,KAAP,SAAYC,GACR,OAAKA,EAGEA,EAAMD,OAFFC,GAYfpX,OAAAkE,eAAIgT,EAAA/S,UAAA,eAAY,KAAhB,WACI,OAAKR,EAAAA,MAAMU,QAAQ3B,KAAKyC,SAGpBzC,KAAK2U,WAAW,2CAYxBH,EAAA/S,UAAAmT,UAAA,SAAUlT,EAAcmT,GACpB,OAAO7U,KAAK8U,WAAW,CACnBC,WAAYrT,EACZmT,MAAOA,GAAS,MAOxBL,EAAA/S,UAAAqT,WAAA,SAAWE,GAIP,OAHKhV,KAAKgV,SACNhV,KAAKgV,OAAS,IAEXhV,KAAKgV,OAAOtW,KAAKsW,IAM5BR,EAAA/S,UAAAwT,UAAA,WACI,GAAKjV,KAAKgV,OAGV,OAAOhV,KAAKgV,OAAO1C,OASvBkC,EAAA/S,UAAAyT,aAAA,SAAaC,EAA+BC,GACxC,QADwC,IAAAA,IAAAA,GAAA,GACnCpV,KAAKgV,OAGV,GAAI/T,EAAAA,MAAMjC,SAASmW,GAEf,IAAK,IAAIrX,EAAIkC,KAAKgV,OAAOhX,OAAS,EAAGF,GAAK,EAAGA,IAAK,CAC9C,IAAMuX,EAAUrV,KAAKgV,OAAOlX,GAC5B,GAAImD,EAAAA,MAAMqB,KAAK+S,EAAQR,MAAOM,GAAe,CAEzC,GADAnV,KAAKgV,OAAOM,OAAOxX,EAAG,GACK,IAAvBkC,KAAKgV,OAAOhX,OAEZ,mBADOgC,KAAKgV,OAGhB,IAAKI,EACD,YAKX,CACD,GAAID,EAAe,GAAKA,GAAgBnV,KAAKgV,OAAOhX,OAChD,OAEJgC,KAAKgV,OAAOM,OAAOH,EAAc,GACN,IAAvBnV,KAAKgV,OAAOhX,eACLgC,KAAKgV,SAWxBR,EAAA/S,UAAA8T,cAAA,SAAcxN,EAAeiN,GACpBhV,KAAKgV,QAGVhV,KAAKgV,OAAOM,OAAOvN,EAAO,EAAGiN,IASjCR,EAAA/S,UAAA+T,gBAAA,SAAgBX,EAAeY,WAC3B,QAD2B,IAAAA,IAAAA,EAAA,IACtBzV,KAAKgV,OACN,OAAQ,EAEZ,IAAIjN,EAAQ,EACR2N,EAAe,EACfC,GAAc,MAClB,IAAqB,IAAAvT,EAAA5E,EAAAwC,KAAKgV,QAAM3S,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAA7B,IAAM+W,EAAM3S,EAAAnE,MACb,GAAI+C,EAAAA,MAAMqB,KAAKuS,EAAOG,EAAOH,OAAQ,CAEjC,GADAc,EAAa5N,EACT2N,IAAiBD,EACjB,MAEJC,IAEJ3N,sGAEJ,OAAO4N,GASXnB,EAAA/S,UAAAkT,WAAA,SAAWE,EAAee,QAAA,IAAAA,IAAAA,GAAA,GACtB,IAAMC,EAAmB7V,KAAKwV,gBAAgBX,EAAOe,GAAW,EAAI,GACpE,OAAOC,GAAoB,EAAI7V,KAAKgV,QAAUhV,KAAKgV,OAAOa,QAAoB3V,GAMlFsU,EAAA/S,UAAAqU,WAAA,WACI,GAAK9V,KAAKgV,OAGV,OAAOhV,KAAKgV,OAAOhV,KAAKgV,OAAOhX,OAAS,IAM5CV,OAAAkE,eAAIgT,EAAA/S,UAAA,eAAY,KAAhB,WACI,OAAKzB,KAAKgV,OAGHhV,KAAKgV,OAAOhX,OAFR,mCAWfwW,EAAA/S,UAAAsU,QAAA,SAAQrU,EAAcqS,GAIlB,OAHK/T,KAAKgW,MAAS/U,EAAAA,MAAMwK,QAAQzL,KAAKgW,QAClChW,KAAKgW,KAAO,IAEThW,KAAKgW,KAAKtX,KAAK,CAClBqW,WAAYrT,EACZqS,YAAWA,KAOnBS,EAAA/S,UAAA2P,MAAA,WACI,IAAMlB,EAAOlQ,KAAKkQ,KAClBjP,EAAAA,MAAMgV,YAAYjW,MAClBA,KAAKkQ,KAAOA,GAMhBsE,EAAA/S,UAAAyU,WAAA,WAAA,MAAAxO,EAAA1H,KACUmW,EAA4B,QAAdjI,EAAGlO,KAAKgV,cAAM,IAAA9G,OAAA,EAAAA,EAAE7E,QAClC,SAAC2L,GAAmB,OAAAA,EAAOH,OAASG,EAAOH,MAAM9P,WAAWwP,MAK9D,OAHA4B,MAAAA,GAAAA,EAAgBtR,SACd,SAACmQ,GAAW,OAAAtN,EAAKwN,aAAaF,EAAOH,OAAO,MAEvC7U,MAMXwU,EAAA/S,UAAAgT,KAAA,WACI,IAAMC,EAAQ,IAAIF,EAAMxU,KAAKkQ,MAE7B,OADAjP,EAAAA,MAAMwT,KAAKzU,KAAM0U,GACVA,GAMXF,EAAA/S,UAAA2U,aAAA,WAEI,OADcpW,KAAKyU,OACNyB,cAQjB1B,EAAA/S,UAAA4U,WAAA,SAAWC,GAAX,MAAA5O,EAAA1H,KACI,IAAK,IAAMuW,UADJ,IAAAD,IAAAA,GAAA,GACgBtW,MACfA,KAAKwW,eAAeD,IAActV,EAAAA,MAAMqB,KAAKiU,EAAU,WAAeD,GAAarV,EAAAA,MAAMqB,KAAKiU,EAAU,gBACjGvW,KAAKuW,GAGpB,IAAME,EAA+B,QAAdvI,EAAGlO,KAAKgV,cAAM,IAAA9G,OAAA,EAAAA,EAAE7E,QACrC,SAAC2L,GAAmB,OAAAA,EAAOH,QAAUG,EAAOH,MAAM9P,WAAWwP,MAK/D,OAHAkC,MAAAA,GAAAA,EAAmB5R,SACjB,SAACmQ,GAAW,OAAAtN,EAAKwN,aAAaF,EAAOH,UAEhC7U,MAQXwU,EAAA/S,UAAAiV,aAAA,SAAaJ,GAET,YAFS,IAAAA,IAAAA,GAAA,GACKtW,KAAKyU,OACN4B,WAAWC,IAM5B9B,EAAA/S,UAAAkV,YAAA,iBACI,SAAoB,QAAZzI,EAAClO,KAAKgV,cAAM,IAAA9G,OAAA,EAAAA,EAAE9E,MAAK,SAAA1L,GAAK,OAAAA,EAAEmX,OAASnX,EAAEmX,MAAM9P,WAAWwP,QAQlEC,EAAA/S,UAAAI,SAAA,SAAS+U,GACL5W,KAAKoR,QACL,IAAMsD,EAAQzT,EAAAA,MAAMY,SAAS+U,GAEvB5B,EAASN,EAAMM,OACjB/T,EAAAA,MAAMwK,QAAQuJ,KACdN,EAAMM,OAASA,EAAOnC,KAAY,SAAC3U,GAC/B,OAAI+C,EAAAA,MAAMwK,QAAQvN,GACP,CACH6W,WAAY7W,EAAM,GAClB2W,MAAO3W,EAAM,IAIVA,MAInB,IAAM8X,EAAOtB,EAAMsB,KAenB,OAdI/U,EAAAA,MAAMwK,QAAQuK,KACdtB,EAAMsB,KAAOA,EAAKnD,KAAU,SAAC3U,GACzB,OAAI+C,EAAAA,MAAMwK,QAAQvN,GACP,CACH6W,WAAY7W,EAAM,GAClB6V,YAAa7V,EAAM,IAIhBA,MAInB+C,EAAAA,MAAM4V,OAAO7W,KAAM0U,GACZ1U,MAMXwU,EAAA/S,UAAAqV,qBAAA,WACI,IAAMrZ,EAAS,GAcf,OAbAwD,EAAAA,MAAM8V,MAAMtZ,EAAGuC,MACXA,KAAKgV,SACLvX,EAAEuX,OAAShV,KAAKgV,OAAOnC,KAAc,SAAC3U,GAClC,IAAM8Y,EAAI,CAAC9Y,EAAM6W,YAIjB,OAHI7W,EAAM2W,OACNmC,EAAEtY,KAAKR,EAAM2W,OAEVmC,MAGXhX,KAAKgW,OACLvY,EAAEuY,KAAOhW,KAAKgW,KAAKnD,KAAc,SAAC3U,GAAU,MAAA,CAACA,EAAM6W,WAAY7W,EAAM6V,iBAElE9S,EAAAA,MAAMgW,OAAOxZ,IAMxB+W,EAAA/S,UAAAyV,KAAA,WACI,IAAMC,EAAW,GACjBlW,EAAAA,MAAMmW,aAAaD,EAAKnX,aAEjBmX,EAAIE,YACJF,EAAIG,SACX,IAAMC,EAAMtW,EAAAA,MAAMgW,OAAOE,GACzB,OAAOlW,EAAAA,MAAMuW,OAAOD,sBCxVxB,SAAAE,EACWrL,GADX,IAAA1E,EAAA1H,KACWA,KAAAoM,YAAAA,EAgFXpM,KAAA0X,mBAAqBC,EAAAA,OAAO,MAG5B3X,KAAA4X,eAAiB,SAAAla,GAAK,OAAAgK,EAAKgQ,mBAAmBha,GAAGma,QAAQ,IAAK,aA7EpDJ,EAAAhW,UAAAqW,YAAA,SAAYC,GAClB,SAAI9W,EAAAA,MAAM+W,SAASD,IAAe9W,EAAAA,MAAMzB,OAAOuY,IAAe9W,EAAAA,MAAMwK,QAAQsM,KAUtEN,EAAAhW,UAAAwW,mBAAA,SAAmBF,GACzB,IAAI7Z,EACAwC,EASJ,OARIV,KAAK8X,YAAYC,IACjB7Z,EAAQ6Z,EAAU7Z,MAClBwC,EAAUqX,EAAUrX,SAAW,KAG/BxC,EAAQ6Z,EACRrX,EAAU,IAEP,CAACxC,EAAOwC,IASnB+W,EAAAhW,UAAAyW,eAAA,SAAeha,GACX,OAAO8B,KAAKoM,YAAY+L,cAAc,gBAAgBlX,EAAAA,MAAMmX,YAAYla,EAAQ,MASpFuZ,EAAAhW,UAAA4W,iBAAA,SAAiBC,GACb,IAAMC,EAAoBD,EAAO,KAC3BE,EAAoBD,EAAY,KAChCE,EAAoBD,EAAY,KAChCE,EAAoBD,EAAY,KAChCE,EAAoBD,EAAY,KAElCE,EAAa,8BACXC,EAAc,CAAE3a,MAAOoa,GAqB7B,OApBIQ,KAAKC,IAAIJ,IAAc,GACvBC,EAAa,2BACbC,EAAO3a,MAAQya,GAEVG,KAAKC,IAAIL,IAAc,GAC5BE,EAAa,2BACbC,EAAO3a,MAAQwa,GAEVI,KAAKC,IAAIN,IAAc,GAC5BG,EAAa,2BACbC,EAAO3a,MAAQua,GAEVK,KAAKC,IAAIP,IAAc,GAC5BI,EAAa,2BACbC,EAAO3a,MAAQsa,GAEVM,KAAKC,IAAIR,IAAc,IAC5BK,EAAa,2BACbC,EAAO3a,MAAQqa,GAEZvY,KAAKoM,YAAY+L,cAAcS,EAAYC,IAetDpB,EAAAhW,UAAAuX,YAAA,SAAY9a,GACJ,IAAAgQ,EAAA7P,EAAkBH,EAAMwM,MAAM,KAAI,GAAjCuO,EAAQ/K,EAAA,GAAEgL,EAAGhL,EAAA,GAClB,OAAU+K,EAAQ,IAAIjZ,KAAK4X,gBAAgBsB,IAW/CzB,EAAAhW,UAAA0X,YAAA,SAAYpB,EAAmC9Y,GAA/C,IAAAyI,EAAA1H,KACQkO,EAAA7P,EAAmB2B,KAAKiY,mBAAmBF,GAAU,GAApD7Z,EAAKgQ,EAAA,GAAExN,EAAOwN,EAAA,GACnB,GAAIjP,GAAUA,EAAOma,UACjB,OAAQnY,EAAAA,MAAMmX,YAAYnZ,EAAOma,YAC7B,IAAK,WAAY,OAAOpZ,KAAKkY,eAAeha,GAC5C,IAAK,aACD,GAAI+C,EAAAA,MAAMtB,SAASzB,GACf,OAAO8B,KAAKqY,iBAAiBna,GAEjC,MACJ,IAAK,QACD,GAAG+C,EAAAA,MAAMjC,SAASd,GACd,OAAO8B,KAAKgZ,YAAY9a,GAEvB,GAAG+C,EAAAA,MAAMwK,QAAQvN,GAClB,OAAOA,EAAM2U,KAAI,SAAAC,GACb,OAAApL,EAAKsR,YAAY/X,EAAAA,MAAMjC,SAAS8T,GAAIA,EAAIA,EAAE5U,UAC5C6H,KAAK,MAKvB,GAAIrF,EAIA,OAHIO,EAAAA,MAAMzB,OAAOkB,KACbA,EAAUO,EAAAA,MAAMoY,aAAa3Y,IAE1BV,KAAKoM,YAAY+L,cAAczX,EAAS,CAACxC,MAAKA,IAEzD,GAAI+C,EAAAA,MAAMtB,SAASzB,GAEf,OADM2I,EAAU7G,KAAKoM,YAAYkN,WAAW,sBAEjCtZ,KAAKoM,YAAYmN,WAAW1S,EAAS,CAAC3I,MAAKA,IAG3C8B,KAAKoM,YAAYoN,aAAatb,GAM7C,GAHIe,GAAUF,EAAkBS,OAAOP,IAAWgC,EAAAA,MAAMjC,SAASd,KAC7DA,EAAQ+C,EAAAA,MAAMiG,eAAehJ,IAAUA,GAEvC+C,EAAAA,MAAMzB,OAAOtB,GAAQ,CACrB,IAAIe,GAAWF,EAAkBS,OAAOP,GAGnC,CACD,IAAM4H,EACN,GADMA,EAAU7G,KAAKoM,YAAYkN,WAAW,mBAExC,OAAOtZ,KAAKoM,YAAYmN,WAAW1S,EAAS,CAAC4S,KAAMvb,EAAOwb,KAAMzY,EAAAA,MAAMqL,QAAQpO,KAG9E,IAAIR,EAAIsC,KAAKoM,YAAYuN,WAAWzb,GAIpC,OAH6B,IAAzB+C,EAAAA,MAAMqL,QAAQpO,KACdR,GAAK,KAAOsC,KAAKoM,YAAYwN,WAAW1b,IAErCR,EAZXQ,EAAQ+C,EAAAA,MAAMoY,aAAanb,GAgBnC,GAAI+C,EAAAA,MAAM1B,UAAUrB,GAEhB,OADM2I,EAAU7G,KAAKoM,YAAYkN,WAAW,uBAEjCtZ,KAAKoM,YAAYmN,WAAW1S,EAAS,CAAC3I,MAAKA,IAG3CA,EAAMoI,WAGrB,GAAIrF,EAAAA,MAAMwK,QAAQvN,GAAQ,CACtB,IAAM2b,EAAsB,GAC5B3b,EAAM2G,SAAQ,SAAAiO,GAIV,IAAIgH,EAHAD,EAAU7b,OAAS,GACnB6b,EAAUnb,KAAK,KAOfob,EAJChH,EAGI7R,EAAAA,MAAMzB,OAAOsT,GACb7R,EAAAA,MAAMoY,aAAavG,GAEnB7R,EAAAA,MAAMjC,SAAS8T,GACfA,EAGAA,EAAEpS,SAAWoS,EAAE5U,OAAS,SATxB,SAWT2b,EAAUnb,KAAKob,MAEnB5b,EAAQ2b,EAAU9T,KAAK,IAE3B,OAAK7H,EAGE8B,KAAKoM,YAAY+L,cAAcja,GAF3BA,GAafuZ,EAAAhW,UAAAsY,eAAA,SAAe7b,EAAee,WACpB+a,EAAa/a,EAASgC,EAAAA,MAAMyJ,MAAMzL,EAAO+a,YAAc,GAAI,UAAO9Z,EACxE,IAAK8Z,GAAoC,IAAtBA,EAAWhc,OAC1B,OAAOE,MAGX,IAAwB,IAAA+b,EAAAzc,EAAAwc,GAAUE,EAAAD,EAAAhc,QAAAic,EAAA/b,KAAA+b,EAAAD,EAAAhc,OAAE,CAA/B,IAAMkc,EAASD,EAAAhc,MAChB,OAAQ+C,EAAAA,MAAMmX,YAAY+B,IACtB,IAAK,YAAajc,EAAQ+C,EAAAA,MAAMmZ,YAAYlc,GAAQ,MACpD,IAAK,aAAcA,EAAQ+C,EAAAA,MAAMoZ,aAAanc,GAAQ,MACtD,IAAK,YAAaA,EAAQ+C,EAAAA,MAAMmX,YAAYla,GAAQ,MACpD,IAAK,aAAcA,EAAQ+C,EAAAA,MAAMqZ,aAAapc,GAAQ,MACtD,IAAK,YAAaA,EAAQ+C,EAAAA,MAAMsZ,YAAYrc,GAAQ,MACpD,IAAK,YAAaA,EAAQ+C,EAAAA,MAAMuZ,YAAYtc,GAAQ,MACpD,IAAK,YAAaA,EAAQ+C,EAAAA,MAAMwZ,YAAYvc,GAAQ,MACpD,IAAK,YAAaA,EAAQ+C,EAAAA,MAAMyZ,YAAYxc,sGAGpD,OAAOA,GAUXuZ,EAAAhW,UAAA4F,iBAAA,SAAiB0Q,EAAmC9Y,GAChD,IAAI0b,EAAiB3a,KAAKmZ,YAAYpB,EAAW9Y,GAEjD,OADA0b,EAAiB3a,KAAK+Z,eAAeY,EAAgB1b,IAYzDwY,EAAAhW,UAAAqB,WAAA,SAAW5E,EAAY+N,GACnB,GAAIhL,EAAAA,MAAMjC,SAASd,IACX+N,EACA,OAAQhL,EAAAA,MAAMmX,YAAYnM,IACtB,IAAK,aACD,OAAOjM,KAAK4a,gBAAgB1c,GAAS,GAKrD,OAAOA,GAUXuZ,EAAAhW,UAAAmZ,gBAAA,SAAgBrD,EAAasD,GACzB,YADyB,IAAAA,IAAAA,EAAA,GAClB5Z,EAAAA,MAAM6Z,OAAOvD,EAAKsD,IAS7BpD,EAAAhW,UAAAsZ,UAAA,SAAU7c,GACF,IAACgb,EAAD7a,EAAQ2B,KAAKiY,mBAAmB/Z,GAAM,GAAlC,GACR,OAAG+C,EAAAA,MAAMwK,QAAQyN,GACNA,EAAIrG,KAAI,SAAAC,GAAK,OAAA7R,EAAAA,MAAMjC,SAAS8T,GAAIA,EAAIA,EAAE5U,SAAO6H,KAAK,KAEtDmT,MAAAA,OAAG,EAAHA,EAAK5S,kDA/RPmR,GAAauD,EAAAC,SAAAC,EAAAC,mDAAb1D,EAAarD,QAAbqD,EAAapD,KAAAC,WAFV,0BCyMZ,SAAA8G,EACiCC,EACtBC,EACAlP,EACAhF,GAHsBpH,KAAAqb,YAAAA,EACtBrb,KAAAsb,cAAAA,EACAtb,KAAAoM,YAAAA,EACApM,KAAAoH,cAAAA,EAnJDpH,KAAAub,QAAU,IAAIC,EAAAA,QAqJfxb,KAAKyb,SACNC,QAAQ/c,MAAM,4BApJPyc,EAAAO,aAAP,SAAoBC,GACxB,IAAKA,EACD,OAAA,EAEJ,OAAQ3a,EAAAA,MAAMmX,YAAYwD,IACtB,IAAK,OACL,IAAK,UAAa,OAAA,EAClB,IAAK,OAAa,OAAA,EAClB,IAAK,WAAa,OAAA,EAClB,IAAK,OAAa,OAAA,EAClB,IAAK,WAAa,OAAA,EAClB,IAAK,UAAa,OAAA,EAClB,IAAK,QAAa,OAAA,EAClB,IAAK,SAAa,OAAA,EAClB,IAAK,QAAa,OAAA,EAClB,IAAK,YAAa,OAAA,GAClB,IAAK,QAAa,OAAA,GAClB,IAAK,UAAa,OAAA,GAClB,IAAK,SAAa,OAAA,GAClB,IAAK,SAAa,OAAA,GAClB,IAAK,MAAa,OAAA,GAClB,QAAkB,OAAA,IAIXR,EAAAS,2BAAP,SAAkCC,GACtC,OAAQA,GACJ,IAAK,IAAK,OAAA,KACV,IAAK,IAAK,OAAA,EACV,IAAK,IAAK,OAAA,EACV,IAAK,IAAK,OAAA,KACV,IAAK,IAAK,OAAA,IACV,IAAK,IAAK,OAAA,KACV,IAAK,IAAK,OAAA,KACV,IAAK,IAAK,OAAA,OACV,IAAK,IAAK,OAAA,QACV,IAAK,IAAK,OAAA,SACV,QAAU,OAAA,IAIHV,EAAAW,qBAAP,SAA4B7c,EAAmB8c,WAC/CC,EAAG,EACP,GAAID,MACA,IAAgB,IAAAE,EAAA1e,EAAAwe,GAAYG,EAAAD,EAAAje,QAAAke,EAAAhe,KAAAge,EAAAD,EAAAje,OAAE,CAAzB,IAAM6d,EAACK,EAAAje,MACR+d,GAAOb,EAAWS,2BAA2BC,qGAGrD,OAAOG,GAGIb,EAAAgB,WAAP,SAAkBlM,EAAc0L,EAAcI,EAAuBK,GACzE,IAAMnd,EAAQkc,EAAWO,aAAaC,GAEtC,MAAO,CACH1L,KAAIA,EACJ0L,KAAIA,EACJI,aAAYA,EACZ9c,MAAKA,EACLC,cANkBic,EAAWW,qBAAqB7c,EAAO8c,GAAgB,IAOzEK,QAAOA,IAORjB,EAAApc,SAAP,SAAgBC,GACZ,OAAOF,EAAkBC,SAASC,IAM/Bmc,EAAAhc,MAAP,SAAaH,GACT,OAAOF,EAAkBK,MAAMH,IAM5Bmc,EAAA/b,OAAP,SAAcJ,GACV,OAAOF,EAAkBM,OAAOJ,IAM7Bmc,EAAA9b,SAAP,SAAgBL,GACZ,OAAOF,EAAkBO,SAASL,IAM/Bmc,EAAA7b,UAAP,SAAiBN,GACb,OAAOF,EAAkBQ,UAAUN,IAMhCmc,EAAA5b,OAAP,SAAcP,GACV,OAAOF,EAAkBS,OAAOP,IAM7Bmc,EAAA3b,SAAP,SAAgBR,GACZ,OAAOF,EAAkBU,SAASR,IAM/Bmc,EAAA1b,UAAP,SAAiBT,GACb,OAAOF,EAAkBW,UAAUT,IAMhCmc,EAAAzb,SAAP,SAAgBV,GACZ,OAAOF,EAAkBY,SAASV,IAM/Bmc,EAAAxb,SAAP,SAAgBX,GACZ,OAAOF,EAAkBa,SAASX,IAM/Bmc,EAAAvb,WAAP,SAAkBZ,GACd,OAAOF,EAAkBc,WAAWZ,IAcxCmc,EAAA3Z,UAAA6a,YAAA,WACItc,KAAKub,QAAQgB,YAMjBjf,OAAAkE,eAAI4Z,EAAA3Z,UAAA,SAAM,KAAV,WACI,OAAOzB,KAAKub,yCAMhBje,OAAAkE,eAAI4Z,EAAA3Z,UAAA,UAAO,KAAX,WACI,OAAOzB,KAAKqb,YAAYmB,qCAM5Blf,OAAAkE,eAAI4Z,EAAA3Z,UAAA,SAAM,KAAV,WACI,OAAOzB,KAAKqb,YAAYoB,wCAGpBrB,EAAA3Z,UAAAib,iBAAA,WACJ,GAAK1c,KAAKwc,IAAV,CAKA,IAAMG,EAAmB3c,KAAKwc,IAAIG,kBAAoB1b,EAAAA,MAAMyJ,MAAM1K,KAAKwc,IAAII,WAAY,KAAK,GAC5F5c,KAAK6c,gBAAkB5b,EAAAA,MAAM6b,SAAkB9c,KAAKwc,IAAIO,QAASJ,GAC5D3c,KAAK6c,iBACNnB,QAAQsB,KAAK,iCAAiChd,KAAKyb,SAEvDzb,KAAK2P,QAAU3P,KAAK6c,qBAThBnB,QAAQsB,KAAK,sBAYb5B,EAAA3Z,UAAAwb,OAAA,SAAOT,GACXxc,KAAKwc,IAAMA,EACXxc,KAAKkd,oCAAoCV,GACzCxc,KAAKmd,SAAWnd,KAAKod,cAAwBpd,KAAKwc,IAAIa,QACtDrd,KAAKsd,eAAiBtd,KAAKod,cAA8Bpd,KAAKwc,IAAIe,cAClEvd,KAAK0c,mBACL1c,KAAKwd,WACLxd,KAAKyd,eAAiBxc,EAAAA,MAAMyJ,MAAM1K,KAAKsd,eAAiBtd,KAAKsd,eAAeG,eAAiB,GAAI,MAG7FrC,EAAA3Z,UAAAyb,oCAAA,SAAoCV,GACnCA,EAIAA,EAAIkB,WAEElB,EAAIkB,aAAeC,EAAAA,uCAC1BjC,QAAQsB,KAAK,2HACiDW,EAAAA,sCADjD,yCAE8BnB,EAAIkB,WAAU,MAJzDhC,QAAQ/c,MAAM,mBAAmB6d,EAAItM,KAAI,qDAJzCwL,QAAQsB,KAAK,wCAiBrB5B,EAAA3Z,UAAA1B,KAAA,WAAA,IAAA2H,EAAA1H,KACI,OAAOA,KAAKsb,cAAcsC,MAAMC,KAC5BhL,EAAAA,KAAI,SAAA2J,GAEA,OADA9U,EAAKuV,OAAOT,GACLA,OAUnBpB,EAAA3Z,UAAAqc,YAAA,SAAYtB,GACJA,GACAxc,KAAKid,OAAOT,IASpBpB,EAAA3Z,UAAAsc,QAAA,SAAQC,GAAR,IAAAtW,EAAA1H,KACUie,EAAaje,KAAKsb,cAAcyC,QAAQ/d,KAAKwc,IAAMxc,KAAKwc,IAAI0B,UAAY,GAAIF,GASlF,OARAC,EAAWE,WACP,SAAAC,GAII,OAHKA,EAASC,UAAYD,EAAS5B,KAC/B9U,EAAKuV,OAAOmB,EAAS5B,KAElB4B,KAGRH,EAAWJ,KAAKhL,EAAAA,KAAI,SAAC3U,GACxB,OAAOwJ,EAAK8U,SAOpBpB,EAAA3Z,UAAA2P,MAAA,WACIpR,KAAKwc,SAAMtc,EACXF,KAAKmd,cAAWjd,EAChBF,KAAK6c,qBAAkB3c,EACvBF,KAAK2P,aAAUzP,EACfF,KAAKse,aAGDlD,EAAA3Z,UAAA8c,cAAA,SAAcC,GAClB,QAASA,KAAaA,EAAQC,WAAaxd,EAAAA,MAAM8D,WAAWyZ,EAAQC,UAAW,YAG3ErD,EAAA3Z,UAAAid,iBAAA,SAAiB/O,GACrB,GAAKA,EAAL,CAGA,IAAMgP,EAAU1d,EAAAA,MAAMyJ,MAAMiF,EAAQiP,cAAe,CAAC,MACpD,GAAuB,IAAnBD,EAAQ3gB,OACR,OAAOgC,KAAKwc,IAAMxc,KAAKwc,IAAImC,QAAQE,OAAI3e,EAGvC,IAAMse,EAAUxe,KAAK8e,SAASH,EAAQ,IACtC,OAAIH,GAAWxe,KAAKue,cAAcC,GACvBxe,KAAKwc,IAAMxc,KAAKwc,IAAImC,QAAQE,OAAI3e,EAEpCse,IAIPpD,EAAA3Z,UAAAsd,uBAAA,SAAuBC,EAA4BR,eACvD,GAAKA,GAAYA,EAAQS,YAGzB,IAAyB,IAAA7c,EAAA5E,EAAAF,OAAO4hB,KAAKV,EAAQS,UAAQ5c,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAAlD,IAAMkhB,EAAU9c,EAAAnE,MACXe,EAASuf,EAAQS,QAAQE,GAE/B,GADAH,EAAU/d,EAAAA,MAAMmX,YAAYnZ,EAAOiR,OAASjR,EACxCA,EAAOod,YACP,IAAoB,IAAAtT,GAAAqW,OAAA,EAAA5hB,EAAAyB,EAAOod,UAAOpT,EAAAF,EAAA9K,QAAAgL,EAAA9K,KAAA8K,EAAAF,EAAA9K,OAAE,CAA/B,IAAMohB,EAAKpW,EAAA/K,MACZ8gB,EAAU/d,EAAAA,MAAMmX,YAAYiH,IAAUpgB,yMAM9Cmc,EAAA3Z,UAAA6d,uBAAA,SAAuBN,EAA4BrP,eACvD,GAAKA,GAAYA,EAAQ4P,aAAgB5P,EAAQ4P,YAAYN,QAA7D,CAGA,IAAMT,EAAUxe,KAAK0e,iBAAiB/O,GACtC,GAAK6O,GAAYA,EAAQS,YAGzB,IAAyB,IAAA7c,EAAA5E,EAAAmS,EAAQ4P,YAAYN,SAAO5c,EAAAD,EAAAnE,QAAAoE,EAAAlE,KAAAkE,EAAAD,EAAAnE,OAAE,CAAjD,IAAMuhB,EAAUnd,EAAAnE,MACjB,GAAIshB,EAAWtP,KAAM,CACjB,IAAMiP,EAAale,EAAAA,MAAMmX,YAAYoH,EAAWtP,MAC5CjR,EAASuf,EAAQS,QAAQE,GAI7B,GAHKlgB,IACDA,EAASmc,EAAWqE,aAAaN,IAEjClgB,EAAQ,CAIR,GAFAA,EAASgC,EAAAA,MAAMwT,KAAKxV,GACpB+f,EAAUG,GAAclgB,EACpBugB,EAAWnD,QAAS,CACpBpd,EAAOod,QAAUpb,EAAAA,MAAMyJ,MAAM8U,EAAWnD,QAAS,CAAC,IAAK,UACvD,IAAoB,IAAAtT,GAAA2W,OAAA,EAAAliB,EAAAyB,EAAOod,UAAOpT,EAAAF,EAAA9K,QAAAgL,EAAA9K,KAAA8K,EAAAF,EAAA9K,OAAE,CAA/B,IAAMohB,EAAKpW,EAAA/K,MACZ8gB,EAAU/d,EAAAA,MAAMmX,YAAYiH,IAAUpgB,qGAI1CugB,EAAW5X,QACX3I,EAAO2I,MAAQ4X,EAAW5X,OAE1B4X,EAAWG,cACX1gB,EAAO0gB,YAAcH,EAAWG,aAEhCH,EAAWpG,YACXna,EAAOma,UAAYoG,EAAWpG,WAE9BoG,EAAWxF,aACX/a,EAAO+a,WAAawF,EAAWxF,YAE/BwF,EAAWvT,SACXhN,EAAOgN,OAASuT,EAAWvT,QAE3BuT,EAAWI,cACX3gB,EAAO2gB,YAAcJ,EAAWI,oHAO1CxE,EAAA3Z,UAAA+b,SAAA,mCAIN,GAHAxd,KAAK6f,eAAiB,GACtB7f,KAAK8f,eAAiB,GACtB9f,KAAK+f,cAAgB,GAChB/f,KAAKwc,IAAV,CAGA,IAAIwC,EAGJ,GAAIhf,KAAKwc,IAAIO,YACT,IAAwB,IAAA9T,EAAAzL,EAAAF,OAAO4hB,KAAKlf,KAAKwc,IAAIO,UAAQ5T,EAAAF,EAAAhL,QAAAkL,EAAAhL,KAAAgL,EAAAF,EAAAhL,OAAE,CAAlD,IAAM+hB,EAAS7W,EAAAjL,MACVyR,EAAU3P,KAAKwc,IAAIO,QAAQiD,GAC7BrQ,IACAA,EAAQc,qBAAuB,IAAIwP,EAAAA,eAAe,yBAA0B,0BAC5EtQ,EAAQc,qBAAqByP,gBAAgBC,QAAQxQ,EAAQyQ,sBAC7DzQ,EAAQc,qBAAqB4P,gBAAgBF,QAAQxQ,EAAQ2Q,sBAC7D3Q,EAAQiB,uBAAyB,IAAIqP,EAAAA,eAAe,4BAA6B,6BACjFtQ,EAAQiB,uBAAuBsP,gBAAgBC,QAAQxQ,EAAQ4Q,wBAC/D5Q,EAAQiB,uBAAuByP,gBAAgBF,QAAQxQ,EAAQ6Q,wBAC3D7Q,EAAQ4P,cACRP,EAAY,GACZhf,KAAK6f,eAAe5e,EAAAA,MAAMmX,YAAYzI,EAAQO,OAAS8O,EACvDhf,KAAKsf,uBAAuBN,EAAWrP,uGAOvD,GAAI3P,KAAKwc,IAAImC,QAAS,CAElB,IAAMH,EAAUxe,KAAKwc,IAAImC,QAAQE,EAC7BL,IACAQ,EAAY,GACZhf,KAAK8f,eAAejB,EAAIG,EACxBhf,KAAK+e,uBAAuBC,EAAWR,QAG3C,IAAwB,IAAAhV,EAAAhM,EAAAF,OAAO4hB,KAAKlf,KAAKwc,IAAImC,UAAQjV,EAAAF,EAAAvL,QAAAyL,EAAAvL,KAAAuL,EAAAF,EAAAvL,OAAE,CAAlD,IAAMwiB,EAAS/W,EAAAxL,MACVwiB,EAAW1gB,KAAKwc,IAAImC,QAAQ1d,EAAAA,MAAMmX,YAAYqI,IAChDC,IACI1gB,KAAKue,cAAcmC,GACG,MAAlBA,EAASxQ,OACTlQ,KAAK8f,eAAe7e,EAAAA,MAAMmX,YAAYsI,EAASxQ,OAASlQ,KAAK8f,eAAejB,IAIhFG,EAAY,GACZhf,KAAK8f,eAAe7e,EAAAA,MAAMmX,YAAYsI,EAASxQ,OAAS8O,EACxDhf,KAAK+e,uBAAuBC,EAAW0B,wGAOvD,IAAMC,EAAe,IAAIC,IACnB3B,EAAUjf,KAAK8f,eAAejB,EACpC,GAAII,MACA,IAAkB,IAAAtV,EAAAnM,EAAAF,OAAO4hB,KAAKD,IAAQ4B,EAAAlX,EAAA1L,QAAA4iB,EAAA1iB,KAAA0iB,EAAAlX,EAAA1L,OAAE,CAEpC,IADMgB,EAASggB,EADL4B,EAAA3iB,QAECme,SAAWpd,EAAOod,QAAQre,OAAS,GACpCqhB,EAAQpgB,EAAOod,QAAQ,KAEzBsE,EAAaG,IAAIzB,EAAOA,yGAKxC,IAAwB,IAAA0B,EAAAvjB,EAAAF,OAAO4hB,KAAKlf,KAAK6f,iBAAemB,EAAAD,EAAA9iB,QAAA+iB,EAAA7iB,KAAA6iB,EAAAD,EAAA9iB,OAAE,CAA/C+hB,EAASgB,EAAA9iB,MAAf,IACK+iB,EAAc,IAAIL,IAAoBD,GACtCO,EAAWlhB,KAAK6f,eAAe5e,EAAAA,MAAMmX,YAAYpY,KAAKmhB,eAAiBnhB,KAAKmhB,eAAejR,KAAO,KACxG,GAAIgR,EAAU,KACV,IAAkB,IAAAE,GAAAlY,OAAA,EAAA1L,EAAAF,OAAO4hB,KAAKgC,KAASG,EAAAD,EAAAnjB,QAAAojB,EAAAljB,KAAAkjB,EAAAD,EAAAnjB,OAAE,CAApC,IACKgB,EAEIogB,EADV,IADMpgB,EAASiiB,EADLG,EAAAnjB,QAECme,SAAWpd,EAAOod,QAAQre,OAAS,GACpCqhB,EAAQpgB,EAAOod,QAAQ,KAEzB4E,EAAYH,IAAIzB,EAAOA,qGAInCrf,KAAK+f,cAAcC,GAAasB,MAAMtO,KAAKiO,EAAY/B,8GAKzD9D,EAAA3Z,UAAA6c,UAAA,WACNte,KAAK6f,eAAiB,GACtB7f,KAAK8f,eAAiB,GACtB9f,KAAK+f,cAAgB,IAMzB3E,EAAA3Z,UAAA2b,cAAA,SAAsClN,GAClC,GAAKlQ,KAAKwc,IAGV,OAAOvb,EAAAA,MAAM6b,SAAmB9c,KAAKwc,IAAI+E,YAAarR,IAM1DkL,EAAA3Z,UAAA+f,QAAA,SAAQtR,GACJ,GAAKlQ,KAAKwc,IAGV,OAAOxc,KAAKwc,IAAIiF,MAAMvR,IAM1B5S,OAAAkE,eAAI4Z,EAAA3Z,UAAA,iBAAc,KAAlB,WACI,OAAOzB,KAAK6c,iDAMhBvf,OAAAkE,eAAI4Z,EAAA3Z,UAAA,UAAO,KAAX,WACI,OAAMzB,KAAK0hB,SACA1hB,KAAK0hB,SAET1hB,KAAK6c,qBAMhB,SAAY3e,GACR,GAAIA,IAAU8B,KAAK0hB,SAAU,CACzB,IAAMC,EAAW3hB,KAAK0hB,SACtB1hB,KAAK0hB,SAAWxjB,EAChB8B,KAAKub,QAAQtd,KAAK,CAAC2d,KAAM,gBAAiB9X,QAAS9D,KAAK0hB,SAAUC,SAAUA,sCAOpFvG,EAAA3Z,UAAAmgB,WAAA,SAAW1R,GACP,OAAOlQ,KAAKwc,IAAMxc,KAAKwc,IAAIO,QAAQ9b,EAAAA,MAAMmX,YAAYlI,SAAShQ,GAMlEkb,EAAA3Z,UAAAogB,WAAA,SAAW3R,GACP,IAAMP,EAAWO,EAA6BlQ,KAAK4hB,WAAW1R,GAAtClQ,KAAKmhB,eAC7B,OAAIxR,GACA3P,KAAK2P,QAAUA,GACR,IAGP+L,QAAQsB,KAAK,kCAAkC9M,EAAI,qBAC5C,IAOf5S,OAAAkE,eAAI4Z,EAAA3Z,UAAA,SAAM,KAAV,WACI,OAAKzB,KAAK2P,SAGH3P,KAAK+f,cAAc9e,EAAAA,MAAMmX,YAAYpY,KAAK2P,QAAQO,QAF9C,oCAQfkL,EAAA3Z,UAAAqgB,iBAAA,SAAiB5R,GACb,GAAKlQ,KAAK2P,SAAY3P,KAAK2P,QAAQoS,aAGnC,OAAO/hB,KAAK2P,QAAQoS,aAAa3Y,MAAK,SAAClL,GAAU,OAAA+C,EAAAA,MAAMqB,KAAK4N,EAAMhS,EAAMgS,UAM5EkL,EAAA3Z,UAAAqd,SAAA,SAAS5O,GACL,GAAKlQ,KAAKwc,IAGV,OAAOvb,EAAAA,MAAM6b,SAAkB9c,KAAKwc,IAAImC,QAASzO,IAMrDkL,EAAA3Z,UAAA8B,UAAA,SAAU2M,WACN,GAAKA,GAGAlQ,KAAK2P,QAAV,CAIA,IAAI1Q,EACA+iB,EAAgBhiB,KAAK6f,eAAe5e,EAAAA,MAAMmX,YAAYpY,KAAK2P,QAAQO,OACvE,GAAI8R,IACA/iB,EAAS+iB,EAAc/gB,EAAAA,MAAMmX,YAAYlI,KAErC,OAAOjR,EAIf,IAAM0f,EAAU1d,EAAAA,MAAMyJ,MAAM1K,KAAK2P,QAAQiP,cAAe,CAAC,MACnDqD,EAAgC,IAAnBtD,EAAQ3gB,YAAekC,EAAYF,KAAK8e,SAASH,EAAQ,IAC5E,GAAuB,IAAnBA,EAAQ3gB,QAAmBikB,GAAcjiB,KAAKue,cAAc0D,IAE5D,IADAD,EAAgBhiB,KAAK8f,eAAejB,KAEhC5f,EAAS+iB,EAAc/gB,EAAAA,MAAMmX,YAAYlI,KAErC,OAAOjR,WAKf,IAAoB,IAAAijB,EAAA1kB,EAAAmhB,GAAOwD,EAAAD,EAAAjkB,QAAAkkB,EAAAhkB,KAAAgkB,EAAAD,EAAAjkB,OAAE,CAAxB,IAAM8J,EAAKoa,EAAAjkB,MAEZ,IADA8jB,EAAgBhiB,KAAK8f,eAAe7e,EAAAA,MAAMmX,YAAYrQ,OAElD9I,EAAS+iB,EAAc/gB,EAAAA,MAAMmX,YAAYlI,KAErC,OAAOjR,oGAOvB,OADAA,EAASmc,EAAWqE,aAAaxe,EAAAA,MAAMmX,YAAYlI,WACnD,IAYJkL,EAAA3Z,UAAA2gB,sBAAA,SAAsBnjB,GAClB,OAAIA,GACIA,EAAOod,SAAWpd,EAAOod,QAAQre,OAAS,EACnCiB,EAAOod,QAAQ,GAGvB,IASHjB,EAAA3Z,UAAA4gB,cAAA,SAAcpjB,EAAmB4b,GACrC,YADqC,IAAAA,IAAAA,EAAA,IACjC5b,EACOA,EAAOiR,KAEX2K,GASXO,EAAA3Z,UAAA6gB,eAAA,SAAerjB,EAAmB4b,GAC9B,QAD8B,IAAAA,IAAAA,EAAA,IAC1B5b,EAAQ,CACR,IAAMogB,EAAQrf,KAAKoiB,sBAAsBnjB,GACzC,GAAIogB,EACA,OAAOA,EAGf,OAAOxE,GAMXO,EAAA3Z,UAAA6B,kBAAA,SAAkB4M,GACd,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,OAAOlQ,KAAKqiB,cAAcpjB,EAAQiR,GAAQ,KAM9CkL,EAAA3Z,UAAAgH,mBAAA,SAAmByH,GACf,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,OAAOlQ,KAAKsiB,eAAerjB,EAAQiR,GAAQ,KAU/CkL,EAAA3Z,UAAA8gB,UAAA,SAAU9f,EAAc+D,GACpB,OAAOrF,EAAWkQ,MAAM5O,EAAM,CAACY,WAAYrD,KAAMoH,cAAepH,KAAKoH,cAAegF,YAAapM,KAAKoM,aAAc5F,IASxH4U,EAAA3Z,UAAA+gB,iBAAA,SAAiB/hB,EAAevC,GAC5B,GAAI+C,EAAAA,MAAMzB,OAAOtB,GACb,OAAO+C,EAAAA,MAAMoY,aAAanb,GAE9BA,GAAgB,GAChB,IAAMe,EAASe,KAAKuD,UAAU9C,GAC9B,OAAIxB,IAAWmc,EAAWxb,SAASX,GAExBkC,EAAWyE,OAAO1H,GAEtBA,GASXkd,EAAA3Z,UAAAoG,SAAA,SAASqI,EAAc2K,GACnB,IAAM5b,EAASe,KAAKuD,UAAU2M,GAC9B,GAAIjR,EAAQ,CACR,IAAM2I,EAAQwT,EAAWhc,MAAMH,GAAUA,EAAO0gB,YAAc1gB,EAAO2I,MACrE,GAAIA,EACA,OAAOA,EAGf,OAAK3G,EAAAA,MAAMC,YAAY2Z,GAGhB3K,EAFI2K,GAWfO,EAAA3Z,UAAAghB,iBAAA,SAAiBvS,EAAc2K,GAC3B,IAAM5b,EAASe,KAAKuD,UAAU2M,GAC9B,OAAIjR,GAAUA,EAAO2I,MACV3I,EAAO2I,MAEb3G,EAAAA,MAAMC,YAAY2Z,GAGhB3K,EAFI2K,GAWfO,EAAA3Z,UAAAihB,eAAA,SAAexS,EAAc2K,GACzB,IAAM5b,EAASe,KAAKuD,UAAU2M,GAC9B,OAAIjR,GAAUA,EAAO0gB,YACV1gB,EAAO0gB,YAEb1e,EAAAA,MAAMC,YAAY2Z,GAGhB3K,EAFI2K,GAQfO,EAAA3Z,UAAAzC,SAAA,SAASkR,GACL,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAWpc,SAASC,IAM3Cmc,EAAA3Z,UAAArC,MAAA,SAAM8Q,GACF,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAWhc,MAAMH,IAMxCmc,EAAA3Z,UAAApC,OAAA,SAAO6Q,GACH,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAW/b,OAAOJ,IAMzCmc,EAAA3Z,UAAAnC,SAAA,SAAS4Q,GACL,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAW9b,SAASL,IAM3Cmc,EAAA3Z,UAAAlC,UAAA,SAAU2Q,GACN,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAW7b,UAAUN,IAM5Cmc,EAAA3Z,UAAAjC,OAAA,SAAO0Q,GACH,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAW5b,OAAOP,IAMzCmc,EAAA3Z,UAAAhC,SAAA,SAASyQ,GACL,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAW3b,SAASR,IAM3Cmc,EAAA3Z,UAAA/B,UAAA,SAAUwQ,GACN,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAW1b,UAAUT,IAM5Cmc,EAAA3Z,UAAA9B,SAAA,SAASuQ,GACL,OAAOlQ,KAAKN,UAAUwQ,IAASlQ,KAAKP,SAASyQ,IAMjDkL,EAAA3Z,UAAA7B,SAAA,SAASsQ,GACL,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAWxb,SAASX,IAM3Cmc,EAAA3Z,UAAA5B,WAAA,SAAWqQ,GACP,IAAMjR,EAASe,KAAKuD,UAAU2M,GAC9B,QAASjR,GAAUmc,EAAWvb,WAAWZ,IAO7Cmc,EAAA3Z,UAAAkhB,iBAAA,SAAiBC,GAIb,OAHI5iB,KAAKqb,YAAYwH,YAAgBD,IAAQ3hB,EAAAA,MAAM6hB,cAAcF,KAC7DA,EAAM3hB,EAAAA,MAAM8hB,OAAO/iB,KAAKyc,OAAQmG,IAE7BA,GAMXtlB,OAAAkE,eAAI4Z,EAAA3Z,UAAA,WAAQ,KAAZ,WACI,OAAOzB,KAAK2iB,iBAAiB1hB,EAAAA,MAAM8hB,OAAO/iB,KAAKqb,YAAY2H,gBAAkB,gDAv3BlE5H,EAAAqE,aAAgC,CAC3CwD,GAAI7H,EAAWgB,WAAW,KAAM,UAChC3Z,KAAM2Y,EAAWgB,WAAW,OAAQ,WACpC8G,kBAAmB9H,EAAWgB,WAAW,oBAAqB,MAAO,MACrE+G,cAAe/H,EAAWgB,WAAW,gBAAiB,WACtDgH,gBAAiBhI,EAAWgB,WAAW,kBAAmB,UAC1DiH,kBAAmBjI,EAAWgB,WAAW,oBAAqB,OAC9DkH,eAAgBlI,EAAWgB,WAAW,iBAAkB,OACxDmH,0BAA2BnI,EAAWgB,WAAW,4BAA6B,WAC9EoH,SAAUpI,EAAWgB,WAAW,WAAY,OAC5CqH,oBAAqBrI,EAAWgB,WAAW,sBAAuB,WAClEsH,kBAAmBtI,EAAWgB,WAAW,oBAAqB,OAC9DuH,eAAgBvI,EAAWgB,WAAW,iBAAkB,WACxDwH,WAAYxI,EAAWgB,WAAW,aAAc,WAChDyH,YAAazI,EAAWgB,WAAW,cAAe,eAAWlc,EAAW,CAAC,kDAhBpEkb,GAAUJ,EAAAC,SAyLP6I,EAAAA,cAAY9I,EAAAC,SAAA8I,EAAAC,eAAAhJ,EAAAC,SAAAC,EAAAC,aAAAH,EAAAC,SAAAxD,yCAzLf2D,EAAUhH,QAAVgH,EAAU/G,KAAAC,WAFP,0BClBZ,SAAA2P,EACkC5I,GAAArb,KAAAqb,YAAAA,SAI1B4I,EAAAxiB,UAAAyiB,gBAAA,SAAgBtB,GACpB,OAAO3hB,EAAAA,MAAM8D,WAAW6d,EAAK5iB,KAAKqb,YAAY8I,UAG1CF,EAAAxiB,UAAA2iB,WAAA,SAAWjN,GACf,OAAQlW,EAAAA,MAAM+W,SAASb,IAAQlW,EAAAA,MAAMwK,QAAQ0L,MAAUlW,EAAAA,MAAMojB,cAAclN,KAASlW,EAAAA,MAAMqjB,OAAOnN,KAC5FlW,EAAAA,MAAMjC,SAASmY,MAAUA,aAAeoN,EAAAA,aAIzCN,EAAAxiB,UAAA+iB,kBAAA,SAAkBxG,GACtB,GAAKA,EAAL,CAGA,IAAIyG,EACJ,GAAIxjB,EAAAA,MAAMwK,QAAQuS,GACdyG,EAAezG,OAEd,GAAI/c,EAAAA,MAAM+W,SAASgG,GAAc,CAClC,IAAM0G,EAAc1G,EACpB,GAAI0G,EAAY1G,aAAe0G,EAAYC,cACvC,OAAOD,EAEXD,EAAe,CAACzG,GAEpB,MAAO,CACHA,YAAayG,KAQbR,EAAAxiB,UAAAmjB,aAAA,SAAaF,SACXG,EAAY7kB,KAAK8kB,eACC,QAAxB5W,EAAAwW,MAAAA,OAAW,EAAXA,EAAa1G,mBAAW,IAAA9P,GAAAA,EAAErJ,SAAQ,SAAAkgB,GAC1BA,EAAMC,SACND,EAAMC,OAAS,IAEnBD,EAAMC,OAAO,cAAgBH,MAQ7BZ,EAAAxiB,UAAAqjB,aAAA,WAKJ,OAJI9kB,KAAK6kB,YAAa7kB,KAAKilB,mBACvBjlB,KAAK6kB,UAAY5jB,EAAAA,MAAMikB,QAE3BllB,KAAKmlB,aAAe,IAAIC,KACjBplB,KAAK6kB,WAMRZ,EAAAxiB,UAAAwjB,eAAA,WAGJ,OAFoB,IAAIG,MAAO9Y,UAAYtM,KAAKmlB,aAAa7Y,UAExC,KAQf2X,EAAAxiB,UAAA4jB,kBAAA,SAAkBX,KAO5BT,EAAAxiB,UAAA6jB,UAAA,SAAUC,EAA2BtnB,GAMjC,OALI+B,KAAKkkB,gBAAgBqB,EAAQ3C,MAAQ5iB,KAAKokB,WAAWmB,EAAQC,QAC7DD,EAAQC,KAAKC,aAAezlB,KAAKwkB,kBAAkBe,EAAQC,KAAKC,cAChEzlB,KAAK4kB,aAAaW,EAAQC,KAAKC,cAC/BzlB,KAAKqlB,kBAAkBE,EAAQC,KAAKC,eAEjCxnB,EAAKynB,OAAOH,0CA9FdtB,GAAgBjJ,EAAAC,SAOb6I,EAAAA,oDAPHG,EAAgB7P,QAAhB6P,EAAgB5P,KAAAC,WAFb,SCXhB,IAAMqR,EAA6B,KC4BnC,6CAAaC,iEAAAA,IAAcC,UAAAjnB,EAHhB+mB,GACNG,QAAA,CAXQ,CACLC,EAAAA,WACAC,EAAAA,WACAC,EAAAA,uFAUKL,EAAc,CAAAE,QAAA,CAZnBC,EAAAA,WACAC,EAAAA,WACAC,EAAAA","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {CCColumn, EngineType, EngineTypeModifier} from \"@sinequa/core/web-services\";\n\n/**\n * @ignore\n *\n * Used internally to avoid circular references between ExprParser, AppService and FormatService.\n * Do not export from the app-utils module.\n */\nexport class AppServiceHelpers {\n    static isString(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.string) {\n            return true;\n        }\n        if (column.eType === EngineType.csv && (column.eTypeModifier & EngineTypeModifier.x) === EngineTypeModifier.x) {\n            return true;\n        }\n        return false;\n    }\n\n    static isCsv(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.csv && (column.eTypeModifier & EngineTypeModifier.x) !== EngineTypeModifier.x) {\n            return true;\n        }\n        return false;\n    }\n\n    static isTree(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.csv && (column.eTypeModifier & EngineTypeModifier.t) === EngineTypeModifier.t) {\n            return true;\n        }\n        return false;\n    }\n\n    static isEntity(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.csv && (column.eTypeModifier & (EngineTypeModifier.e | EngineTypeModifier.l)) === (EngineTypeModifier.e | EngineTypeModifier.l)) {\n            return true;\n        }\n        return false;\n    }\n\n    static isBoolean(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.bool) {\n            return true;\n        }\n        return false;\n    }\n\n    static isDate(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.date || column.eType === EngineType.dateTime || column.eType === EngineType.time) {\n            return true;\n        }\n        return false;\n    }\n\n    static isDouble(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.double || column.eType === EngineType.float) {\n            return true;\n        }\n        return false;\n    }\n\n    static isInteger(column: CCColumn | undefined): boolean {\n        if (!column) {\n            return false;\n        }\n        if (column.eType === EngineType.integer || column.eType === EngineType.unsigned) {\n            return true;\n        }\n        return false;\n    }\n\n    static isNumber(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isInteger(column) || AppServiceHelpers.isDouble(column);\n    }\n\n    static isScalar(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isNumber(column) || AppServiceHelpers.isDate(column) || AppServiceHelpers.isBoolean(column);\n    }\n\n    static isSortable(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isString(column) || AppServiceHelpers.isScalar(column) ||\n            (AppServiceHelpers.isCsv(column) && !!column && ((column.eTypeModifier & EngineTypeModifier.l) === EngineTypeModifier.l));\n    }\n}\n","import {Utils, MapOf, IRef, FieldValue} from \"@sinequa/core/base\";\nimport {AppService} from \"../app.service\";\nimport {AppServiceHelpers} from \"../app-service-helpers\";\nimport {CCColumn, EngineType} from \"@sinequa/core/web-services\";\nimport {IntlService} from \"@sinequa/core/intl\";\nimport {FormatService} from \"../format.service\";\n\n/**\n * Describes a context for processing expressions\n */\nexport interface ExprContext {\n    appService: AppService;\n    formatService: FormatService;\n    intlService: IntlService;\n    disallowFulltext?: boolean;\n}\n\n/**\n * The operators accepted in fielded search expressions\n */\nexport const enum ExprOperator {\n    none,\n    eq,\n    gt,\n    gte,\n    lt,\n    lte,\n    neq,\n    regex,\n    like,\n    contains,\n    in,\n    between\n}\n\n/**\n * The range operators accepted in fielded search expressions\n */\nexport const enum ExprRange {\n    none,\n    gteLte,\n    gteLt,\n    gtLte,\n    gtLt\n}\n\n/**\n * An object containing the data necessary to format an `Expr` using\n * [IntlService.formatMessage]{@link IntlService#formatMessage}\n */\nexport interface ExprMessage {\n    /**\n     * The `IntlService` compatible message string\n     */\n    message: string;\n    /**\n     * Any values referenced by `message`\n     */\n    values?: {\n        [key: string]: FieldValue\n    };\n}\n\n/**\n * Options to be used with `Expr.toMessage`\n */\nexport interface ExprMessageOptions {\n    /**\n     * If `true`, field names are included in the message\n     */\n    withFields?: boolean;\n    /**\n     * If `true`, use any display value set in the expression\n     */\n    useDisplay?: boolean;\n    /**\n     * Include HTML formatting in the message\n     */\n    asHTML?: boolean;\n    /**\n     * If `true`, don't include any outer `NOT` operator in the message\n     */\n    hideOuterNot?: boolean;\n}\n\n/**\n * @ignore\n */\ninterface ExprMessageCtxt {\n    inner: boolean;\n    message: string[];\n    values: {\n        [key: string]: FieldValue\n    };\n    valueIndex: number;\n}\n\n/**\n * Describes a location in a fielded search expression\n */\nexport interface ExprLocation {\n    start: number;\n    length: number;\n}\n\n/**\n * Describes a location and value in a fielded search expression\n */\nexport interface ExprValueLocation extends ExprLocation {\n    value: string;\n}\n\n/**\n * Describes a location, value and field in a fielded search expression\n */\nexport interface ExprValueInfo extends ExprValueLocation {\n    field: string;\n}\n\n/**\n * Describes the data used in [Expr.evaluate]{@link Expr#evaluate}\n */\nexport interface ExprEvaluationContext {\n    [key: string]: any;\n}\n\n/**\n * Describes an initialization object used in the construction of an {@link Expr} from a value\n */\nexport interface ExprValueInitializer {\n    /**\n     * The expression context\n     */\n    exprContext: ExprContext;\n    /**\n     * A single value\n     */\n    value?: string;\n    /**\n     * An array of values\n     */\n    values?: string[];\n    /**\n     * Locations of the values used in range expressions\n     */\n    locations?: ExprLocation[];\n    /**\n     * The operator used in the expression\n     */\n    operator?: ExprOperator;\n    /**\n     * The field name\n     */\n    field?: string;\n    /**\n     * The display value\n     */\n    display?: string;\n}\n\n/**\n * Describes an initialization object used in the construction of a boolean {@link Expr} with a pair of operands\n */\nexport interface ExprOperandsInitializer {\n    /**\n     * The expression context\n     */\n    exprContext: ExprContext;\n    /**\n     * The first operand\n     */\n    op1: Expr;\n    /**\n     * If `true` this `Expr` represents an `AND` expression, otherwise it represents an `OR` expression\n     */\n    and: boolean;\n    /**\n     * The second operand\n     */\n    op2: Expr;\n    /**\n     * The field name\n     */\n    field?: string;\n    /**\n     * The display value\n     */\n    display?: string;\n}\n\n/**\n * Represents a parsed fielded search expression. A tree of expression nodes is built when an expression\n * combines sub-expressions using boolean operators\n */\nexport class Expr {\n\n    private _field: string | undefined = undefined;\n\n    /**\n     * Return the field name of this expression. Return the first ancestor's non-empty field\n     * if the field on this node is empty\n     */\n    public get field(): string | undefined {\n        let expr: Expr = this;\n        while (expr) {\n            if (!Utils.isEmpty(expr._field)) {\n                return expr._field;\n            }\n            expr = expr.parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * Set the field name of this expression\n     */\n    public set field(value: string | undefined) {\n        this._field = value;\n    }\n\n    private _display: string | undefined = undefined;\n    private _displayObj: {label?: string, display?: string} | undefined = undefined;\n\n    /**\n     * Return the display value of this expression. Return the first ancestor's non-empty display value\n     * if the display value on this node is empty\n     */\n    public get display(): string | undefined {\n        let expr: Expr = this;\n        while (expr) {\n            if (!Utils.isEmpty(expr._display)) {\n                return expr._display;\n            }\n            expr = expr.parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * Set the display value of this expression. If the display value is a valid stringified JSON object\n     * then set `displayObj` to the parsed object\n     */\n    public set display(value: string | undefined) {\n        this._display = value;\n        if (!this._display) {\n            this._displayObj = undefined;\n        }\n        else {\n            if (this._display[0] === \"{\" && this._display[this._display.length - 1] === \"}\") {\n                try {\n                    this._displayObj = Utils.fromJson(this._display);\n                }\n                catch (e) {\n                    this._displayObj = undefined;\n                }\n            }\n            else {\n                this._displayObj = undefined;\n            }\n        }\n    }\n\n    /**\n     * Return the display object of this expression. Return the first ancestor's non-empty display object\n     * if the display object on this node is empty\n     */\n    public get displayObj(): {label?: string, display?: string} | undefined {\n        let expr: Expr = this;\n        while (expr) {\n            if (expr._displayObj) {\n                return expr._displayObj;\n            }\n            expr = expr.parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * The values of this expression\n     */\n    public values: string[] | undefined = undefined;\n    /**\n     * The locations of the values of this expression\n     */\n    public locations: ExprLocation[] | undefined;\n\n    /**\n     * Return the value of this expression. Note that range expressions may have multiple values\n     */\n    public get value(): string | undefined {\n        if (!this.values || this.values.length === 0) {\n            return undefined;\n        }\n        return this.values[0];\n    }\n\n    /**\n     * Set the value of this expression\n     */\n    public set value(value: string | undefined) {\n        if (value === undefined) {\n            this.values = undefined;\n        }\n        else {\n            if (!this.values) {\n                this.values = [];\n            }\n            this.values[0] = value;\n            this.values.length = 1;\n        }\n    }\n\n    /**\n     * The operator of this expression\n     */\n    public operator: ExprOperator;\n    /**\n     * If `true` then this expression included the `NOT` boolean operator\n     */\n    public not: boolean;\n    /**\n     * If `true` then the operands of this expression are combined with the `AND` operator.\n     * Otherwise the operands are combined with the `OR` operator\n     */\n    public and: boolean;\n    /**\n     * The operands of this expression, if any\n     */\n    public operands: Expr[];\n    /**\n     * The parent expression, if any\n     */\n    public parent: Expr;\n    /**\n     * The expression context\n     */\n    public exprContext: ExprContext;\n    /**\n     * The distance specified in a `NEAR` expression\n     */\n    public near: number;\n    /**\n     * The position of this expression's value in the original text\n     */\n    public start: number;\n    /**\n     * The length of this expression's value in the original text\n     */\n    public length: number;\n    private mergedStructured: boolean;\n\n    // for evaluate\n    private _evaluationRegExps: MapOf<RegExp | undefined>;\n    private get evaluationRegExps(): MapOf<RegExp | undefined> {\n        if (!this._evaluationRegExps) {\n            this._evaluationRegExps = {};\n        }\n        return this._evaluationRegExps;\n    }\n\n    constructor(init: ExprValueInitializer | ExprOperandsInitializer) {\n        if (!(<ExprOperandsInitializer>init).op1) {\n            const valueInit: ExprValueInitializer = <ExprValueInitializer>init;\n            this.exprContext = valueInit.exprContext;\n            if (!Utils.isUndefined(valueInit.value)) {\n                this.value = ExprParser.unescape(valueInit.value);\n            }\n            else if (!Utils.isUndefined(valueInit.values)) {\n                this.values = ExprParser.unescapeList(valueInit.values);\n            }\n            this.locations = valueInit.locations;\n            this.field = valueInit.field;\n            this.display = valueInit.display;\n            this.operator = !Utils.isUndefined(valueInit.operator) ? valueInit.operator : ExprOperator.none;\n            this.near = -1;\n            this.start = -1;\n            this.length = 0;\n        }\n        else {\n            const opsInit: ExprOperandsInitializer = init as ExprOperandsInitializer;\n            this.exprContext = opsInit.exprContext;\n            this.field = opsInit.field;\n            this.display = opsInit.display;\n            this.addOperand(opsInit.op1);\n            this.addOperand(opsInit.op2);\n            this.and = opsInit.and;\n            this.near = -1;\n            this.start = -1;\n            this.length = 0;\n        }\n    }\n\n    /**\n     * Add an operand to this expression\n     *\n     * @param operand The operand to add\n     * @param contextField The parser's field context, if any\n     * @param prepend If `true` the operand is prepended to the operands\n     */\n    public addOperand(operand: Expr, contextField?: string, prepend = false) {\n        if (Utils.isUndefined(contextField)) {\n            contextField = this.field;\n        }\n        if (!this.operands) {\n            this.operands = [];\n        }\n        if (!Utils.isEmpty(this.field) && Utils.isEmpty(operand.field) && !operand.isStructured) {\n            if (Utils.isEmpty(contextField)) {\n                // Prefer setting the fields explicitly on the target operands rather the Field to \"text\" on the source operand\n                // operand.field = ExprParser.fieldPartnamePrefix + \"text\";\n                for (const expr of this.operands) {\n                    if (Utils.isEmpty(expr._field)) {\n                        expr._field = this.field;\n                    }\n                }\n                this.field = undefined;\n            }\n        }\n        if (!Utils.eqNC(this.field || \"\", operand.field || \"\")) {\n            operand._field = operand.field;\n        }\n        else {\n            operand._field = undefined;\n        }\n        if (!Utils.isEmpty(this.display)) {\n            operand._display = undefined;\n        }\n        if (prepend) {\n            this.operands.unshift(operand);\n        }\n        else {\n            this.operands.push(operand);\n        }\n        operand.parent = this;\n    }\n\n    /**\n     * Return `true` if this expression is a leaf node (does have a value)\n     */\n    public get isLeaf(): boolean {\n        // if (this.value === null && !this.operands) throw \"Expr.isLeaf - bad expression\";\n        return !!this.value;\n    }\n\n    /**\n     * Make an expression object\n     *\n     * @param exprContext The expression context\n     * @param text The value of the expression\n     * @param field The parser's field context\n     * @param display The display value\n     * @param allowEmptyValue Determines how empty values will be processed when making the expression\n     */\n    public static makeExpr(exprContext: ExprContext, text: string, field: string, display: string, allowEmptyValue: boolean): Expr | undefined {\n        if (!Expr.getIsStructuredField(exprContext, Expr.resolveField(exprContext, field))) {\n            return new Expr({\n                exprContext: exprContext,\n                value: text,\n                field: field,\n                display: display\n            });\n        }\n\n        const values: IRef<string[] | undefined> = {value: undefined};\n        const locations: IRef<ExprLocation[] | undefined> = {value: undefined};\n        const operator: IRef<ExprOperator> = {value: ExprOperator.none};\n        const range: IRef<ExprRange> = {value: ExprRange.none};\n        Expr.parseValue(exprContext, text, field, allowEmptyValue, values, locations, operator, range);\n        if (range.value !== ExprRange.none && values.value && locations.value) {\n            const value1 = values.value[0];\n            const value2 = values.value[1];\n            const location1 = locations.value[0];\n            const location2 = locations.value[1];\n            if (range.value === ExprRange.gteLte && !Utils.eqNC(value1, \"*\") && !Utils.eqNC(value2, \"*\")) {\n                return new Expr({\n                    exprContext: exprContext,\n                    values: values.value,\n                    locations: locations.value,\n                    field: field,\n                    display: display,\n                    operator: ExprOperator.between\n                });\n            }\n            const expr1 = !Utils.eqNC(value1, \"*\") ? new Expr({\n                exprContext: exprContext,\n                value: value1,\n                locations: [location1],\n                field: field,\n                display: display,\n                operator: range.value === ExprRange.gteLt || range.value === ExprRange.gteLte ? ExprOperator.gte : ExprOperator.gt\n            }) : null;\n            const expr2 = !Utils.eqNC(value2, \"*\") ? new Expr({\n                exprContext: exprContext,\n                value: value2,\n                locations: [location2],\n                field: field,\n                display: display,\n                operator: range.value === ExprRange.gteLte || range.value === ExprRange.gtLte ? ExprOperator.lte : ExprOperator.lt\n            }) : undefined;\n            if (!expr1 && !expr2) {\n                return undefined;\n            }\n            if (!(!!expr1 && !!expr2)) return !!expr1 ? expr1 : expr2;\n            return new Expr({\n                exprContext: exprContext,\n                op1: expr1,\n                and: true,\n                op2: expr2,\n                display: display\n            });\n        }\n        return new Expr({\n            exprContext: exprContext,\n            values: values.value,\n            locations: locations.value,\n            field: field,\n            display: display,\n            operator: operator.value\n        });\n    }\n\n    private static resolveField(exprContext: ExprContext, field: string | null | undefined): string {\n        if (Utils.isString(field)) {\n            return exprContext.appService.resolveColumnName(field);\n        }\n        return \"\";\n    }\n\n    private static getColumn(exprContext: ExprContext, field: string | undefined): CCColumn | undefined {\n        return exprContext.appService.getColumn(field);\n    }\n\n    /**\n     * Return the {@link CCColumn} corresponding to this expression\n     */\n    get column(): CCColumn | undefined {\n        return Expr.getColumn(this.exprContext, this.field);\n    }\n\n    private static getIsStructuredField(exprContext: ExprContext, field: string | undefined): boolean {\n        if (!field) {\n            return false;\n        }\n        if (exprContext.disallowFulltext) {\n            return true;\n        }\n        else {\n            if (field[0] === \":\") {\n                return false; // :: => take partname over column\n            }\n            if (Utils.eqNCN(field, \"exists\", \"missing\")) {\n                return true;\n            }\n            return !!Expr.getColumn(exprContext, field);\n        }\n    }\n\n    /**\n     * Return `true` if the expression has a non-fulltext field. In this case the expression will be a leaf node\n     */\n    get isStructuredField(): boolean {\n        if (!this.isLeaf) {\n            return false;\n        }\n        return Expr.getIsStructuredField(this.exprContext, this.field);\n    }\n\n    /**\n     * Return `true` if the expression only contains non-fulltext fields\n     */\n    public get isStructured(): boolean {\n        if (this.mergedStructured) {\n            return true;\n        }\n        if (this.isLeaf) {\n            return this.isStructuredField;\n        }\n        if (!this.operands) {\n            return false;\n        }\n        for (const operand of this.operands) {\n            if (!operand.isStructured) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return `true` if the expression and its ancestors do not have `not` set to `true`\n     */\n    public get isPositive(): boolean {\n        let positive = true;\n        let current: Expr = this;\n        while (current != null) {\n            positive = positive && !current.not;\n            current = current.parent;\n        }\n        return positive;\n    }\n\n    /**\n     * Return an `ExprValueLocation` object for the passed text. Leading and trailing\n     * whitespace is excluded\n     */\n    static getValueAndLocation(text: string): ExprValueLocation {\n        let start = 0;\n        let length = text.length;\n        const value1 = Utils.trimStart(text);\n        start += length - value1.length;\n        length -= length - value1.length;\n        const value2 = Utils.trimEnd(value1);\n        length -= length - value2.length;\n        return {\n            value: value2,\n            start: start,\n            length: length\n        };\n    }\n\n    private static parseValue(exprContext: ExprContext, text: string, field: string, allowEmptyValue: boolean, values: IRef<string[] | undefined>, locations: IRef<ExprLocation[] | undefined>, operator: IRef<ExprOperator>, range: IRef<ExprRange>) {\n        if (Utils.isEmpty(text) && !allowEmptyValue) {\n            return;\n        }\n        const first = text[0];\n        const last = text[text.length - 1];\n        let vl: ExprValueLocation;\n        if (\"[{\".includes(first) && \"]}\".includes(last)) {\n            text = text.substr(1, text.length - 2);\n            let sepLen = 4;\n            let sep = text.indexOf(\" TO \");\n            if (sep === -1) {\n                sepLen = 2;\n                sep = text.indexOf(\"..\");\n            }\n            if (sep === -1) {\n                const vls = ExprParser.valuesAndLocationsFromText(text, ',');\n                values.value = [];\n                locations.value = [];\n                vls.forEach(vl1 => {\n                    values.value!.push(vl1.value);\n                    locations.value!.push({start: 1 + vl1.start, length: vl1.length});\n                });\n                operator.value = ExprOperator.in;\n                return;\n            }\n            vl = Expr.getValueAndLocation(text.substr(0, sep));\n            values.value = [vl.value];\n            locations.value = [{start: 1 + vl.start, length: vl.length}];\n            vl = Expr.getValueAndLocation(text.substr(sep + sepLen));\n            values.value.push(vl.value);\n            locations.value.push({start: 1 + sep + sepLen + vl.start, length: vl.length});\n            if (first === \"[\") {\n                range.value = last === \"]\" ? ExprRange.gteLte : ExprRange.gteLt;\n            }\n            else { // '{'\n                range.value = last === \"}\" ? ExprRange.gtLt : ExprRange.gtLte;\n            }\n            return;\n        }\n        vl = {\n            value: text,\n            start: 0,\n            length: text.length\n        };\n        if (text.startsWith(\"=\")) {\n            operator.value = ExprOperator.eq;\n            vl = Expr.getValueAndLocation(text.substr(1));\n            vl.start += 1;\n        }\n        else if (text.startsWith(\">=\")) {\n            operator.value = ExprOperator.gte;\n            vl = Expr.getValueAndLocation(text.substr(2));\n            vl.start += 2;\n        }\n        else if (text.startsWith(\">\")) {\n            operator.value = ExprOperator.gt;\n            vl = Expr.getValueAndLocation(text.substr(1));\n            vl.start += 1;\n        }\n        else if (text.startsWith(\"<=\")) {\n            operator.value = ExprOperator.lte;\n            vl = Expr.getValueAndLocation(text.substr(2));\n            vl.start += 2;\n        }\n        else if (text.startsWith(\"<>\")) {\n            operator.value = ExprOperator.neq;\n            vl = Expr.getValueAndLocation(text.substr(2));\n            vl.start += 2;\n        }\n        else if (text.startsWith(\"<\")) {\n            operator.value = ExprOperator.lt;\n            vl = Expr.getValueAndLocation(text.substr(1));\n            vl.start += 1;\n        }\n        else if (text.startsWith(\"~\")) {\n            operator.value = ExprOperator.regex;\n            vl = Expr.getValueAndLocation(text.substr(1));\n            vl.start += 1;\n        }\n        else if (text.length > 1 && text.startsWith(\"/\") && text.endsWith(\"/\")) {\n            operator.value = ExprOperator.regex;\n            vl.value = text.substr(1, text.length - 2);\n            vl.start = 1;\n            vl.length = vl.value.length;\n        }\n        if (text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\")) {\n            vl.value = text.substr(1, text.length - 2);\n            vl.start = 1;\n            vl.length = vl.value.length;\n        }\n        values.value = [vl.value];\n        locations.value = [{start: vl.start, length: vl.length}];\n    }\n\n    private static getOperatorText(operator: ExprOperator): string {\n        switch (operator) {\n            case ExprOperator.eq: return \"=\";\n            case ExprOperator.gt: return \">\";\n            case ExprOperator.gte: return \">=\";\n            case ExprOperator.lt: return \"<\";\n            case ExprOperator.lte: return \"<=\";\n            case ExprOperator.neq: return \"<>\";\n            case ExprOperator.regex: return \"REGEXP\";\n            case ExprOperator.like: return \"LIKE\";\n            case ExprOperator.contains: return \"CONTAINS\";\n            case ExprOperator.in: return \"IN\";\n            case ExprOperator.between: return \"BETWEEN\";\n            default: return \"=\";\n        }\n    }\n\n    /**\n     * Find the first `ExprValueInfo` object from a starting position in this expression\n     *\n     * @param start The position at which to start the search\n     */\n    findValue(start: number): ExprValueInfo | undefined {\n        if (this.isLeaf) {\n            if (start >= this.start && start <= this.start + this.length) {\n                if (!this.isStructured) {\n                    return {\n                        /* eslint-disable-next-line */\n                        value: this.value!,\n                        /* eslint-disable-next-line */\n                        field: this.field!,\n                        start: this.start,\n                        length: this.length\n                    };\n                }\n                else if (!!this.locations && this.values && this.values.length === this.locations.length) {\n                    for (let i = 0, ic = this.values.length; i < ic; i++) {\n                        const value = this.values[i];\n                        const location = this.locations[i];\n                        if (start >= this.start + location.start && start <= this.start + location.start + location.length) {\n                            return {\n                                value,\n                                /* eslint-disable-next-line */\n                                field: this.field!,\n                                start: this.start + location.start,\n                                length: location.length\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        else if (!!this.operands) {\n            for (const expr of this.operands) {\n                const value = expr.findValue(start);\n                if (value) {\n                    return value;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Combine two expressions into a single expression. The second expression will be added to\n     * the first expression and the first expression returned if the first expression is non-leaf\n     * and is an `AND` expression and not negated. Otherwise, a new `AND` expression will be created\n     * to which both expressions are added as operands.\n     */\n    static combine(expr1: Expr, expr2: Expr): Expr {\n        if (!expr1) {\n            return expr2;\n        }\n        if (!expr2) {\n            return expr1;\n        }\n        if (!expr1.isLeaf && expr1.and && !expr1.not) {\n            if (expr1.isLeaf || !expr2.and || expr2.not) {\n                expr1.addOperand(expr2);\n            }\n            else {\n                for (const expr3 of expr2.operands) {\n                    expr1.addOperand(expr3);\n                }\n            }\n            return expr1;\n        }\n        return new Expr({\n            exprContext: expr1.exprContext,\n            op1: expr1,\n            and: true,\n            op2: expr2\n        });\n    }\n\n    private normalizeField(field: string | undefined): string | undefined {\n        if (field && field[0] === ExprParser.fieldPartnamePrefix) {\n            return field.substr(1);\n        }\n        return field;\n    }\n\n    private shouldDisplayField(): boolean {\n        if (!this.field && !this.parent) { // top level full text\n            return true;\n        }\n        return !!this.field && (!this.parent || !Utils.eqNC(this.field, this.parent.field || \"\"));\n    }\n\n    private getOperatorString(): string {\n        if (this.operator === ExprOperator.none || this.operator === ExprOperator.eq) {\n            return \"\";\n        }\n        return Expr.getOperatorText(this.operator);\n    }\n\n    private escapeValue(value: string | null | undefined): string {\n        if (!!value && !!this.column && (AppServiceHelpers.isString(this.column) || AppServiceHelpers.isCsv(this.column))) {\n            return ExprParser.escape(value);\n        }\n        return value || \"\";\n    }\n\n    private getValueString(): string {\n        if (this.operator === ExprOperator.between && this.values && this.values.length === 2) {\n            return `[${this.escapeValue(this.values[0])}..${this.escapeValue(this.values[1])}]`;\n        }\n        if (this.values && this.values.length > 1) {\n            const sb: string[] = [];\n            for (const value of this.values) {\n                if (sb.length > 0) {\n                    sb.push(\", \");\n                }\n                sb.push(this.escapeValue(value));\n            }\n            sb.unshift(\"[\");\n            sb.push(\"]\");\n            return sb.join(\"\");\n        }\n        return this.escapeValue(this.value);\n    }\n\n    private addFieldToString(sb: string[]): boolean {\n        let added = false;\n        if (this.shouldDisplayField()) {\n            sb.push(this.normalizeField(this.field) || \"text\");\n            added = true;\n        }\n        if (this.display) {\n            sb.push(ExprParser.escape(this.display));\n            added = true;\n        }\n        if (added) {\n            sb.push(\":\");\n        }\n        return added;\n    }\n\n    private _toString(withFields: boolean, inner: boolean): string {\n        const sb: string[] = [];\n        if (this.isLeaf) {\n            if (this.not) {\n                sb.push(\"NOT \");\n            }\n            if (withFields) {\n                this.addFieldToString(sb);\n            }\n            sb.push(this.getOperatorString());\n            sb.push(this.getValueString());\n        }\n        else {\n            if (!this.operands) {\n                return \"\";\n            }\n            if (this.not) {\n                sb.push(\"NOT \");\n            }\n            let bracketed = inner;\n            if (this.addFieldToString(sb)) {\n                bracketed = true;\n            }\n            if (bracketed) {\n                sb.push(\"(\");\n            }\n            let first = true;\n            for (const operand of this.operands) {\n                if (!first) {\n                    if (this.and) {\n                        sb.push(\" AND \");\n                    }\n                    else {\n                        sb.push(\" OR \");\n                    }\n                }\n                first = false;\n                sb.push(operand._toString(withFields, true));\n            }\n            if (bracketed) {\n                sb.push(\")\");\n            }\n        }\n        return sb.join(\"\");\n    }\n\n    /**\n     * Return a string representation of this expression\n     *\n     * @param withFields If `true`, include field names\n     */\n    toString(withFields = true): string {\n        return this._toString(withFields, false);\n    }\n\n    private addDisplay(options: ExprMessageOptions, ctxt: ExprMessageCtxt, display: string) {\n        this._addValue(options, ctxt, this.value || \"\", display);\n    }\n\n    private encodeHTML(text: string, options: ExprMessageOptions): string {\n        if (options && options.asHTML) {\n            return Utils.encodeHTML(text);\n        }\n        else {\n            return text;\n        }\n    }\n\n    private _addValue(options: ExprMessageOptions, ctxt: ExprMessageCtxt, value: string, display?: string) {\n        if (options.asHTML) {\n            ctxt.message.push(`<span class=\"sq-value\">`);\n        }\n        const column = this.exprContext.appService.getColumn(this.field);\n        const valueId = `value${ctxt.valueIndex++}`;\n        let _value: FieldValue = value;\n        let _display: string | undefined;\n        if (display) {\n            _display = this.encodeHTML(ExprParser.unescape(display), options);\n        }\n        if (column && AppServiceHelpers.isNumber(column) && Utils.testFloat(value)) {\n            _value = +value;\n        }\n        else if (column && AppServiceHelpers.isDate(column)) {\n            _value = Utils.fromSysDateStr(value) || value;\n        }\n        else if (column && AppServiceHelpers.isBoolean(column)) {\n            _value = Utils.isTrue(value);\n        }\n        else if (Utils.isString(_value)) {\n            _value = this.encodeHTML(_value, options);\n        }\n        ctxt.message.push(`{${valueId}}`);\n        ctxt.values[valueId] = column\n            ? this.exprContext.formatService.formatFieldValue({value: _value, display: _display}, column)\n            : _display || _value;\n        if (options.asHTML) {\n            ctxt.message.push(`</span>`);\n        }\n    }\n\n    private addValue(options: ExprMessageOptions, ctxt: ExprMessageCtxt) {\n        if (this.values) {\n            if (this.operator === ExprOperator.between && this.values.length === 2) {\n                this._addValue(options, ctxt, this.values[0]);\n                ctxt.message.push(\" \");\n                this.addOperator(\"AND\", options, ctxt);\n                ctxt.message.push(\" \");\n                this._addValue(options, ctxt, this.values[1]);\n            }\n            else if (this.values.length > 1) {\n                let first = true;\n                for (const value of this.values) {\n                    ctxt.message.push(first ? \"[\" : \", \");\n                    first = false;\n                    this._addValue(options, ctxt, value);\n                }\n                ctxt.message.push(\"]\");\n            }\n            else {\n                this._addValue(options, ctxt, this.values[0]);\n            }\n        }\n    }\n\n    private addText(options: ExprMessageOptions, ctxt: ExprMessageCtxt, text: string) {\n        const valueId = `value${ctxt.valueIndex++}`;\n        const message = `{${valueId}}`;\n        ctxt.message.push(message);\n        ctxt.values[valueId] = this.encodeHTML(text, options);\n    }\n\n    private addFieldLabel(options: ExprMessageOptions, ctxt: ExprMessageCtxt) {\n        const displayObj = this.displayObj;\n        if (displayObj && displayObj.label) {\n            this.addText(options, ctxt, displayObj.label);\n        }\n        else if (this.field) {\n            const label = this.exprContext.appService.getLabel(this.normalizeField(this.field) || \"\");\n            this.addText(options, ctxt, label);\n        }\n        else {\n            if (!this.isStructured) {\n                const label = this.exprContext.appService.getLabel(\"text\");\n                this.addText(options, ctxt, label);\n            }\n            else {\n                const fields = this.getFields();\n                fields.forEach((field, index) => {\n                    if (index !== 0) {\n                        this.addText(options, ctxt, \"/\");\n                    }\n                    const label = this.exprContext.appService.getLabel(field);\n                    this.addText(options, ctxt, label);\n                });\n            }\n        }\n    }\n\n    private addField(options: ExprMessageOptions, ctxt: ExprMessageCtxt) {\n        if (options.asHTML) {\n            ctxt.message.push(`<span class=\"sq-field\">`);\n        }\n        this.addFieldLabel(options, ctxt);\n        if (options.asHTML) {\n            ctxt.message.push(`</span>`);\n            ctxt.message.push(`<span class=\"sq-separator\">`);\n        }\n        this.addText(options, ctxt, \"msg#system.fieldSeparator\");\n        if (options.asHTML) {\n            ctxt.message.push(`</span>`);\n        }\n    }\n\n    private addOperator(operator: string, options: ExprMessageOptions, ctxt: ExprMessageCtxt) {\n        if (!operator) {\n            return;\n        }\n        if (options.asHTML) {\n            ctxt.message.push(`<span class=\"sq-operator\">`);\n        }\n        ctxt.message.push(this.encodeHTML(operator, options));\n        if (options.asHTML) {\n            ctxt.message.push(`</span>`);\n        }\n    }\n\n    private _toMessage(ctxt: ExprMessageCtxt, options?: ExprMessageOptions): ExprMessage {\n        const inner = ctxt.inner;\n        ctxt.inner = true;\n        if (!options) {\n            options = {};\n        }\n        if (Utils.isUndefined(options.useDisplay)) {\n            options.useDisplay = true;\n        }\n\n        const displayObj = this.displayObj;\n        const display = (displayObj ? displayObj.display : undefined) || this.display;\n        const showNot = this.not && (inner || !options.hideOuterNot);\n        const showField = (options.withFields || inner) && this.shouldDisplayField();\n        if (options.useDisplay && !!display) {\n            if (showNot) {\n                this.addOperator(\"NOT\", options, ctxt);\n                ctxt.message.push(\" \");\n            }\n            if (showField) {\n                this.addField(options, ctxt);\n            }\n            this.addDisplay(options, ctxt, display);\n        }\n        else if (this.isLeaf) {\n            if (showNot) {\n                this.addOperator(\"NOT\", options, ctxt);\n                ctxt.message.push(\" \");\n            }\n            if (showField) {\n                this.addField(options, ctxt);\n            }\n            const operator = this.getOperatorString();\n            if (operator) {\n                this.addOperator(operator, options, ctxt);\n                ctxt.message.push(\" \");\n            }\n            this.addValue(options, ctxt);\n        }\n        else {\n            if (!this.operands) {\n                return {message: \"\"};\n            }\n            if (showNot) {\n                this.addOperator(\"NOT\", options, ctxt);\n                ctxt.message.push(\" \");\n            }\n            let bracketed = inner;\n            if (showField) {\n                this.addField(options, ctxt);\n                bracketed = true;\n            }\n            if (bracketed) {\n                ctxt.message.push(\"(\");\n            }\n            let first = true;\n            for (const operand of this.operands) {\n                if (!first) {\n                    if (this.and) {\n                        ctxt.message.push(\" \");\n                        this.addOperator(\"AND\", options, ctxt);\n                        ctxt.message.push(\" \");\n                    }\n                    else {\n                        ctxt.message.push(\" \");\n                        this.addOperator(\"OR\", options, ctxt);\n                        ctxt.message.push(\" \");\n                    }\n                }\n                first = false;\n                operand._toMessage(ctxt, options);\n            }\n            if (bracketed) {\n                ctxt.message.push(\")\");\n            }\n        }\n        if (inner) {\n            return {message: \"\"};\n        }\n        return {\n            message: ctxt.message.join(\"\"),\n            values: ctxt.values\n        };\n    }\n\n    /**\n     * Return an `ExprMessage` for the expression which can be used with [IntlService.formatMessage]{@link IntlService#formatMessage}\n     * for display purposes\n     */\n    toMessage(options?: ExprMessageOptions): ExprMessage {\n        return this._toMessage({\n            inner: false,\n            message: [\"txt#\"],\n            values: {},\n            valueIndex: 0\n        }, options);\n    }\n\n    private static matchNode(context: ExprContext, expr1: Expr, expr2: Expr): boolean {\n        if (expr1.isLeaf !== expr2.isLeaf) {\n            return false;\n        }\n        if (expr1.isLeaf) {\n            if (expr1.isStructured !== expr2.isStructured) {\n                return false;\n            }\n            if (expr1.not !== expr2.not) {\n                return false;\n            }\n            const field1 = context.appService.resolveColumnAlias(expr1.field);\n            const field2 = context.appService.resolveColumnAlias(expr2.field);\n            if (field1 !== field2) {\n                return false;\n            }\n            const operator1 = expr1.operator === ExprOperator.none ? ExprOperator.eq : expr1.operator;\n            const operator2 = expr2.operator === ExprOperator.none ? ExprOperator.eq : expr2.operator;\n            if (operator1 !== operator2) {\n                return false;\n            }\n        }\n        if (!expr1.isLeaf) {\n            if (expr1.and !== expr2.and) {\n                return false;\n            }\n            // All of the structured and non-structured operands in expr2 must be in expr1 so check that there are at least enough\n            // operands available. (The actual matching of the contents of the operand nodes is done in the recursive calls to MatchNode)\n            if (!expr1.operands !== !expr2.operands) {\n                return false;\n            }\n            let expr1StructuredCount = 0, expr1UnstructuredCount = 0, expr2StructuredCount = 0, expr2UnstructuredCount = 0;\n            expr1.operands.forEach((operand) => { if (operand.isStructured) { expr1StructuredCount++; } else { expr1UnstructuredCount++; }});\n            expr2.operands.forEach((operand) => { if (operand.isStructured) { expr2StructuredCount++; } else { expr2UnstructuredCount++; }});\n            if ((expr2StructuredCount > expr1StructuredCount) || (expr2UnstructuredCount > expr1UnstructuredCount)) {\n                return false;\n            }\n        }\n        const values1Length = expr1.values ? expr1.values.length : 0;\n        const values2Length = expr2.values ? expr2.values.length : 0;\n        if (values1Length !== values2Length) {\n            return false;\n        }\n        if (values1Length && expr1.values && expr2.values) {\n            for (const value1 of expr1.values) {\n                let found = false;\n                for (const value2 of expr2.values) {\n                    if (Utils.eqNC(value1, value2)) {\n                        found = true;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return `true` if this expression matches the passed one\n     */\n    matchNode(expr: Expr): boolean {\n        return Expr.matchNode(this.exprContext, this, expr);\n    }\n\n    /**\n     * Returns the matching expression or sub-expression in this expression with the passed one.\n     *\n     * @param expr The expression to match\n     * @param filter An option filter function called on first level candidate sub-expressions\n     * before matching within them\n     */\n    find(expr: Expr, filter?: (expr: Expr) => boolean): Expr | null {\n        if (this.matchNode(expr)) {\n            if (!this.isLeaf && this.operands) {\n                for (const child1 of expr.operands) {\n                    let found = false;\n                    for (const child2 of this.operands) {\n                        if (filter && filter(child2)) {\n                            continue;\n                        }\n                        if (child2.find(child1)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        return null;\n                    }\n                }\n            }\n            return this;\n        }\n        else {\n            if (!this.isLeaf && this.operands) {\n                for (const child of this.operands) {\n                    if (filter && filter(child)) {\n                        continue;\n                    }\n                    if (child.find(expr)) {\n                        return child;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Perform the passed `action` on this expression and any descendant operands\n     *\n     * @param action The action to perform\n     */\n    forEach(action: (expr: Expr) => void) {\n        action(this);\n        if (this.operands) {\n            for (const operand of this.operands) {\n                operand.forEach(action);\n            }\n        }\n    }\n\n    /**\n     * Execute the callback function on this node and any descendants until the callback returns a truthy value\n     * in which case immediately return `true`. Otherwise return `false`.\n     */\n    some(callback: (expr: Expr) => boolean): boolean {\n        if (callback(this)) {\n            return true;\n        }\n        if (this.operands) {\n            for (const operand of this.operands) {\n                if (operand.some(callback)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Execute the callback function on this node and any descendants until the callback returns a falsy value\n     * in which case, immediately return `false`. Otherwise return `true`.\n     */\n    every(callback: (expr: Expr) => boolean): boolean {\n        if (!callback(this)) {\n            return false;\n        }\n        if (this.operands) {\n            for (const operand of this.operands) {\n                if (!operand.every(callback)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return `true` if the exoression has at least one fulltext operand.\n     * The test on `isPositive` filters expressions that only contain\n     * negative fulltext terms which will be ignored on the server. Fulltext\n     * expressions must have at least one positive term.\n     */\n    get hasRelevance(): boolean {\n        return this.some(expr => expr.isLeaf && !expr.isStructured && expr.isPositive);\n    }\n\n    /**\n     * Return an array of all fields used in this expression\n     */\n    getFields(): string[] {\n        const fields: string[] = [];\n        this.forEach((expr) => {\n            const field = this.exprContext.appService.resolveColumnAlias(expr.field);\n            if (field) {\n                if (!fields.find((field1) => Utils.eqNC(field, field1))) {\n                    fields.push(field);\n                }\n            }\n        });\n        return fields;\n    }\n\n    /**\n     * Return an array of all values used in this expression that pertain to the passed field and where the associated `isPositive`\n     * field matches the passed `positive` parameter\n     *\n     * @param field The field for which values are to be returned\n     * @param positive The value to test against `isPositive`\n     */\n    getValues(field: string, positive = true): string[] {\n        const values: string[] = [];\n        const column = this.exprContext.appService.resolveColumnName(field);\n        this.forEach((expr) => {\n            if (column) {\n                const column1 = this.exprContext.appService.resolveColumnName(expr.field);\n                if (!Utils.eqNC(column, column1)) {\n                    return;\n                }\n            }\n            if (expr.isLeaf && expr.isPositive === positive && expr.values) {\n                values.push(...expr.values);\n            }\n        });\n        return values;\n    }\n\n    private getDataValue(data: ExprEvaluationContext, field?: string, defaultScope?: string): any {\n        if (!data) {\n            return undefined;\n        }\n        const fields = Utils.split(field || \"\", \".\");\n        if (fields.length >= 1 && Utils.isUndefined(data[fields[0]]) && !!defaultScope) {\n            // By default, look on the \"defaultScope\" sub-object\n            fields.unshift(...Utils.split(defaultScope, \".\"));\n        }\n        let value: any = data;\n        for (const _field of fields) {\n            if (!value) {\n                break;\n            }\n            value = value[_field];\n        }\n        return value;\n    }\n\n    private getWildcardRegExp(value: string): RegExp | undefined {\n        if (value) {\n            let regExp = this.evaluationRegExps[value];\n            if (!Utils.isUndefined(regExp)) {\n                return regExp;\n            }\n            let haveWildcards = false;\n            let escaping = false;\n            const sb: string[] = [];\n            for (const ch of value) {\n                switch (ch) {\n                    // Handle wildcards and wildcard escaping\n                    case \"\\\\\":\n                        if (escaping) {\n                            sb.push(\"\\\\\\\\\");\n                            escaping = false;\n                        }\n                        else {\n                            escaping = true;\n                        }\n                        break;\n                    case \"*\":\n                        if (escaping) {\n                            sb.push(\"\\\\\");\n                            sb.push(ch);\n                            escaping = false;\n                        }\n                        else {\n                            haveWildcards = true;\n                            sb.push(\".*?\");\n                        }\n                        break;\n                    case \"?\":\n                        if (escaping) {\n                            sb.push(\"\\\\\");\n                            sb.push(ch);\n                            escaping = false;\n                        }\n                        else {\n                            haveWildcards = true;\n                            sb.push(\".\");\n                        }\n                        break;\n                    // Escape other regexp special characters\n                    case \"-\":\n                    case \"/\":\n                    case \"^\":\n                    case \"$\":\n                    case \"+\":\n                    case \".\":\n                    case \"(\":\n                    case \")\":\n                    case \"|\":\n                    case \"[\":\n                    case \"]\":\n                    case \"{\":\n                    case \"}\":\n                        sb.push(\"\\\\\");\n                        sb.push(ch);\n                        escaping = false;\n                        break;\n                    // All other characters just emit\n                    default:\n                        sb.push(ch);\n                        escaping = false;\n                        break;\n                }\n            }\n            if (haveWildcards) {\n                regExp = new RegExp(\"^\" + sb.join(\"\") + \"$\", \"i\");\n                this.evaluationRegExps[value] = regExp;\n                return regExp;\n            }\n            else {\n                this.evaluationRegExps[value] = undefined;\n            }\n        }\n        return undefined;\n    }\n\n    // NB comparisons with NaN always return false\n    private compare(value: string | string[] | undefined, dataValue: any, equality?: boolean): number {\n        if (Utils.isArray(dataValue) && dataValue.length === 0) {\n            return NaN;\n        }\n        const column = Expr.getColumn(this.exprContext, this.field || \"\");\n        if (Utils.isArray(dataValue) || Utils.isArray(value)) {\n            // \"in\" / \"contains\"\n            if (!Utils.isArray(dataValue)) {\n                dataValue = [dataValue];\n            }\n            if (Utils.isArray(value)) {\n                if (value.length === 0) {\n                    return NaN;\n                }\n            }\n            else {\n                value = [value + \"\"];\n            }\n            // At least one value in the value array must match a value in the dataValue array\n            for (const value1 of value) {\n                for (const dataValue1 of dataValue) {\n                    if (this.compare(value1, dataValue1, true) === 0) {\n                        return 0;\n                    }\n                }\n            }\n            return NaN;\n        }\n        if (!Utils.isArray(value)) {\n            value = ExprParser.unescape(value || \"\");\n            if (column && column.parser) {\n                value = this.exprContext.formatService.parseValue(value, column.parser);\n            }\n            if (AppServiceHelpers.isNumber(column)) {\n                if (!Utils.isNumber(dataValue)) {\n                    dataValue = 0;\n                }\n                const _value = Utils.toNumber(value);\n                return dataValue - _value;\n            }\n            if (AppServiceHelpers.isDate(column)) {\n                if (Utils.isString(dataValue)){\n                    dataValue = Utils.toDate(dataValue);\n                }\n                if (Utils.isDate(dataValue)) {\n                    const _value = this.exprContext.intlService.parseDate(value);\n                    if (_value) {\n                        return dataValue.getTime() - _value.getTime();\n                    }\n                }\n                return NaN;\n            }\n            if (AppServiceHelpers.isBoolean(column)) {\n                const _value = Utils.isTrue(value) ? 1 : 0;\n                return (dataValue ? 1 : 0) - _value;\n            }\n            dataValue = dataValue || \"\";\n            if (Utils.isString(dataValue)) {\n                dataValue = ExprParser.unescape(dataValue);\n                if (equality) {\n                    const regExp = this.getWildcardRegExp(value);\n                    if (regExp) {\n                        return regExp.test(dataValue) ? 0 : -1;\n                    }\n                }\n                return Utils.compare(dataValue, value);\n            }\n        }\n        return NaN;\n    }\n\n    /**\n     * Evaluate this expression using `data` to provide field values. Field values\n     * can contain scopes (full stop separated components) to reference sub-objects\n     * in the data\n     *\n     * @param data The field values to be used in the evaluation\n     * @param defaultScope If a field value cannot be resolved then try to retrieve a value with this scope prepended to the field name\n     * @return The boolean result of the expression evaluation\n     */\n    evaluate(data: ExprEvaluationContext, defaultScope?: string): boolean {\n        let ret: boolean;\n        if (this.isLeaf) {\n            if (!this.isStructured) {\n                ret = false;\n            }\n            else {\n                if (Utils.eqNC(this.field || \"\", \"exists\")) {\n                    const dataValue = this.getDataValue(data, this.value, defaultScope);\n                    ret = !Utils.isUndefined(dataValue);\n                }\n                else if (Utils.eqNC(this.field || \"\", \"missing\")) {\n                    const dataValue = this.getDataValue(data, this.value, defaultScope);\n                    ret = Utils.isUndefined(dataValue);\n                }\n                else {\n                    const dataValue = this.getDataValue(data, this.field, defaultScope);\n                    switch (this.operator) {\n                        case ExprOperator.none:\n                        case ExprOperator.eq:\n                            ret = this.compare(this.value, dataValue, true) === 0;\n                            break;\n                        case ExprOperator.gt:\n                            ret = this.compare(this.value, dataValue) > 0;\n                            break;\n                        case ExprOperator.gte:\n                            ret = this.compare(this.value, dataValue) >= 0;\n                            break;\n                        case ExprOperator.lt:\n                            ret = this.compare(this.value, dataValue) < 0;\n                            break;\n                        case ExprOperator.lte:\n                            ret = this.compare(this.value, dataValue) <= 0;\n                            break;\n                        case ExprOperator.neq:\n                            ret = this.compare(this.value, dataValue, true) !== 0;\n                            break;\n                        case ExprOperator.regex: {\n                            const regExp = new RegExp(this.value || \"\");\n                            ret = regExp.test(dataValue + \"\");\n                            break;\n                        }\n                        case ExprOperator.like: // not currently generated in parse\n                            ret = this.compare(this.value + \"*\", dataValue, true) === 0;\n                            break;\n                        case ExprOperator.in:\n                            ret = this.compare(this.values, dataValue, true) === 0;\n                            break;\n                        case ExprOperator.contains: // not currently generated in parse\n                            ret = this.compare(this.value, dataValue, true) === 0;\n                            break;\n                        case ExprOperator.between:\n                            ret = !!this.values &&\n                                this.compare(this.values[0], dataValue) >= 0 && this.compare(this.values[1], dataValue) <= 0;\n                            break;\n                    }\n                }\n            }\n        }\n        else {\n            ret = !!this.and;\n            for (const operand of this.operands) {\n                const ret1 = operand.evaluate(data, defaultScope);\n                if (this.and) {\n                    ret = ret && ret1;\n                    if (!ret) {\n                        break;\n                    }\n                }\n                else {\n                    ret = ret || ret1;\n                }\n            }\n        }\n        if (this.not) {\n            ret = !ret;\n        }\n        return ret;\n    }\n}\n\n/**\n * @ignore\n */\nexport const enum Token {\n    invalid=-1,\n    or=0,\n    and=1,\n    not=2,\n    near=3,\n    infixNear=4,\n    lPar=5,\n    rPar=6,\n    eof=7,\n    value=8\n}\n\n/**\n * @ignore\n */\nconst enum Act {\n    s,  // shift\n    r,  // reduce\n    a,  // accept\n    e1, // error : missing right parenthesis\n    e2, // error : missing operator\n    e3, // error : unbalanced right parenthesis\n    e4  // error : invalid function argument\n}\n\n/**\n * Parsing options\n */\nexport interface ExprParserOptions {\n    /**\n     * If `true` then a fielded search expression with no value will not generate an error. This would be used\n     * when providing feedback during text entry\n     */\n    allowEmptyValues?: boolean;\n    /**\n     * If `true`, fields can contain the scoping character (`.`). This is typically used with `Expr.evaluate`\n     */\n    allowScopedFields?: boolean;\n    /**\n     * If `true` then arbitrary field names are permitted. This is typically used with `Expr.evaluate`\n     */\n    disallowFulltext?: boolean;\n}\n\n/**\n * @ignore\n */\nexport class ExprParserOperator {\n    public static invalid: ExprParserOperator = new ExprParserOperator(Token.invalid);\n    public static or: ExprParserOperator = new ExprParserOperator(Token.or);\n    public static and: ExprParserOperator = new ExprParserOperator(Token.and);\n    public static not: ExprParserOperator = new ExprParserOperator(Token.not);\n    public static lPar: ExprParserOperator = new ExprParserOperator(Token.lPar);\n    public static rPar: ExprParserOperator = new ExprParserOperator(Token.rPar);\n    public static eof: ExprParserOperator = new ExprParserOperator(Token.eof);\n\n    public tok: Token;\n    public tokValue: string;\n    public tokValuePos: number;\n    public tokValueLen: number;\n\n    constructor(tok: Token, value: string = \"\", valuePos: number = -1, valueLen: number = -1) {\n        this.tok = tok;\n        this.tokValue = value;\n        this.tokValuePos = valuePos;\n        this.tokValueLen = valueLen;\n    }\n}\n\n/**\n * A parser for Sinequa fielded search expressions. Such expressions allow filters to be specified in fulltext and\n * can be combined with boolean operators to build complex queries.\n *\n * A single fielded search clause has this form:\n * ``<fieldname>[`display value`]:[:][<operator>]<value>``\n *\n * A field name is either a column name or alias or a partname. In the case of a partname and column name clashing then\n * the field is treated as a column. Two colons can be specified as the separator to denote that the field is a partname.\n * An optional display value can follow the fieldname enclosed in backquote characters\n *\n * Operators are: `=` (default), `>=`, `>`, `<=`, `<`, `~` (regexp)\n * In addition, a regular expression can be specified by enclosing the value in `/` characters\n *\n * An inclusive range of values can be specified using a square bracket syntax: `[value1..value2]`\n * An exclusive range of values can be specified using a curly bracket syntax: `{value1..value2}`\n * The brackets can be mixed. For example: `age:{5..13]` expresses `13 >= age > 5`.\n *\n * For multi-value csv fields an `IN` condition can be expressed using a comma-separated list of values enclosed in square brackets.\n * For example: `authors:[Proust, Orwell, Dickens]`\n *\n * If a value contains reserved characters then it can be enclosed in backquote characters to prevent the parser interpreting them\n * incorrectly. For example: ``code: `a:b:c` ``\n *\n * The parser also supports a NEAR operator to allow searching for terms close to each other. There are two forms suppported:\n * * infix - `term1 NEAR[/n] term2` where `n` is the maximum number of words between the two terms for them to match\n * * function - `NEAR[/n](term1, term2, term3, ...)` where `n` is \"window\" size within which all the terms must be present for them\n * to match. The minimum useful value for n is thus equal to the number of terms passed to the operator.\n *\n * Fielded search expresions can be combined with the boolean operators `AND`, `OR` and `NOT` and brackets used for grouping.\n * For example: `football (age:>=7 AND (name:smith OR name:jones))`\n */\nexport class ExprParser {\n\n    public static fieldPartnamePrefix = \"@\";\n    private static parsetbl: Act[][] = [\n    /* stk  ------------- input ------------*/\n    /*\t\t                                 INFIX                  */\n    /*\t\t         OR\t   AND\t NOT   NEAR  NEAR  (\t  )\t     $  */\n    /*OR */         [Act.r, Act.s, Act.s, Act.s, Act.s, Act.s, Act.r, Act.r],\n    /*AND*/         [Act.r, Act.r, Act.s, Act.s, Act.s, Act.s, Act.r, Act.r],\n    /*NOT*/         [Act.r, Act.r, Act.s, Act.s, Act.r, Act.s, Act.r, Act.r],\n    /*NEAR*/        [Act.r, Act.r, Act.s, Act.s, Act.r, Act.s, Act.r, Act.r],\n    /*INFIXNEAR*/   [Act.r, Act.r, Act.s, Act.s, Act.r, Act.s, Act.r, Act.r],\n    /*(*/           [Act.s, Act.s, Act.s, Act.s, Act.s, Act.s, Act.s, Act.e1],\n    /*)*/           [Act.r, Act.r, Act.r, Act.r, Act.r, Act.e2, Act.r, Act.r],\n    /*$*/           [Act.s, Act.s, Act.s, Act.s, Act.s, Act.s, Act.e3, Act.a]\n    ];\n\n    private exprContext: ExprContext;\n    private options: ExprParserOptions;\n    private expressions: Expr[];\n    private operators: ExprParserOperator[];\n    private fields: string[]; // pushed on '(', popped on ')'\n    private displays: string[]; // pushed on '(', popped on ')'\n    private op: ExprParserOperator;\n    private prevOp: ExprParserOperator;\n    private saveOp: ExprParserOperator; // for default conjunction operator\n    private field: string;\n    private display: string;\n    private text: string;\n    private current: number;\n    private length: number;\n\n    private constructor(exprContext: ExprContext, options?: ExprParserOptions) {\n        this.exprContext = exprContext;\n        this.options = options || {};\n        this.exprContext.disallowFulltext = this.options.disallowFulltext;\n        this.expressions = [];\n        this.operators = [];\n        this.fields = [];\n        this.displays = [];\n        this.text = \"\";\n        this.current = 0;\n        this.length = 0;\n        this.op = this.prevOp = this.saveOp = ExprParserOperator.invalid;\n    }\n\n    /**\n     * Escape a string so that the characters in it are not processed by the fielded search expression parser.\n     * Single occurrences of the backslash character are replaced by two backslashes and backquote characters\n     * are prefixed by a backslash. Finally, the string is enclosed in backquotes.\n     *\n     * For example: `` a\\`\\b `` => `` a\\\\\\`\\\\b ``\n     */\n    // \\ => \\\\\n    // ` => \\`\n    // then surround with ``\n    public static escape(value: string | undefined): string {\n        if (!value) {\n            return \"``\";\n        }\n        value = String(value); // make sure we have a string\n        if (value.search(/[\\\\`]/) === -1) {\n            return \"`\" + value + \"`\";\n        }\n        const sb: string[] = [\"`\"];\n        for (let i = 0, ic = value.length; i < ic; i++) {\n            const ch = value[i];\n            if (ch === \"\\\\\" || ch === \"`\") {\n                sb.push(\"\\\\\");\n            }\n            sb.push(ch);\n        }\n        sb.push(\"`\");\n        return sb.join(\"\");\n    }\n\n    private static isEscaped(value: string | undefined): boolean {\n        return !!value && value.length >= 2 && value[0] === \"`\" && value[value.length - 1] === \"`\";\n    }\n\n    /**\n     * Perform the reverse operation to [ExprParser.escpae]{@link ExprParser#escape}\n     */\n    // remove surrounding ``\n    // \\\\ => \\\n    // \\` => `\n    public static unescape(value: string): string {\n        if (!ExprParser.isEscaped(value)) {\n            return value;\n        }\n        const sb: string[] = [];\n        for (let i = 1, ic = value.length - 1; i < ic; i++) {\n            let ch = value[i];\n            if (ch === \"\\\\\") {\n                if (i >= ic - 1) { // we end with a \\ => drop it\n                    continue;\n                }\n                ch = value[++i];\n            }\n            sb.push(ch);\n        }\n        return sb.join(\"\");\n    }\n\n    /**\n     * @ignore\n     */\n    public static unescapeList(values: string[]): string[] {\n        if (!values) {\n            return values;\n        }\n        const values1: string[] = [];\n        for (let _i = 0, _a = values; _i < _a.length; _i++) {\n            const value = _a[_i];\n            values1.push(ExprParser.unescape(value));\n        }\n        return values1;\n    }\n\n    /**\n     * @ignore\n     */\n    public static valuesAndLocationsFromText(text: string, separator: string): ExprValueLocation[] {\n        if (Utils.isEmpty(text)) {\n            return [];\n        }\n        if (!text.includes(separator)) {\n            return [{value: text, start: 0, length: text.length}];\n        }\n        const values: ExprValueLocation[] = [];\n        const length = text.length;\n        let current = 0;\n        let currentStart = 0;\n        const sb: string[] = [];\n        let value: ExprValueLocation;\n        while (true) {\n            if (current >= length) {\n                value = Expr.getValueAndLocation(sb.join(\"\"));\n                value.start += currentStart;\n                if (!Utils.isEmpty(value.value)) {\n                    values.push(value);\n                }\n                break;\n            }\n            const ch = text[current];\n            if (ch === \"\\\\\") {\n                sb.push(ch);\n                current++;\n                if (current < length) {\n                    const ch1 = text[current];\n                    if (ch1 === \"\\\\\" || ch1 === \"`\") {\n                        sb.push(ch1);\n                        current++;\n                    }\n                }\n            }\n            else if (ch === \"`\") {\n                const last: IRef<number> = {value: 0};\n                const s = ExprParser.matchUntil(text, length, current, current + 1, \"`\", last);\n                if (!!s) {\n                    sb.push(s);\n                    current = last.value;\n                }\n                else {\n                    sb.push(ch);\n                    current++;\n                }\n            }\n            else if (ch === separator) {\n                value = Expr.getValueAndLocation(sb.join(\"\"));\n                value.start += currentStart;\n                sb.length = 0;\n                if (!Utils.isEmpty(value.value)) {\n                    values.push(value);\n                }\n                current++;\n                currentStart = current;\n            }\n            else {\n                sb.push(ch);\n                current++;\n            }\n        }\n        return values;\n    }\n\n    private matchKeyword(keyword: string, sbCurrentValue: string[], suffixCh?: string): boolean {\n        if (sbCurrentValue.length !== 0) {\n            const currentValue = sbCurrentValue.join(\"\");\n            if (!!currentValue && !\" \\r\\n\\t\".includes(currentValue[currentValue.length - 1])) {\n                return false;\n            }\n        }\n        if (Utils.isEmpty(keyword)) {\n            return false;\n        }\n        const keywordLen = keyword.length;\n        if (this.current + keywordLen > this.length) {\n            return false;\n        }\n        for (let i = 0, ic = keywordLen; i < ic; i++) {\n            const ch = this.text[this.current + i];\n            const kh = keyword[i];\n            if (ch !== kh) {\n                return false;\n            }\n        }\n        if (this.current + keywordLen < this.length) {\n            const nch = this.text[this.current + keywordLen];\n            if (nch !== suffixCh && !\" \\r\\n\\t(\".includes(nch)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private matchUntil(first: number, start: number, endChars: string, last: IRef<number>): string | undefined {\n        return ExprParser.matchUntil(this.text, this.length, first, start, endChars, last);\n    }\n\n    private static matchUntil(text: string, length: number, first: number, start: number, endChars: string, last: IRef<number>): string | undefined {\n        last.value = start;\n        let found = false;\n        const sb: string[] = [text.substr(first, start - first)];\n        while (last.value < length) {\n            let ch = text[last.value++];\n            if (ch === \"\\\\\") {\n                sb.push(ch);\n                if (last.value < length) {\n                    ch = text[last.value++];\n                    if (ch === \"\\\\\" || ch === \"`\") {\n                        sb.push(ch);\n                        continue;\n                    }\n                }\n            }\n            sb.push(ch);\n            if (endChars.includes(ch)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return undefined;\n        }\n        return sb.join(\"\");\n    }\n\n    private matchSimpleValue(start: number): string {\n        const first = this.current;\n        let last = start;\n        while (last < this.length) {\n            const ch = this.text[last];\n            if (\" \\r\\n\\t)\".includes(ch)) {\n                break;\n            }\n            last++;\n        }\n        if (last === start) {\n            return \"\";\n        }\n        return this.text.substr(first, last - first);\n    }\n\n    private getTerminators(ch: string, allowRanges: boolean): string {\n        if (ch === \"\\\"\") return \"\\\"\";\n        if (ch === \"[\") return allowRanges ? \"]}\" : \"]\";\n        if (ch === \"{\") return allowRanges ? \"}]\" : \"}\";\n        if (ch === \"/\") return \"/\";\n        if (ch === \"(\") return \")\";\n        if (ch === \"`\") return \"`\";\n        return \"\";\n    }\n\n    private canBeTokValue(value: string, canBeEmpty = true) {\n        return !Utils.isEmpty(value) || (canBeEmpty && this.options.allowEmptyValues && !Utils.isEmpty(this.field));\n    }\n\n    private _getTokValue(value: string, canBeEmpty = true): boolean {\n        // Current is pointing at the next non-whitepspace character after this value\n        if (value === null) return false;\n        let pos = this.current;\n        const len = value.length;\n        value = Utils.trimEnd(value);\n        pos -= len - value.length;\n        value = value.trim();\n        if (this.canBeTokValue(value, canBeEmpty)) {\n            this.op = new ExprParserOperator(Token.value, value, pos - value.length, value.length);\n            return true;\n        }\n        return false;\n    }\n\n    private getTokValue(sb: string[], canBeEmpty = true): boolean {\n        if (!sb) {\n            return false;\n        }\n        return this._getTokValue(sb.join(\"\"), canBeEmpty);\n    }\n\n    private ensureNearValue(value: string): string {\n        const defaultNearValue = this.exprContext.appService.ccquery ? this.exprContext.appService.ccquery.defaultNearValue : 0;\n        let near = Utils.toInt(value, defaultNearValue);\n        if (near < 0) {\n            near = defaultNearValue;\n        }\n        return near.toString();\n    }\n\n    private findDisplay(value: string): number {\n        if (!value || value.length < 3) {\n            return -1;\n        }\n        if (value[value.length - 1] !== \"`\") {\n            return -1;\n        }\n        let pos = value.length - 2;\n        while (pos !== -1) {\n            pos = value.lastIndexOf(\"`\", pos);\n            if (pos !== -1) {\n                let escapes = 0;\n                let pos1 = pos - 1;\n                while (pos1 >= 0) {\n                    if (value[pos1] !== \"\\\\\") {\n                        break;\n                    }\n                    escapes++;\n                    pos1--;\n                }\n                if (escapes % 2 === 0) {\n                    return pos;\n                }\n                pos--;\n            }\n        }\n        return -1;\n    }\n\n    private isValidFieldName(name: string): boolean {\n        return this.options.allowScopedFields ? Utils.isValidScopedSimpleName(name) : Utils.isValidSimpleName(name);\n    }\n\n    private isAllowedField(field: string, forcePartname: boolean, isPartname: IRef<boolean>): boolean {\n        isPartname.value = false;\n        if (Utils.eqNCN(field, \"exists\", \"missing\")) {\n            return true;\n        }\n        if (Utils.eqNCN(field, \"text\", \"concepts\", \"refine\", \"matchingpartnames\")) {\n            // NB @concepts, @refine and @matchingpartnames must be handled specially by the caller\n            isPartname.value = true;\n            return true;\n        }\n        const ccquery = this.exprContext.appService.ccquery;\n        if (ccquery) {\n            forcePartname = forcePartname && !this.exprContext.disallowFulltext;\n            let column = forcePartname ? undefined : this.exprContext.appService.getColumn(field);\n            if (!!column) {\n                if (column.eType === EngineType.varchar) { // only type not indexed\n                    column = undefined;\n                }\n                else if ((ccquery.$columnFieldsPattern && ccquery.$columnFieldsPattern.hasPatterns()) &&\n                    !ccquery.$columnFieldsPattern.isIncluded(field) &&\n                    !ccquery.$columnFieldsPattern.isIncluded(column.name)) {\n                    column = undefined;\n                }\n            }\n            if (!this.exprContext.disallowFulltext && !column) {\n                isPartname.value = true;\n                if ((ccquery.$partnameFieldsPattern && ccquery.$partnameFieldsPattern.hasPatterns()) &&\n                    !ccquery.$partnameFieldsPattern.isIncluded(field)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private readToken(): string | undefined {\n        if (this.saveOp !== ExprParserOperator.invalid) {\n            this.prevOp = this.op;\n            this.op = this.saveOp;\n            this.saveOp = ExprParserOperator.invalid;\n            return undefined;\n        }\n        let ch;\n        this.prevOp = this.op;\n        let nextValue: string | undefined;\n        const sbCurrentValue: string[] = [];\n        let candidateFieldPos = -1;\n        let fieldSpecified = false;\n        while (true) {\n            if (this.current >= this.length) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.eof;\n                return undefined;\n            }\n            ch = this.text[this.current];\n            if (ch === \"\\\\\") { // \\ escapes \\ and `\n                sbCurrentValue.push(ch);\n                this.current++;\n                if (this.current < this.length) {\n                    const ch1 = this.text[this.current];\n                    if (ch1 === \"\\\\\" || ch1 === \"`\") {\n                        sbCurrentValue.push(ch1);\n                        this.current++;\n                    }\n                }\n            }\n            else if (ch === \"(\") {\n                if (this.getTokValue(sbCurrentValue, false)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.lPar;\n                this.current++;\n                return undefined;\n            }\n            else if (ch === \")\") {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.rPar;\n                this.current++;\n                return undefined;\n            }\n            else if (this.matchKeyword(\"AND\", sbCurrentValue)) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.and;\n                this.current += 3;\n                return undefined;\n            }\n            else if (this.matchKeyword(\"OR\", sbCurrentValue)) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.or;\n                this.current += 2;\n                return undefined;\n            }\n            else if (this.matchKeyword(\"NOT\", sbCurrentValue)) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.op = ExprParserOperator.not;\n                this.current += 3;\n                return undefined;\n            }\n            else if (this.matchKeyword(\"NEAR\", sbCurrentValue, \"/\")) {\n                if (this.getTokValue(sbCurrentValue)) {\n                    return undefined;\n                }\n                this.current += 4;\n                nextValue = undefined;\n                if (this.current < this.length && this.text[this.current] === \"/\") {\n                    const last: IRef<number> = {value: 0};\n                    nextValue = this.matchUntil(this.current + 1, this.current + 1, \" \\r\\n\\t`\\\"([/\", last);\n                    let near = -1;\n                    if (nextValue !== undefined) {\n                        nextValue = nextValue.substr(0, nextValue.length - 1);\n                        near = Utils.toInt(nextValue, -1);\n                    }\n                    if (near < 0) {\n                        return \"bad operator\";\n                    }\n                    this.current = last.value - 1;\n                }\n                nextValue = this.ensureNearValue(nextValue || \"\");\n                const infix = this.current >= this.length || this.text[this.current] !== \"(\";\n                // For infix, near value is the number of words between the two terms so add the 2 terms to\n                // the window (near/0 = adjacent terms)\n                this.op = infix ?\n                    new ExprParserOperator(Token.infixNear, (Utils.toInt(nextValue) + 2).toString()) :\n                    new ExprParserOperator(Token.near, nextValue);\n                return undefined;\n            }\n            else if (ch === \"+\" || ch === \"-\") {\n                if (this.current + 1 < this.length) {\n                    const ch1 = this.text[this.current + 1];\n                    const last: IRef<number> = {value: 0};\n                    let length: number;\n                    if (\"(\\\"[/`\".includes(ch1)) { // ( \" [ / `\n                        nextValue = this.matchUntil(this.current, this.current + 2, this.getTerminators(ch1, false), last);\n                        length = last.value - this.current;\n                    }\n                    else {\n                        nextValue = this.matchSimpleValue(this.current + 1);\n                        length = !!nextValue ? nextValue.length : 0;\n                    }\n                    if (!!nextValue) {\n                        sbCurrentValue.push(nextValue);\n                        this.current += length;\n                        continue;\n                    }\n                }\n                return \"bad operator: \" + ch;\n            }\n            else if (\"\\\"[{/`\".includes(ch)) { // \" [ { / `\n                const last: IRef<number> = {value: 0};\n                nextValue = this.matchUntil(this.current, this.current + 1, this.getTerminators(ch, true), last);\n                if (!!nextValue) {\n                    const forceRange = (fieldSpecified && \"[{\".includes(ch) && sbCurrentValue.length === 0);\n                    sbCurrentValue.push(nextValue);\n                    this.current = last.value;\n                    if (forceRange && this.getTokValue(sbCurrentValue)) {\n                        return undefined;\n                    }\n                    continue;\n                }\n                return \"bad operator: \" + ch;\n            }\n            else {\n                if (ch === \":\") { // Field\n                    // Pick out previous value and/or field name\n                    // Field specifier can be:\n                    // field:value\n                    // field`display`:value\n                    // `display`:value\n                    const currentValue = sbCurrentValue.join(\"\");\n                    if (candidateFieldPos === -1) {\n                        // Check for display\n                        candidateFieldPos = this.findDisplay(currentValue);\n                        if (candidateFieldPos === -1) {\n                            this.op = ExprParserOperator.invalid;\n                            return \"invalid token\";\n                        }\n                    }\n                    let field = currentValue.substr(candidateFieldPos).trim();\n                    let display = \"\";\n                    // Extract display\n                    const displayStart = this.findDisplay(field);\n                    if (displayStart !== -1) {\n                        display = ExprParser.unescape(field.substr(displayStart, field.length - displayStart));\n                        field = field.substr(0, displayStart);\n                    }\n                    if (this.isValidFieldName(field) || (Utils.isEmpty(field) && !Utils.isEmpty(display))) {\n                        const value = currentValue.substr(0, candidateFieldPos);\n                        if (this.canBeTokValue(value.trim())) {\n                            this.current -= (sbCurrentValue.join(\"\").length - candidateFieldPos); // back up to field\n                            this._getTokValue(value);\n                            return undefined;\n                        }\n                        if (!Utils.isEmpty(field)) {\n                            let forcePartname = false;\n                            if (this.current + 1 < this.length && this.text[this.current + 1] === \":\") {\n                                // :: => force partname over column\n                                forcePartname = true;\n                                this.current++;\n                            }\n                            const isPartname: IRef<boolean> = { value: false };\n                            if (!this.isAllowedField(field, forcePartname, isPartname)) {\n                                candidateFieldPos = -1;\n                                sbCurrentValue.push(\":\");\n                                if (forcePartname) {\n                                    sbCurrentValue.push(\":\");\n                                }\n                                this.current++;\n                                continue;\n                            }\n                            if (isPartname.value) {\n                                field = ExprParser.fieldPartnamePrefix + field;\n                            }\n                        }\n                        if (!Utils.isEmpty(field)) {\n                            this.field = field;\n                            fieldSpecified = true;\n                        }\n                        if (!Utils.isEmpty(display)) {\n                            this.display = display;\n                        }\n                        sbCurrentValue.length = 0;\n                        this.current++;\n                        continue;\n                    }\n                }\n                if (\" \\r\\n\\t)\".includes(ch)) {\n                    candidateFieldPos = -1;\n                }\n                else if (candidateFieldPos === -1) {\n                    candidateFieldPos = sbCurrentValue.join(\"\").length;\n                }\n                sbCurrentValue.push(ch);\n                this.current++;\n            }\n        }\n    }\n\n    private clear() {\n        this.text = \"\";\n        this.current = 0;\n        this.length = 0;\n        this.operators.length = 0;\n        this.expressions.length = 0;\n        this.fields.length = 0;\n        this.displays.length = 0;\n    }\n\n    /**\n     * Parse some text using the Sinequa fielded search syntax\n     *\n     * @return The parsed `Expr` or an error string\n     */\n    public static parse(text: string, context: ExprContext, options?: ExprParserOptions): Expr | string {\n        const parser = new ExprParser(context, options);\n        const error = parser.parse(text);\n        if (error) {\n            return error;\n        }\n        return parser.parseResult();\n    }\n\n    private parseResult(): Expr | string {\n        if (this.expressions.length !== 1) {\n            return \"no expression found\";\n        }\n        return this.expressions[0];\n    }\n\n    private get contextField(): string {\n        let field = this.field;\n        if (Utils.isEmpty(field)) {\n            field = this.peekField();\n        }\n        return field;\n    }\n\n    private get contextDisplay(): string {\n        let display = this.display;\n        if (Utils.isEmpty(display)) {\n            display = this.peekDisplay();\n        }\n        return display;\n    }\n\n    private parse(text: string): string {\n        this.clear();\n        if (this.options.allowEmptyValues && !Utils.len(text.trim())) {\n            const expr = Expr.makeExpr(this.exprContext, \"\", this.contextField, this.contextDisplay, this.options.allowEmptyValues);\n            if (expr) {\n                expr.start = 0;\n                expr.length = 0;\n                this.expressions.push(expr);\n            }\n            return \"\";\n        }\n        this.text = text || \"\";\n        this.length = this.text.length;\n        this.operators.push(ExprParserOperator.eof);\n        let err = this.readToken();\n        if (err) {\n            return err;\n        }\n        while (true) {\n            if ((this.op.tok === Token.value || this.op.tok === Token.lPar || this.op.tok === Token.not || this.op.tok === Token.near) &&\n                (this.prevOp.tok === Token.value || this.prevOp.tok === Token.rPar)) {\n                // Default to AND for space separated terms\n                // NOT xxx => AND NOT xxx\n                this.saveOp = this.op;\n                this.op = ExprParserOperator.and;\n            }\n\n            let a: Act;\n            if (this.op.tok === Token.value) {\n                a = Act.s;\n            }\n            else {\n                a = ExprParser.parsetbl[this.operators[this.operators.length - 1].tok][this.op.tok];\n            }\n            switch (a) {\n                case Act.r:\n                    err = this.reduce();\n                    if (err) {\n                        return err;\n                    }\n                    break;\n                case Act.s:\n                    err = this.shift();\n                    if (err) {\n                        return err;\n                    }\n                    break;\n                case Act.a:\n                    if (this.expressions.length !== 1) {\n                        return \"syntax error\";\n                    }\n                    return \"\";\n                case Act.e1:\n                    return \"missing ')'\";\n                case Act.e2:\n                    return \"missing operator (AND,OR,NOT)\";\n                case Act.e3:\n                    return \"missing '('\";\n                case Act.e4:\n                    return \"invalid argument\";\n            }\n        }\n    }\n\n    private shift(): string | undefined {\n        if (this.op.tok === Token.value) {\n            const value = this.op.tokValue.trim();\n            if (Utils.isEmpty(value) && !this.options.allowEmptyValues) {\n                return \"empty token\";\n            }\n            const expr = Expr.makeExpr(this.exprContext, value, this.contextField, this.contextDisplay, !!this.options.allowEmptyValues);\n            if (!expr) {\n                return \"invalid expression\";\n            }\n            expr.start = this.op.tokValuePos;\n            expr.length = this.op.tokValueLen;\n            if (!!expr.operands) {\n                expr.operands.forEach(operand => {\n                    operand.start = this.op.tokValuePos;\n                    operand.length = this.op.tokValueLen;\n                });\n            }\n            this.expressions.push(expr);\n            this.field = \"\";\n            this.display = \"\";\n        }\n        else {\n            this.operators.push(this.op);\n            if (this.op.tok === Token.lPar) {\n                if (Utils.isEmpty(this.field)) {\n                    this.fields.push(this.peekField());\n                }\n                else {\n                    this.fields.push(this.field);\n                }\n                this.field = \"\";\n                if (Utils.isEmpty(this.display)) {\n                    this.displays.push(this.peekDisplay());\n                }\n                else {\n                    this.displays.push(this.display);\n                }\n                this.display = \"\";\n            }\n        }\n        return this.readToken();\n    }\n\n    private peekField(): string {\n        if (this.fields.length === 0) {\n            return \"\";\n        }\n        return this.fields[this.fields.length - 1];\n    }\n\n    private peekDisplay(): string {\n        if (this.displays.length === 0) {\n            return \"\";\n        }\n        return this.displays[this.displays.length - 1];\n    }\n\n    private canBeMergeTarget(e: Expr, and: boolean): boolean {\n        if (e.isLeaf) {\n            return false;\n        }\n        if (e.near >= 0) {\n            return false;\n        }\n        if (e.and !== and) {\n            return false;\n        }\n        if (e.not) {\n            return false;\n        }\n        return true;\n    }\n\n    private mergeExpr(e1: Expr, e2: Expr, and: boolean): Expr {\n        let source: Expr, target: Expr;\n        let prepend = false;\n        if (this.canBeMergeTarget(e1, and)) {\n            target = e1;\n            source = e2;\n        }\n        else if (this.canBeMergeTarget(e2, and)) {\n            target = e2;\n            source = e1;\n            prepend = true; // to keep the same order as in the input text\n        }\n        else {\n            return new Expr({\n                exprContext: e1.exprContext,\n                op1: e1,\n                and,\n                op2: e2,\n                field: this.peekField(),\n                display: this.peekDisplay()\n            });\n        }\n        if (source.isLeaf || source.and !== and || source.not || !Utils.eq(source.display || \"\", target.display || \"\")) {\n            target.addOperand(source, this.peekField(), prepend);\n        }\n        else {\n            if (source.operands) {\n                for (const operand of source.operands) {\n                    target.addOperand(operand, this.peekField(), prepend);\n                }\n            }\n        }\n        return target;\n    }\n\n    private reduce(): string | undefined {\n        let e: Expr | undefined;\n        let e1: Expr | undefined;\n        let e2: Expr | undefined;\n        const op: ExprParserOperator = this.operators[this.operators.length - 1];\n        switch (op.tok) {\n            case Token.not:\n                // Apply E := NOT E\n                e = this.expressions.pop();\n                if (!e) {\n                    return \"syntax error\";\n                }\n                e.not = !e.not;\n                this.expressions.push(e);\n                break;\n            case Token.and:\n                e2 = this.expressions.pop();\n                e1 = this.expressions.pop();\n                if (!e1 || !e2) {\n                    return \"syntax error\";\n                }\n                this.expressions.push(this.mergeExpr(e1, e2, true));\n                break;\n            case Token.or:\n                e2 = this.expressions.pop();\n                e1 = this.expressions.pop();\n                if (!e1 || !e2) {\n                    return \"syntax error\";\n                }\n                this.expressions.push(this.mergeExpr(e1, e2, false));\n                break;\n            case Token.near:\n                e = this.expressions.pop();\n                if (!e) {\n                    return \"syntax error\";\n                }\n                e.near = Utils.toInt(this.ensureNearValue(op.tokValue));\n                this.expressions.push(e);\n                break;\n            case Token.infixNear:\n                e2 = this.expressions.pop();\n                e1 = this.expressions.pop();\n                if (!e1 || !e2) {\n                    return \"syntax error\";\n                }\n                if (!e2.isLeaf || e2.isStructured || !e1.isLeaf || e1.isStructured || e2.not || e1.not || !Utils.eqNC(e2.field || \"\", e1.field || \"\")) {\n                    return \"syntax error\";\n                }\n                e = new Expr({\n                    exprContext: e1.exprContext,\n                    op1: e1,\n                    and: false,\n                    op2: e2,\n                    field: this.peekField(),\n                    display: this.peekDisplay()\n                });\n                e.near = Utils.toInt(this.ensureNearValue(op.tokValue));\n                this.expressions.push(e);\n                break;\n            case Token.rPar:\n                this.operators.pop();\n                if (this.fields.length === 0) {\n                    return \"missing field\";\n                }\n                if (this.expressions.length === 0) {\n                    return \"syntax error\";\n                }\n                const field = this.fields.pop();\n                const display = this.displays.pop();\n                // Set Field for single term bracketed expressions\n                e = this.expressions[this.expressions.length - 1];\n                if (e.isLeaf) {\n                    if (Utils.isEmpty(e.field)) {\n                        e.field = field;\n                    }\n                    if (Utils.isEmpty(e.display)) {\n                        e.display = display;\n                    }\n                }\n                break;\n        }\n        this.operators.pop();\n        return undefined;\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Utils } from '@sinequa/core/base';\nimport { Aggregation, AggregationItem, TreeAggregationNode } from '@sinequa/core/web-services';\nimport { ValueItem } from '../format.service';\nimport { ExprParser } from './expr-parser';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class ExprBuilder {\n\n    /**\n     * Make a standard selection expression\n     * (resulting in a SQL clause like \"company contains 'BOEING'\")\n     * @param field Name of the field to select (eg. \"company\")\n     * @param value Value of the field to select (eg. \"BOEING\")\n     * @param display Optional string to display that value (eg. \"Boeing\")\n     */\n    makeExpr(field: string, value: string, display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: ${ExprParser.escape(value)}`; // company`Boeing`: BOEING\n    }\n\n    /**\n     * Make a boolean expression\n     * @param field Name of the field to select (eg. \"toto\")\n     * @param value Value of the field to select (eg. \"true\")\n     * @param display Optional string to display that value (eg. \"True\")\n     */\n    makeBooleanExpr(field: string, value: boolean, display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: ${ExprParser.escape(Utils.toSqlValue(value))}`; // toto`True`: true\n    }\n\n\n    /**\n     * Make a numerical expression using a comparison operator (>, <, <=, >=, etc.)\n     * @param field Name of the field to select (eg. \"modified\")\n     * @param operator Comparison operator used for that selection (eg. \">\")\n     * @param value Value of the field to select (eg. \"2020-12-15\")\n     * @param display Optional string to display that value (eg. \"After Dec 15 2020\")\n     */\n    makeNumericalExpr(\n        field: string,\n        operator: '>' | '>=' | '<' | '<=' | '=' | '<>',\n        value: number | Date | string,\n        display?: string): string {\n\n        field = this.formatField(field, display);\n\n        if(Utils.isString(value)) {\n            value = ExprParser.escape(value);\n        }\n        if(Utils.isDate(value) || Utils.isNumber(value)) {\n            value = Utils.toSqlValue(value);\n        }\n\n        return `${field}:${operator} ${value}`; // modified`After Dec 15 2020`:> 2020-12-15\n    }\n\n\n    /**\n     * Make a list expression\n     * @param field Name of the field to select (eg. \"docformat\")\n     * @param values Values of the field to select (eg. ['htm','pdf'])\n     * @param display Optional string to display that value (eg. \"htm, pdf\")\n     */\n    makeListExpr(field: string, values: string[], display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: [${values.map(v => ExprParser.escape(v)).join(',')}]`; // docformat`htm, pdf`:[`htm`,`pdf`]\n    }\n\n\n    /**\n     * Make a range expression\n     * @param field Name of the field to select (eg. \"modified\")\n     * @param from Begining of the range (eg. 2020-12-15)\n     * @param to End of the range (eg. 2020-12-20)\n     * @param display Optional string to display that value (eg. \"[Dec 15 2020, Dec 20 2020]\")\n     */\n    makeRangeExpr(\n        field: string,\n        from: number | Date | string,\n        to: number | Date | string,\n        display?: string): string {\n\n        field = this.formatField(field, display);\n        return `${field}: [${Utils.toSqlValue(from)}..${Utils.toSqlValue(to)}]`; // modified`[Dec 15 2020, Dec 20 2020]`: [2020-12-15..2020-12-20]\n    }\n\n\n    /**\n     * Make a RegExp expression\n     * @param field Name of the field to select (eg. \"company\")\n     * @param value Value of the regular expression to match (eg. \"BOE.*\")\n     * @param display Optional string to display that value (eg. \"Boe...\")\n     */\n    makeRegexpExpr(field: string, value: string, display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}:~ ${ExprParser.escape(value)}`; // company`Boe...`:~ BOE.*\n    }\n\n\n    /**\n     * Make a refine expression\n     * @param text The text to add to the query\n     */\n    makeRefineExpr(text: string): string {\n        return `refine: ${ExprParser.escape(text)}`;\n    }\n\n\n    /**\n     * Return an expression that selects multiple values for a field\n     * (All values are ANDed)\n     * @param field Name of the field to select (eg. \"company\")\n     * @param values Values of the field to select (eg. ['IBM','APPLE'])\n     * @param display Optional string to display that value (eg. \"IBM and Apple\")\n     */\n    makeAndExpr(field: string, values: (string | ValueItem)[], display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: (${this.concatWithOperator(values, 'AND')})`; // company: (IBM AND APPLE AND GOOGLE)\n    }\n\n\n    /**\n     * Return an expression that selects multiple values for a field\n     * (All values are ORed)\n     * This function should be equivalent to using makeListExpr\n     * @param field Name of the field to select (eg. \"company\")\n     * @param values Values of the field to select (eg. ['IBM','APPLE'])\n     * @param display Optional string to display that value (eg. \"IBM and Apple\")\n     */\n    makeOrExpr(field: string, values: (string | ValueItem)[], display?: string): string {\n        field = this.formatField(field, display);\n        return `${field}: (${this.concatWithOperator(values, 'OR')})`; // company: (IBM OR APPLE OR GOOGLE)\n    }\n\n    /**\n     * Combine a list of values with AND or OR operators\n     * @param values the list of values\n     * @param operator the operator\n     */\n    private concatWithOperator(values: (string | ValueItem)[], operator: 'AND' | 'OR') {\n        return values.map(v => {\n            if (Utils.isString(v)){\n                return ExprParser.escape(v);\n            }\n            if (v.display) {\n                return `${ExprParser.escape(v.display)}:${ExprParser.escape(Utils.toSqlValue(v.value))}`;\n            }\n            return ExprParser.escape(Utils.toSqlValue(v.value));\n        }).join(' '+operator+' ');\n    }\n\n    /**\n     * Returns the negative expression of the given expression\n     * eg. NOT(person:Bill GATES)\n     * @param expr\n     */\n    makeNotExpr(expr: string): string {\n        return `NOT (${expr})`;\n    }\n\n    /**\n     * Returns an expression that is the union of given expressions\n     * eg. person:Bill GATES OR company:MICROSOFT\n     * @param exprs\n     */\n    concatOrExpr(exprs: string[]): string {\n        if (exprs.length <= 1) {\n            return exprs[0] || '';\n        }\n        return `(${exprs.join(') OR (')})`;\n    }\n\n\n    /**\n     * Returns an expression that is the intersection of given expressions\n     * eg. person:Bill GATES AND company:MICROSOFT\n     * @param exprs\n     */\n    concatAndExpr(exprs: string[]): string {\n        if (exprs.length <= 1) {\n            return exprs[0] || '';\n        }\n        return `(${exprs.join(') AND (')})`;\n    }\n\n\n    /**\n     * Returns an expression to select the given item\n     * @param field Name of the field to select (eg. \"company\")\n     * @param items A single or list of ValueItem object(s) (eg. content of a record)\n     */\n    makeFieldExpr(field: string, items: ValueItem | ValueItem[], combineWithAnd?: boolean): string {\n        if(!Utils.isArray(items)) {\n            items = [items];\n        }\n        if(items.length === 0) {\n            return \"\"; // Return a falsy string instead of \"()\" or \"``\" which would be truthy\n        }\n        return combineWithAnd? this.makeAndExpr(field, items) : this.makeOrExpr(field, items);\n    }\n\n    /**\n     * Create an expression for the given aggregation item\n     * @param aggregation The aggregation containing this object\n     * @param items The AggregationItem(s) to select\n     * @param combineWithAnd If there are multiple values, combine them with AND (instead of OR)\n     */\n    makeAggregationExpr(aggregation: Aggregation, items: AggregationItem | AggregationItem[], combineWithAnd?: boolean): string {\n        if(!Utils.isArray(items)) {\n            items = [items];\n        }\n        if(aggregation.valuesAreExpressions) {\n            const exprs = items.map(i => i.value.toString()); // .toString() is to avoid typing issues. With valuesAreExpressions = true, item.value is expected to be a string\n            return combineWithAnd? this.concatAndExpr(exprs) : this.concatOrExpr(exprs);\n        }\n        else {\n            const _items = this.asValueItems(items, aggregation.isTree);\n            return this.makeFieldExpr(aggregation.column, _items, combineWithAnd);\n        }\n    }\n\n\n    /**\n     * Combines the field with the optional display value(s)\n     * @param field\n     * @param display\n     */\n    private formatField(field: string, display?: string): string {\n        if(display) {\n            field = `${field}${ExprParser.escape(display)}`;\n        }\n        return field;\n    }\n\n\n    /**\n     * Return the AggregationItem list as a ValueItem list\n     * @param items\n     * @param isTree\n     */\n    private asValueItems(items: AggregationItem[], isTree?: boolean): ValueItem[] {\n        if(isTree) {\n            return items.map(i => {\n                return {\n                    value: (i as TreeAggregationNode).$path + \"*\",\n                    display: i.display || i.value as string\n                };\n            });\n        }\n        return items; // This works because ValueItem and AggregationItem share the value and display properties\n    }\n}\n","import {Utils, MapOf} from \"@sinequa/core/base\";\nimport {IQuery, Select, Open, SpellingCorrectionMode, AggregationOptions} from \"@sinequa/core/web-services\";\n\n\nexport const advancedFacetPrefix = \"advanced_\";\n\n/**\n * Represents a query for retrieving search results from a Sinequa search engine.\n *\n * The properties are described in the {@link IQuery} interface\n */\nexport class Query implements IQuery {\n    text?: string;\n    action: \"\" | \"search\" | \"open\" | \"aggregate\";\n    select?: Select[];\n    open?: Open[];\n    page?: number;\n    pageSize?: number;\n    tab?: string;\n    scope?: string;\n    sort?: string;\n    basket?: string;\n    isFirstPage?: boolean;\n    strictRefine?: boolean;\n    globalRelevance?: number;\n    questionLanguage?: string;\n    questionDefaultLanguage?: string;\n    spellingCorrectionMode?: SpellingCorrectionMode;\n    spellingCorrectionFilter?: string;\n    documentWeight?: string;\n    textPartWeights?: string;\n    relevanceTransforms?: string;\n    removeDuplicates?: boolean;\n    queryId?: string;\n    aggregations: MapOf<AggregationOptions> | string[];\n    orderBy?: string;\n    groupBy?: string;\n\n    /**\n     * Return a copy of the passed query\n     */\n    static copy(query: Query): Query {\n        if (!query) {\n            return query;\n        }\n        return query.copy();\n    }\n\n    constructor(\n        public name: string) {\n    }\n\n    /**\n     * Return `true` if the query has fulltext search elements\n     */\n    get hasRelevance(): boolean {\n        if (!Utils.isEmpty(this.text)) {\n            return true;\n        }\n        if (this.findSelect(\"refine\")) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Add a select filter to the query\n     *\n     * @param expr The fielded search expression to filter the results\n     * @param facet The name of the associated facet\n     */\n    addSelect(expr: string, facet?: string): number {\n        return this.pushSelect({\n            expression: expr,\n            facet: facet || \"\"\n        });\n    }\n\n    /**\n     * Adds a new `Select` object to the end of the query's `selects`\n     */\n    pushSelect(select: Select): number {\n        if (!this.select) {\n            this.select = [];\n        }\n        return this.select.push(select);\n    }\n\n    /**\n     * Remove the last `Select` object from the `selects` and return it\n     */\n    popSelect(): Select | undefined {\n        if (!this.select) {\n            return undefined;\n        }\n        return this.select.pop();\n    }\n\n    /**\n     * Remove the `Select` object identified by `indexOrFacet`\n     *\n     * @param indexOrFacet either an index in the `selects` array or a facet name\n     * @param all If `true` and `indexOrFacet` is a facet name then all `Select` objects with a matching facet name will be removed\n     */\n    removeSelect(indexOrFacet: number | string, all = false): void {\n        if (!this.select) {\n            return;\n        }\n        if (Utils.isString(indexOrFacet)) {\n            // indexOrFacet is a facet name\n            for (let i = this.select.length - 1; i >= 0; i--) {\n                const _select = this.select[i];\n                if (Utils.eqNC(_select.facet, indexOrFacet)) {\n                    this.select.splice(i, 1);\n                    if (this.select.length === 0) {\n                        delete this.select; // Clean the query if no more select\n                        return;\n                    }\n                    if (!all) {\n                        return;\n                    }\n                }\n            }\n        }\n        else {\n            if (indexOrFacet < 0 || indexOrFacet >= this.select.length) {\n                return;\n            }\n            this.select.splice(indexOrFacet, 1);\n            if (this.select.length === 0) {\n                delete this.select;\n            }\n        }\n    }\n\n    /**\n     * Replace a `Select` with another\n     *\n     * @param index The index in the `selects` array of the `Select to replace\n     * @param select The `Select` to use as a replacement\n     */\n    replaceSelect(index: number, select: Select) {\n        if (!this.select) {\n            return;\n        }\n        this.select.splice(index, 1, select);\n    }\n\n    /**\n     * Find the index of the nth `Select` object matching the passed facet name\n     *\n     * @param facet A facet name\n     * @param ordinal Specifies which `Select` object to retrieve among selects with the same facet name\n     */\n    findSelectIndex(facet: string, ordinal = 0): number {\n        if (!this.select) {\n            return -1;\n        }\n        let index = 0;\n        let facetOrdinal = 0;\n        let facetIndex = -1;\n        for (const select of this.select) {\n            if (Utils.eqNC(facet, select.facet)) {\n                facetIndex = index;\n                if (facetOrdinal === ordinal) {\n                    break;\n                }\n                facetOrdinal++;\n            }\n            index++;\n        }\n        return facetIndex;\n    }\n\n    /**\n     * Find the first `Select` matching the passed facet name\n     *\n     * @param facet A facet name\n     * @param fromEnd If `true` start searching backwards from the last `Select`\n     */\n    findSelect(facet: string, fromEnd = true): Select | undefined {\n        const facetSelectIndex = this.findSelectIndex(facet, fromEnd ? -1 : 0);\n        return facetSelectIndex >= 0 ? this.select && this.select[facetSelectIndex] : undefined;\n    }\n\n    /**\n     * Return the last `Select` object\n     */\n    lastSelect(): Select | undefined {\n        if (!this.select) {\n            return undefined;\n        }\n        return this.select[this.select.length - 1];\n    }\n\n    /**\n     * Return the number of `Select` objects\n     */\n    get selectLength(): number {\n        if (!this.select) {\n            return 0;\n        }\n        return this.select.length;\n    }\n\n    /**\n     * Add an `Open` filter to the query. This is typically used to load children of tree nodes\n     *\n     * @param expr The fielded search expression specifying the node to expand\n     * @param aggregation The associated aggregation\n     */\n    addOpen(expr: string, aggregation: string) {\n        if (!this.open || !Utils.isArray(this.open)) {\n            this.open = [];\n        }\n        return this.open.push({\n            expression: expr,\n            aggregation\n        });\n    }\n\n    /**\n     * Clear all fields in the query except the name\n     */\n    clear(): void {\n        const name = this.name;\n        Utils.clearObject(this);\n        this.name = name;\n    }\n\n    /**\n     * Remove advanced search select(s) from the query\n     */\n    toStandard(): Query {\n        const advancedSelect = this.select?.filter(\n          (select: Select) => select.facet && select.facet.startsWith(advancedFacetPrefix)\n        )\n        advancedSelect?.forEach(\n          (select) => this.removeSelect(select.facet, true)\n        )\n        return this;\n    }\n\n    /**\n     * Return a copy of this query\n     */\n    copy(): Query {\n        const query = new Query(this.name);\n        Utils.copy(this, query);\n        return query;\n    }\n\n    /**\n     * Return a copy of this query but without any advanced select\n     */\n    copyStandard(): Query {\n        const query = this.copy();\n        return query.toStandard();\n    }\n\n    /**\n     * Remove all properties from the query except advanced search select(s) and optionally `text`\n     *\n     * @param withText If `true` do not remove the `text` field\n     */\n    toAdvanced(withText: boolean = false): Query {\n        for (const property in this) {\n            if (this.hasOwnProperty(property) && !Utils.eqNC(property, \"select\") && (!withText || !Utils.eqNC(property, \"text\"))) {\n                delete this[property];\n            }\n        }\n        const notAdvancedSelect = this.select?.filter(\n          (select: Select) => select.facet && !select.facet.startsWith(advancedFacetPrefix)\n        )\n        notAdvancedSelect?.forEach(\n          (select) => this.removeSelect(select.facet)\n        )\n        return this;\n    }\n\n    /**\n     * Return a copy of this query including just the advanced fields and optionally `text`\n     *\n     * @param withText If `true` include the `text` field\n     */\n    copyAdvanced(withText: boolean = false): Query {\n        const query = this.copy();\n        return query.toAdvanced(withText);\n    }\n\n    /**\n     * Tests whether this query has advanced search selections\n     */\n    hasAdvanced(): boolean {\n        return !!this.select?.find(s => s.facet && s.facet.startsWith(advancedFacetPrefix));\n    }\n\n    /**\n     * Initialize this query from the passed JSON string\n     *\n     * @param jquery JSON in string form\n     */\n    fromJson(jquery: string): Query {\n        this.clear();\n        const query = Utils.fromJson(jquery);\n        // convert select and open\n        const select = query.select;\n        if (Utils.isArray(select)) {\n            query.select = select.map<Select>((value: Select | string[]) => {\n                if (Utils.isArray(value)) {\n                    return {\n                        expression: value[0],\n                        facet: value[1]\n                    };\n                }\n                else {\n                    return value;\n                }\n            });\n        }\n        const open = query.open;\n        if (Utils.isArray(open)) {\n            query.open = open.map<Open>((value: Open | string[]) => {\n                if (Utils.isArray(value)) {\n                    return {\n                        expression: value[0],\n                        aggregation: value[1]\n                    };\n                }\n                else {\n                    return value;\n                }\n            });\n        }\n        Utils.extend(this, query);\n        return this;\n    }\n\n    /**\n     * Returns a JSON representation of this query where `Select` and `Open` objects are expressed as tuple arrays for conciseness\n     */\n    toJsonForQueryString(): string {\n        const o: any = {};\n        Utils.merge(o, this);\n        if (this.select) {\n            o.select = this.select.map<string[]>((value) => {\n                const a = [value.expression];\n                if (value.facet) {\n                    a.push(value.facet);\n                }\n                return a;\n            });\n        }\n        if (this.open) {\n            o.open = this.open.map<string[]>((value) => [value.expression, value.aggregation]);\n        }\n        return Utils.toJson(o);\n    }\n\n    /**\n     * Return a hash value of this query that excludes any pagination parameters\n     */\n    hash(): string {\n        const obj: any = {};\n        Utils.mergeAndSort(obj, this);\n        // remove pagination\n        delete obj.page;\n        delete obj.pageSize;\n        const str = Utils.toJson(obj);\n        return Utils.sha512(str);\n    }\n}\n","import {Injectable} from \"@angular/core\";\nimport {IntlService} from \"@sinequa/core/intl\";\nimport {Utils, FieldValue} from \"@sinequa/core/base\";\nimport {AppServiceHelpers} from \"./app-service-helpers\";\nimport {CCColumn} from \"@sinequa/core/web-services\";\nimport {format} from \"d3-format\";\n\n/**\n * Describes a value item object that includes a {@link FieldValue} and an optional display value\n * to override standard field value formatting\n */\nexport interface ValueItem {\n    value: FieldValue;\n    display?: string;\n    count?: number; // Following ES-11166, the number of occurrence for an entity can be included\n}\n\n/**\n * This service provides methods for locale-sensitive formatting and parsing of values that can be found in\n * Sinequa search results.\n */\n@Injectable({\n    providedIn: \"root\"\n})\nexport class FormatService {\n    constructor(\n        public intlService: IntlService) {\n    }\n\n    /**\n     * Returns `true` if the passed parameter is a `ValueItem` object\n     */\n    protected isValueItem(valueItem: ValueItem | FieldValue): valueItem is ValueItem {\n        if (Utils.isObject(valueItem) && !Utils.isDate(valueItem) && !Utils.isArray(valueItem)) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Extracts the value and display components from a parameter that can be either a `ValueItem`\n     * object or a simple `FieldValue`, in which case the display will be `undefined`.\n     */\n    protected getValueAndDisplay(valueItem: ValueItem | FieldValue): [FieldValue, string] {\n        let value: FieldValue;\n        let display: string;\n        if (this.isValueItem(valueItem)) {\n            value = valueItem.value;\n            display = valueItem.display || \"\";\n        }\n        else {\n            value = valueItem;\n            display = \"\";\n        }\n        return [value, display];\n    }\n\n    /**\n     * Return the display equivalent of a Sinequa language specifier (`en`, `fr`, ...).\n     * The display values are defined in the {@link IntlModule} message files\n     *\n     * @param value A value containing a Sinequa language specifier\n     */\n    formatLanguage(value: FieldValue): string {\n        return this.intlService.formatMessage(`msg#language.${Utils.toLowerCase(value + \"\")}`);\n    }\n\n    /**\n     * Return the display equivalent of a size value. The units (`kb`, `mb`, ...) are defined\n     * in the {@link IntlModule} message files\n     *\n     * @param size A memory size in bytes\n     */\n    formatMemorySize(size: number): string {\n        const kiloBytes: number = size / 1024;\n        const megaBytes: number = kiloBytes / 1024;\n        const gigaBytes: number = megaBytes / 1024;\n        const teraBytes: number = gigaBytes / 1024;\n        const petaBytes: number = teraBytes / 1024;\n\n        let messageKey = \"msg#system.memorySize.bytes\";\n        const params: any = { value: size };\n        if (Math.abs(petaBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.pb\";\n            params.value = petaBytes;\n        }\n        else if (Math.abs(teraBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.tb\";\n            params.value = teraBytes;\n        }\n        else if (Math.abs(gigaBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.gb\";\n            params.value = gigaBytes;\n        }\n        else if (Math.abs(megaBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.mb\";\n            params.value = megaBytes;\n        }\n        else if (Math.abs(kiloBytes) >= 1) {\n            messageKey = \"msg#system.memorySize.kb\";\n            params.value = kiloBytes;\n        }\n        return this.intlService.formatMessage(messageKey, params);\n    }\n\n    /** D3 formatter for large number: 42096 => 42K */\n    bigNumberFormatter = format(\"~s\");\n\n    /** Similar to bigNumberFormatter, but replaces \"G\" by \"B\" (as in \"$42B\") */\n    moneyFormatter = s => this.bigNumberFormatter(s).replace(/G/, \"B\");\n    \n    /**\n     * Format an amount of money (typically extracted by a Sinequa Text-mining agent)\n     * USD 42069 => USD 42K\n     * @param value \n     * @returns \n     */\n    formatMoney(value: string): string {\n        let [currency, val] = value.split(\" \");\n        return `${currency} ${this.moneyFormatter(+val)}`;\n    }\n\n    /**\n     * Format a value for display according to the passed `column`. Formatters\n     * can be defined in the column's configuration to provide domain-specific\n     * formatting. The standard formatters are `language` and `memorysize`.\n     *\n     * @param valueItem The value to format\n     * @param column The column associated with the value\n     */\n    formatValue(valueItem: ValueItem | FieldValue, column?: CCColumn): string {\n        let [value, display] = this.getValueAndDisplay(valueItem);\n        if (column && column.formatter) {\n            switch (Utils.toLowerCase(column.formatter)) {\n                case \"language\": return this.formatLanguage(value);\n                case \"memorysize\":\n                    if (Utils.isNumber(value)) {\n                        return this.formatMemorySize(value);\n                    }\n                    break;\n                case \"money\":\n                    if(Utils.isString(value)) {\n                        return this.formatMoney(value);\n                    }\n                    else if(Utils.isArray(value)) {\n                        return value.map(v => \n                            this.formatMoney(Utils.isString(v)? v : v.value)\n                        ).join(', ');\n                    }\n                    break;\n            }\n        }\n        if (display) {\n            if (Utils.isDate(display)) { // ES-7785\n                display = Utils.toSysDateStr(display);\n            }\n            return this.intlService.formatMessage(display, {value});\n        }\n        if (Utils.isNumber(value)) {\n            const message = this.intlService.getMessage(\"msg#system.number\");\n            if (message) {\n                return this.intlService.formatText(message, {value});\n            }\n            else {\n                return this.intlService.formatNumber(value);\n            }\n        }\n        if (column && AppServiceHelpers.isDate(column) && Utils.isString(value)) {\n            value = Utils.fromSysDateStr(value) || value;\n        }\n        if (Utils.isDate(value)) {\n            if (column && !AppServiceHelpers.isDate(column)) { // ES-7785\n                value = Utils.toSysDateStr(value);\n            }\n            else {\n                const message = this.intlService.getMessage(\"msg#system.date\");\n                if (message) {\n                    return this.intlService.formatText(message, {date: value, time: Utils.getTime(value)});\n                }\n                else {\n                    let s = this.intlService.formatDate(value);\n                    if (Utils.getTime(value) !== 0) {\n                        s += \", \" + this.intlService.formatTime(value);\n                    }\n                    return s;\n                }\n            }\n        }\n        if (Utils.isBoolean(value)) {\n            const message = this.intlService.getMessage(\"msg#system.boolean\");\n            if (message) {\n                return this.intlService.formatText(message, {value});\n            }\n            else {\n                return value.toString();\n            }\n        }\n        if (Utils.isArray(value)) {\n            const joinValue: string[] = [];\n            value.forEach(v => {\n                if (joinValue.length > 0) {\n                    joinValue.push(\";\");\n                }\n                let _v: string;\n                if (!v) {\n                    _v = \"<null>\";\n                }\n                else if (Utils.isDate(v)) {\n                    _v = Utils.toSysDateStr(v);\n                }\n                else if (Utils.isString(v)) {\n                    _v = v;\n                }\n                else {\n                    _v = v.display || v.value || \"<null>\";\n                }\n                joinValue.push(_v);\n            });\n            value = joinValue.join(\"\");\n        }\n        if (!value) {\n            return value;\n        }\n        return this.intlService.formatMessage(value);\n    }\n\n    /**\n     * Transform a display value. Multiple transformers can be defined on a column and their calls are chained.\n     * The standard formatters are `uppercase`, `upperfirst`, `lowercase`, `lowerfirst`, `startcase`, `kebabcase`,\n     * `snakecase` and `camelcase`.\n     *\n     * @param value The value to transform\n     * @param column The column associated with the value\n     */\n    transformValue(value: string, column?: CCColumn): string {\n        const transforms = column ? Utils.split(column.transforms || \"\", \",\") : undefined;\n        if (!transforms || transforms.length === 0) {\n            return value;\n        }\n        // transforms are composable\n        for (const transform of transforms) {\n            switch (Utils.toLowerCase(transform)) {\n                case \"uppercase\": value = Utils.toUpperCase(value); break;\n                case \"upperfirst\": value = Utils.toUpperFirst(value); break;\n                case \"lowercase\": value = Utils.toLowerCase(value); break;\n                case \"lowerfirst\": value = Utils.toLowerFirst(value); break;\n                case \"startcase\": value = Utils.toStartCase(value); break;\n                case \"kebabcase\": value = Utils.toKebabCase(value); break;\n                case \"snakecase\": value = Utils.toSnakeCase(value); break;\n                case \"camelcase\": value = Utils.toCamelCase(value); break;\n            }\n        }\n        return value;\n    }\n\n    /**\n     * Format a value item for display. This is the standard entry point for formatting a value.\n     * By default, this method calls [formatValue]{@link #formatValue} and [transformValue]{@link #transformValue}.\n     *\n     * @param valueItem The value item to format\n     * @param column The column associated with the value item\n     */\n    formatFieldValue(valueItem: ValueItem | FieldValue, column?: CCColumn): string {\n        let formattedValue = this.formatValue(valueItem, column);\n        formattedValue = this.transformValue(formattedValue, column);\n        return formattedValue;\n    }\n\n    /**\n     * Parse an input value according to the passed `parser`. The standard parser is `memorysize`. Parsers\n     * are configured in the {@link CCColumn} configuration. The parsed value is returned as a string for\n     * processing by the {@link ValidationModule}\n     *\n     * @param value The value to parse\n     * @param parser The parser to use\n     */\n    parseValue(value: any, parser: string): string {\n        if (Utils.isString(value)) {\n            if (parser) {\n                switch (Utils.toLowerCase(parser)) {\n                    case \"memorysize\": {\n                        return this.parseMemorySize(value) + \"\";\n                    }\n                }\n            }\n        }\n        return value;\n    }\n\n    /**\n     * Parse a size string using [Utils.toSize]{@link Utils#toSize}\n     *\n     * @param str The string to parse\n     * @param _default The default value to return if the string cannot be parsed\n     * @return The parsed size in bytes\n     */\n    parseMemorySize(str: string, _default = 0): number {\n        return Utils.toSize(str, _default);\n    }\n\n    /**\n     * Display a raw value without applying any formatting\n     * (besides the native toString() method for non-string values)\n     * @param value \n     * @returns \n     */\n    formatRaw(value: ValueItem | FieldValue): string {\n        let [val] = this.getValueAndDisplay(value);\n        if(Utils.isArray(val)) {\n            return val.map(v => Utils.isString(v)? v : v.value).join(';');\n        }\n        return val?.toString();\n    }\n}\n","import {Injectable, Inject, OnDestroy} from \"@angular/core\";\nimport {Observable, Subject} from \"rxjs\";\nimport {map} from \"rxjs/operators\";\nimport {Utils, MapOf, PatternMatcher} from \"@sinequa/core/base\";\nimport {IntlService} from \"@sinequa/core/intl\";\nimport {FormatService} from \"./format.service\";\nimport {AppWebService, AuditEvents, START_CONFIG, StartConfig,\n    CCApp, CCQuery, CCLabels, CCAutocomplete, CCColumn, CCIndex, CCWebService, CCConfig, CCList, CCAggregation,\n    EngineType, EngineTypeModifier, MINIMUM_COMPATIBLE_SERVER_API_VERSION} from \"@sinequa/core/web-services\";\nimport {ExprParser, ExprParserOptions, Expr} from \"./query/expr-parser\";\nimport {AppServiceHelpers} from \"./app-service-helpers\";\n\n/**\n * A base event from which all events that can be issued by the {@link AppService} are derived\n */\nexport interface AppEvent {\n    type: \"query-changed\";\n}\n\n/**\n * This event is fired each time the [ccquery]{@link AppService#ccquery} member is modified.\n */\nexport interface QueryChangedEvent extends AppEvent {\n    type: \"query-changed\";\n    current?: CCQuery;\n    previous?: CCQuery;\n}\n\n/**\n * A union of the different events that the {@link AppService} can generate\n */\nexport type AppEvents = QueryChangedEvent;\n\n/**\n * A service to manage the Sinequa SBA configuration\n */\n@Injectable({\n    providedIn: \"root\"\n})\nexport class AppService implements OnDestroy {\n    // Should match AdditionalQueryableColumns in Engine.cs\n    private static extraColumns: MapOf<CCColumn> = {\n        id: AppService.makeColumn(\"id\", \"string\"),\n        text: AppService.makeColumn(\"text\", \"varchar\"),\n        documentlanguages: AppService.makeColumn(\"documentlanguages\", \"csv\", \"ci\"),\n        databasealias: AppService.makeColumn(\"databasealias\", \"varchar\"),\n        globalrelevance: AppService.makeColumn(\"globalrelevance\", \"double\"),\n        matchingpartnames: AppService.makeColumn(\"matchingpartnames\", \"csv\"),\n        matchlocations: AppService.makeColumn(\"matchlocations\", \"csv\"),\n        matchlocationsperpartname: AppService.makeColumn(\"matchlocationsperpartname\", \"varchar\"), // json\n        extracts: AppService.makeColumn(\"extracts\", \"csv\"),\n        extractsperpartname: AppService.makeColumn(\"extractsperpartname\", \"varchar\"), // json\n        extractslocations: AppService.makeColumn(\"extractslocations\", \"csv\"),\n        documentweight: AppService.makeColumn(\"documentweight\", \"varchar\"),\n        groupcount: AppService.makeColumn(\"groupcount\", \"integer\"),\n        accesslists: AppService.makeColumn(\"accesslists\", \"varchar\", undefined, [\"accessLists\"]) // json\n    };\n\n    /**\n     * The app configuration\n     */\n    app?: CCApp;\n    /**\n     * The labels configuration\n     */\n    cclabels?: CCLabels;\n    /**\n     * The autocomplete configuration\n     */\n    ccautocomplete?: CCAutocomplete;\n    /**\n     * The suggest queries configured on the application\n     */\n    suggestQueries: string[];\n    private columnsByQuery: MapOf<MapOf<CCColumn>>;\n    private columnsByIndex: MapOf<MapOf<CCColumn>>;\n    private fieldsByQuery: MapOf<string[]>;\n    private _defaultCCQuery?: CCQuery;\n    private _ccquery?: CCQuery;\n\n    protected _events = new Subject<AppEvents>();\n\n    private static toEngineType(type: string): EngineType {\n        if (!type) {\n            return EngineType.none;\n        }\n        switch (Utils.toLowerCase(type)) {\n            case \"bool\"     :\n            case \"boolean\"  : return EngineType.bool;\n            case \"date\"     : return EngineType.date;\n            case \"datetime\" : return EngineType.dateTime;\n            case \"time\"     : return EngineType.time;\n            case \"unsigned\" : return EngineType.unsigned;\n            case \"integer\"  : return EngineType.integer;\n            case \"float\"    : return EngineType.float;\n            case \"double\"   : return EngineType.double;\n            case \"dates\"    : return EngineType.dates;\n            case \"datetimes\": return EngineType.dateTimes;\n            case \"times\"    : return EngineType.times;\n            case \"varchar\"  : return EngineType.varchar;\n            case \"binary\"   : return EngineType.binary;\n            case \"string\"   : return EngineType.string;\n            case \"csv\"      : return EngineType.csv;\n            default         : return EngineType.none;\n        }\n    }\n\n    private static toEngineTypeModifierSimple(c: string): EngineTypeModifier {\n        switch (c) {\n            case 'a': return EngineTypeModifier.a;\n            case 'c': return EngineTypeModifier.c;\n            case 'd': return EngineTypeModifier.d;\n            case 'e': return EngineTypeModifier.e;\n            case 'i': return EngineTypeModifier.i;\n            case 'l': return EngineTypeModifier.l;\n            case 'n': return EngineTypeModifier.n;\n            case 't': return EngineTypeModifier.t;\n            case 'x': return EngineTypeModifier.x;\n            case 'z': return EngineTypeModifier.z;\n            default : return EngineTypeModifier.none;\n        }\n    }\n\n    private static toEngineTypeModifier(eType: EngineType, typeModifier: string): EngineTypeModifier {\n        let etm = EngineTypeModifier.none;\n        if (typeModifier) {\n            for (const c of typeModifier) {\n                etm |= AppService.toEngineTypeModifierSimple(c);\n            }\n        }\n        return etm;\n    }\n\n    private static makeColumn(name: string, type: string, typeModifier?: string, aliases?: string[]) {\n        const eType = AppService.toEngineType(type);\n        const eTypeModifier = AppService.toEngineTypeModifier(eType, typeModifier || \"\");\n        return {\n            name,\n            type,\n            typeModifier,\n            eType,\n            eTypeModifier,\n            aliases\n        };\n    }\n\n    /**\n     * Return `true` if a `column` is a string\n     */\n    static isString(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isString(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a csv\n     */\n    static isCsv(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isCsv(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a tree\n     */\n    static isTree(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isTree(column);\n    }\n\n    /**\n     * Return `true` if a `column` is an entity\n     */\n    static isEntity(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isEntity(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a boolean\n     */\n    static isBoolean(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isBoolean(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a date\n     */\n    static isDate(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isDate(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a double\n     */\n    static isDouble(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isDouble(column);\n    }\n\n    /**\n     * Return `true` if a `column` is an integer\n     */\n    static isInteger(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isInteger(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a number (integer or double)\n     */\n    static isNumber(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isNumber(column);\n    }\n\n    /**\n     * Return `true` if a `column` is a scalar\n     */\n    static isScalar(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isScalar(column);\n    }\n\n    /**\n     * Return `true` if a `column` is sortable\n     */\n    static isSortable(column: CCColumn | undefined): boolean {\n        return AppServiceHelpers.isSortable(column);\n    }\n\n    constructor(\n        @Inject(START_CONFIG) public startConfig: StartConfig,\n        public appWebService: AppWebService,\n        public intlService: IntlService,\n        public formatService: FormatService) {\n\n        if (!this.appName) {\n            console.error(\"Missing app name!\");\n        }\n    }\n\n    ngOnDestroy() {\n        this._events.complete();\n    }\n\n    /**\n     * Return an `Observable` stream of the events that the `AppService` can generate\n     */\n    get events(): Observable<AppEvents> {\n        return this._events;\n    }\n\n    /**\n     * Return the name of the SBA\n     */\n    get appName(): string {\n        return this.startConfig.app!;\n    }\n\n    /**\n     * Return the origin of the Sinequa server\n     */\n    get origin(): string {\n        return this.startConfig.origin!;\n    }\n\n    private initDefaultQuery() {\n        if (!this.app) {\n            console.warn(\"No app configured\");\n            return;\n        }\n        // If not set explicitly, the default query is the first in the list\n        const defaultQueryName = this.app.defaultQueryName || Utils.split(this.app.queryNames, \",\")[0];\n        this._defaultCCQuery = Utils.getField<CCQuery>(this.app.queries, defaultQueryName);\n        if (!this._defaultCCQuery) {\n            console.warn(`Query not configured for app: ${this.appName}`);\n        }\n        this.ccquery = this._defaultCCQuery;\n    }\n\n    private setApp(app: CCApp) {\n        this.app = app;\n        this.verifyServerApiVersionCompatibility(app);\n        this.cclabels = this.getWebService<CCLabels>(this.app.labels);\n        this.ccautocomplete = this.getWebService<CCAutocomplete>(this.app.autocomplete);\n        this.initDefaultQuery();\n        this.makeMaps();\n        this.suggestQueries = Utils.split(this.ccautocomplete ? this.ccautocomplete.suggestQueries : \"\", \",\");\n    }\n\n    private verifyServerApiVersionCompatibility(app: CCApp): void {\n        if (!app) {\n            console.warn('Unexpected empty app configuration.');\n            return;\n        }\n        if (!app.apiVersion) {\n            console.error(`The App config '${app.name}' is not of 'Angular Workspace application' type.`);\n        } else if (app.apiVersion !== MINIMUM_COMPATIBLE_SERVER_API_VERSION) {\n            console.warn(`This SBA is not compatible with the REST API of Sinequa Server.\\n` +\n                `The SBA expects the server API version to be at least '${MINIMUM_COMPATIBLE_SERVER_API_VERSION}',` +\n                ` whereas the server API version is '${app.apiVersion}'.`);\n        }\n    }\n\n    /**\n     * Initialize this service by retrieving the current application\n     * configuration from the Sinequa server and using it to set up the data structures\n     * on which the service relies\n     */\n    init(): Observable<CCApp> {\n        return this.appWebService.get().pipe(\n            map(app => {\n                this.setApp(app);\n                return app;\n            }\n        ));\n    }\n\n    /**\n     * Initialize this service from an application configuration object. This is typically\n     * used for supporting mutiple concurrent queries within the same application by providing\n     * component level instances of this service.\n     */\n    initFromApp(app: CCApp) {\n        if (app) {\n            this.setApp(app);\n        }\n    }\n\n    /**\n     * Refresh the application configuration, reinitializing the service if it has changed\n     *\n     * @param auditEvents Any associated audit events that should be stored\n     */\n    refresh(auditEvents?: AuditEvents): Observable<CCApp | undefined> {\n        const observable = this.appWebService.refresh(this.app ? this.app.versionId : \"\", auditEvents);\n        observable.subscribe(\n            response => {\n                if (!response.upToDate && response.app) {\n                    this.setApp(response.app);\n                }\n                return response;\n            }\n        );\n        return observable.pipe(map((value) => {\n            return this.app;\n        }));\n    }\n\n    /**\n     * Clear the data associated with the service. Typically used when processing a user logout\n     */\n    clear() {\n        this.app = undefined;\n        this.cclabels = undefined;\n        this._defaultCCQuery = undefined;\n        this.ccquery = undefined;\n        this.clearMaps();\n    }\n\n    private indexIsNormal(ccindex: CCIndex): boolean {\n        return !!ccindex && (!ccindex.indexType || Utils.startsWith(ccindex.indexType, \"normal\"));\n    }\n\n    private getIndexForQuery(ccquery: CCQuery): CCIndex | undefined {\n        if (!ccquery) {\n            return undefined;\n        }\n        const indexes = Utils.split(ccquery.searchIndexes, [\",\"]);\n        if (indexes.length === 0) {\n            return this.app ? this.app.indexes._ : undefined;\n        }\n        else {\n            const ccindex = this.getIndex(indexes[0]);\n            if (ccindex && this.indexIsNormal(ccindex)) {\n                return this.app ? this.app.indexes._ : undefined;\n            }\n            return ccindex;\n        }\n    }\n\n    private _makeColumnMapForIndex(columnMap: MapOf<CCColumn>, ccindex: CCIndex) {\n        if (!ccindex || !ccindex.columns) {\n            return;\n        }\n        for (const columnName of Object.keys(ccindex.columns)) {\n            const column = ccindex.columns[columnName];\n            columnMap[Utils.toLowerCase(column.name)] = column;\n            if (column.aliases) {\n                for (const alias of column.aliases) {\n                    columnMap[Utils.toLowerCase(alias)] = column;\n                }\n            }\n        }\n    }\n\n    private _makeColumnMapForQuery(columnMap: MapOf<CCColumn>, ccquery: CCQuery) {\n        if (!ccquery || !ccquery.columnsInfo || !ccquery.columnsInfo.columns) {\n            return;\n        }\n        const ccindex = this.getIndexForQuery(ccquery);\n        if (!ccindex || !ccindex.columns) {\n            return;\n        }\n        for (const columnInfo of ccquery.columnsInfo.columns) {\n            if (columnInfo.name) {\n                const columnName = Utils.toLowerCase(columnInfo.name);\n                let column = ccindex.columns[columnName];\n                if (!column) {\n                    column = AppService.extraColumns[columnName];\n                }\n                if (column) {\n                    // Copy column so we can add the query specific aliases and labels\n                    column = Utils.copy(column);\n                    columnMap[columnName] = column;\n                    if (columnInfo.aliases) {\n                        column.aliases = Utils.split(columnInfo.aliases, [\",\", \";\"]);\n                        for (const alias of column.aliases) {\n                            columnMap[Utils.toLowerCase(alias)] = column;\n                        }\n                    }\n                    // Overwrite labels if defined on the query\n                    if (columnInfo.label) {\n                        column.label = columnInfo.label;\n                    }\n                    if (columnInfo.labelPlural) {\n                        column.labelPlural = columnInfo.labelPlural;\n                    }\n                    if (columnInfo.formatter) {\n                        column.formatter = columnInfo.formatter;\n                    }\n                    if (columnInfo.transforms) {\n                        column.transforms = columnInfo.transforms;\n                    }\n                    if (columnInfo.parser) {\n                        column.parser = columnInfo.parser;\n                    }\n                    if (columnInfo.description) {\n                        column.description = columnInfo.description;\n                    }\n                }\n            }\n        }\n    }\n\n    protected makeMaps() {\n        this.columnsByQuery = {};\n        this.columnsByIndex = {};\n        this.fieldsByQuery = {};\n        if (!this.app) {\n            return;\n        }\n        let columnMap: MapOf<CCColumn>;\n\n        // Queries\n        if (this.app.queries) {\n            for (const queryName of Object.keys(this.app.queries)) {\n                const ccquery = this.app.queries[queryName];\n                if (ccquery) {\n                    ccquery.$columnFieldsPattern = new PatternMatcher(\"included column fields\", \"excluded column fields\");\n                    ccquery.$columnFieldsPattern.includedPattern.setText(ccquery.columnFieldsIncluded);\n                    ccquery.$columnFieldsPattern.excludedPattern.setText(ccquery.columnFieldsExcluded);\n                    ccquery.$partnameFieldsPattern = new PatternMatcher(\"included part name fields\", \"excluded part name fields\");\n                    ccquery.$partnameFieldsPattern.includedPattern.setText(ccquery.partnameFieldsIncluded);\n                    ccquery.$partnameFieldsPattern.excludedPattern.setText(ccquery.partnameFieldsExcluded);\n                    if (ccquery.columnsInfo) {\n                        columnMap = {};\n                        this.columnsByQuery[Utils.toLowerCase(ccquery.name)] = columnMap;\n                        this._makeColumnMapForQuery(columnMap, ccquery);\n                    }\n                }\n            }\n        }\n\n        // Indexes\n        if (this.app.indexes) {\n            // Special normal index\n            const ccindex = this.app.indexes._;\n            if (ccindex) {\n                columnMap = {};\n                this.columnsByIndex._ = columnMap;\n                this._makeColumnMapForIndex(columnMap, ccindex);\n\n            }\n            for (const indexName of Object.keys(this.app.indexes)) {\n                const ccindex1 = this.app.indexes[Utils.toLowerCase(indexName)];\n                if (ccindex1) {\n                    if (this.indexIsNormal(ccindex1)) {\n                        if (ccindex1.name !== \"_\") {\n                            this.columnsByIndex[Utils.toLowerCase(ccindex1.name)] = this.columnsByIndex._;\n                        }\n                    }\n                    else {\n                        columnMap = {};\n                        this.columnsByIndex[Utils.toLowerCase(ccindex1.name)] = columnMap;\n                        this._makeColumnMapForIndex(columnMap, ccindex1);\n                    }\n                }\n            }\n        }\n\n        // Fields per query (contains aliases for default query and globally defined aliases)\n        const globalFields = new Map<string, string>();\n        const columns = this.columnsByIndex._;\n        if (columns) {\n            for (const key of Object.keys(columns)) {\n                const column = columns[key];\n                if (column.aliases && column.aliases.length > 0) {\n                    const alias = column.aliases[0];\n                    if (alias) {\n                        globalFields.set(alias, alias);\n                    }\n                }\n            }\n        }\n        for (const queryName of Object.keys(this.columnsByQuery)) {\n            const queryFields = new Map<string, string>(globalFields);\n            const columns1 = this.columnsByQuery[Utils.toLowerCase(this.defaultCCQuery ? this.defaultCCQuery.name : \"\")];\n            if (columns1) {\n                for (const key of Object.keys(columns1)) {\n                    const column = columns1[key];\n                    if (column.aliases && column.aliases.length > 0) {\n                        const alias = column.aliases[0];\n                        if (alias) {\n                            queryFields.set(alias, alias);\n                        }\n                    }\n                }\n                this.fieldsByQuery[queryName] = Array.from(queryFields.keys());\n            }\n        }\n    }\n\n    protected clearMaps() {\n        this.columnsByQuery = {};\n        this.columnsByIndex = {};\n        this.fieldsByQuery = {};\n    }\n\n    /**\n     * Get the configuration of the web service with the passed name\n     */\n    getWebService<T extends CCWebService>(name: string): T | undefined {\n        if (!this.app) {\n            return undefined;\n        }\n        return Utils.getField<CCConfig>(this.app.webServices, name) as T;\n    }\n\n    /**\n     * Get the list configuration with the passed name\n     */\n    getList(name: string): CCList | undefined {\n        if (!this.app) {\n            return undefined;\n        }\n        return this.app.lists[name];\n    }\n\n    /**\n     * Return the default {@link CCQuery}\n     */\n    get defaultCCQuery(): CCQuery | undefined {\n        return this._defaultCCQuery;\n    }\n\n    /**\n     * Return the current {@link CCQuery}\n     */\n    get ccquery(): CCQuery | undefined {\n        if (!!this._ccquery) {\n            return this._ccquery;\n        }\n        return this._defaultCCQuery;\n    }\n\n    /**\n     * Set the current {@link CCQuery}\n     */\n    set ccquery(value: CCQuery | undefined) {\n        if (value !== this._ccquery) {\n            const previous = this._ccquery;\n            this._ccquery = value;\n            this._events.next({type: \"query-changed\", current: this._ccquery, previous: previous});\n        }\n    }\n\n    /**\n     * Get the {@link CCQuery} with the passed name\n     */\n    getCCQuery(name: string): CCQuery | undefined {\n        return this.app ? this.app.queries[Utils.toLowerCase(name)] : undefined;\n    }\n\n    /**\n     * Set the current {@link CCQuery} to that with the passed name\n     */\n    setCCQuery(name?: string): boolean {\n        const ccquery = !name ? this.defaultCCQuery : this.getCCQuery(name);\n        if (ccquery) {\n            this.ccquery = ccquery;\n            return true;\n        }\n        else {\n            console.warn(`AppService.setCCQuery - query '${name}' does not exist`);\n            return false;\n        }\n    }\n\n    /**\n     * Return the fields defined on the current {@link CCQuery}\n     */\n    get fields(): string[] {\n        if (!this.ccquery) {\n            return [];\n        }\n        return this.fieldsByQuery[Utils.toLowerCase(this.ccquery.name)] || [];\n    }\n\n    /**\n     * Get the {@link CCAggregation} with the passed name\n     */\n    getCCAggregation(name: string): CCAggregation | undefined {\n        if (!this.ccquery || !this.ccquery.aggregations) {\n            return undefined;\n        }\n        return this.ccquery.aggregations.find((value) => Utils.eqNC(name, value.name));\n    }\n\n    /**\n     * Get the {@link CCIndex} with the passed name\n     */\n    getIndex(name: string): CCIndex | undefined {\n        if (!this.app) {\n            return undefined;\n        }\n        return Utils.getField<CCIndex>(this.app.indexes, name);\n    }\n\n    /**\n     * Get the {@link CCColumn} with the passed name. Aliases are resolved\n     */\n    getColumn(name: string | null | undefined): CCColumn | undefined {\n        if (!name) {\n            return undefined;\n        }\n        if (!this.ccquery) {\n            return undefined;\n        }\n        // First, CCQuery specific aliases\n        let column: CCColumn;\n        let columnAliases = this.columnsByQuery[Utils.toLowerCase(this.ccquery.name)];\n        if (columnAliases) {\n            column = columnAliases[Utils.toLowerCase(name)];\n            if (column) {\n                return column;\n            }\n        }\n        // Second, aliases by index\n        const indexes = Utils.split(this.ccquery.searchIndexes, [\",\"]);\n        const firstIndex = indexes.length === 0 ? undefined : this.getIndex(indexes[0]);\n        if (indexes.length === 0 || (!!firstIndex && this.indexIsNormal(firstIndex))) {\n            columnAliases = this.columnsByIndex._;\n            if (columnAliases) {\n                column = columnAliases[Utils.toLowerCase(name)];\n                if (column) {\n                    return column;\n                }\n            }\n        }\n        else {\n            for (const index of indexes) {\n                columnAliases = this.columnsByIndex[Utils.toLowerCase(index)];\n                if (columnAliases) {\n                    column = columnAliases[Utils.toLowerCase(name)];\n                    if (column) {\n                        return column;\n                    }\n                }\n            }\n        }\n        // Third, extra columns\n        column = AppService.extraColumns[Utils.toLowerCase(name)];\n        if (column) {\n            return column;\n        }\n        return undefined;\n    }\n\n    /**\n     * Get the default alias a column\n     *\n     * @param column The column\n     * @return The default alias or `null` if no alias is defined\n     */\n    getColumnDefaultAlias(column?: CCColumn): string {\n        if (column) {\n            if (column.aliases && column.aliases.length > 0) {\n                return column.aliases[0];\n            }\n        }\n        return \"\";\n    }\n\n    /**\n     * Get the name of a column\n     *\n     * @param column The column\n     * @param _default A default name to return if `column` is empty\n     */\n    private getColumnName(column?: CCColumn, _default = \"\"): string {\n        if (column) {\n            return column.name;\n        }\n        return _default;\n    }\n\n    /**\n     * Get the default alias for a column\n     *\n     * @param column The column\n     * @param _default A default alias name to return if the `column` is empty or no alias is defined\n     */\n    getColumnAlias(column?: CCColumn, _default = \"\"): string {\n        if (column) {\n            const alias = this.getColumnDefaultAlias(column);\n            if (alias) {\n                return alias;\n            }\n        }\n        return _default;\n    }\n\n    /**\n     * Return a column name from a name which can be an alias\n     */\n    resolveColumnName(name: string | null | undefined): string {\n        const column = this.getColumn(name);\n        return this.getColumnName(column, name || \"\");\n    }\n\n    /**\n     * Return a column alias from a name which can be an alias\n     */\n    resolveColumnAlias(name: string | null | undefined): string {\n        const column = this.getColumn(name);\n        return this.getColumnAlias(column, name || \"\");\n    }\n\n    /**\n     * Parse a fielded search expression\n     *\n     * @param text The expression\n     * @param options Options for the parsing\n     * @return The parsed {@link Expr} or an error message\n     */\n    parseExpr(text: string, options?: ExprParserOptions): Expr | string {\n        return ExprParser.parse(text, {appService: this, formatService: this.formatService, intlService: this.intlService}, options);\n    }\n\n    /**\n     * Escape a value for fielded search if necessary. `Date` objects are converted to\n     * Sinequa system date strings and non-scalars fields are escaped\n     * @param field The value's field\n     * @param value The value\n     */\n    escapeFieldValue(field: string, value: string | number | Date | boolean | undefined): string {\n        if (Utils.isDate(value)) {\n            return Utils.toSysDateStr(value);\n        }\n        value = value + \"\";\n        const column = this.getColumn(field);\n        if (column && !AppService.isScalar(column)) {\n            // escaoe columns that might contain search operators in them (treating negative numbers as an ignorable edge case)\n            return ExprParser.escape(value);\n        }\n        return value;\n    }\n\n    /**\n     * Get the label of a column. The plural label is returned for csv-type columns.\n     *\n     * @param name The name of the column which can be an alias\n     * @param _default The default label to return if no label is defined\n     */\n    getLabel(name: string, _default?: string): string {\n        const column = this.getColumn(name);\n        if (column) {\n            const label = AppService.isCsv(column) ? column.labelPlural : column.label;\n            if (label) {\n                return label;\n            }\n        }\n        if (!Utils.isUndefined(_default)) {\n            return _default;\n        }\n        return name;\n    }\n\n    /**\n     * Get the singular label of a column\n     *\n     * @param name The name of the column which can be an alias\n     * @param _default The default label to return if no label is defined\n     */\n    getSingularLabel(name: string, _default?: string): string {\n        const column = this.getColumn(name);\n        if (column && column.label) {\n            return column.label;\n        }\n        if (!Utils.isUndefined(_default)) {\n            return _default;\n        }\n        return name;\n    }\n\n    /**\n     * Get the plural label of a column\n     *\n     * @param name The name of the column which can be an alias\n     * @param _default The default label to return if no label is defined\n     */\n    getPluralLabel(name: string, _default?: string): string {\n        const column = this.getColumn(name);\n        if (column && column.labelPlural) {\n            return column.labelPlural;\n        }\n        if (!Utils.isUndefined(_default)) {\n            return _default;\n        }\n        return name;\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a string\n     */\n    isString(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isString(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a csv\n     */\n    isCsv(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isCsv(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a tree\n     */\n    isTree(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isTree(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is an entity\n     */\n    isEntity(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isEntity(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a boolean\n     */\n    isBoolean(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isBoolean(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a date\n     */\n    isDate(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isDate(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a double\n     */\n    isDouble(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isDouble(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is an integer\n     */\n    isInteger(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isInteger(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a number (integer or double)\n     */\n    isNumber(name: string): boolean {\n        return this.isInteger(name) || this.isDouble(name);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is a scalar\n     */\n    isScalar(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isScalar(column);\n    }\n\n    /**\n     * Return `true` if a column with the passed name or alias is sortable\n     */\n    isSortable(name: string): boolean {\n        const column = this.getColumn(name);\n        return !!column && AppService.isSortable(column);\n    }\n\n    /**\n     * If the passed url is relative and CORS is active then\n     * prepend it with the Sinequa server origin\n     */\n    updateUrlForCors(url: string): string {\n        if (this.startConfig.corsActive && !!url && !Utils.isUrlAbsolute(url)) {\n            url = Utils.addUrl(this.origin, url);\n        }\n        return url;\n    }\n\n    /**\n     * Return the url to the Sinequa administration console\n     */\n    get adminUrl(): string {\n        return this.updateUrlForCors(Utils.addUrl(this.startConfig.applicationPath!, \"admin\"));\n    }\n}","import {Injectable, Inject} from \"@angular/core\";\nimport {HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpParams} from \"@angular/common/http\";\nimport {Observable} from \"rxjs\";\nimport {START_CONFIG, StartConfig, AuditRecord, AuditEvent, AuditEvents} from \"@sinequa/core/web-services\";\nimport {Utils} from \"@sinequa/core/base\";\n\n/**\n * An `HttpInterceptor` to process audi events attached to the request body\n * in the `$auditRecord` member.\n */\n@Injectable({\n    providedIn: \"root\"\n})\nexport class AuditInterceptor implements HttpInterceptor {\n    \n    // Store the session id and its datetime of creation/refresh\n    sessionid: string;\n    sessionstart: Date;\n\n    constructor(\n        @Inject(START_CONFIG) private startConfig: StartConfig\n    ) {\n    }\n\n    private shouldIntercept(url: string): boolean {\n        return Utils.startsWith(url, this.startConfig.apiPath!);\n    }\n\n    private isJsonable(obj): boolean {\n        return (Utils.isObject(obj) || Utils.isArray(obj)) && !Utils.isArrayBuffer(obj) && !Utils.isBlob(obj) &&\n            !Utils.isString(obj) && !(obj instanceof HttpParams);\n    }\n\n    // Handle legacy calls where auditEvents is either an AuditEvent or AuditEvent[]\n    private ensureAuditRecord(auditEvents: AuditEvents): AuditRecord | undefined{\n        if (!auditEvents) {\n            return undefined;\n        }\n        let auditEvents1: AuditEvent[] | undefined;\n        if (Utils.isArray(auditEvents)) {\n            auditEvents1 = auditEvents;\n        }\n        else if (Utils.isObject(auditEvents)) {\n            const auditRecord = auditEvents as AuditRecord;\n            if (auditRecord.auditEvents || auditRecord.mlAuditEvents) {\n                return auditRecord;\n            }\n            auditEvents1 = [auditEvents as AuditEvent];\n        }\n        return {\n            auditEvents: auditEvents1\n        };\n    }\n\n    /**\n     * Add a sessionid to all the audit events\n     * @param auditRecord \n     */\n    private addSessionId(auditRecord?: AuditRecord) {\n        const sessionid = this.getSessionId();\n        auditRecord?.auditEvents?.forEach(event => {\n            if(!event.detail) {\n                event.detail = {};\n            }\n            event.detail['session-id'] = sessionid;\n        });\n    }\n\n    /**\n     * Get a Session Id initialized upon login. The session is maintained for 10 minutes\n     * after the last call to this method.\n     */\n    private getSessionId(): string {\n        if(!this.sessionid || this.isSessionStale()) {\n            this.sessionid = Utils.guid();\n        }\n        this.sessionstart = new Date();\n        return this.sessionid;\n    }\n\n    /**\n     * Test whether the current session id valid or stale (need to be refreshed)\n     */\n    private isSessionStale(): boolean {\n        const lastSession = new Date().getTime() - this.sessionstart.getTime();\n        // Consider the session stale after 10 minutes\n        return lastSession > 10 * 60 * 1000;\n    }\n\n    /**\n     * Called once the `$auditRecord` member has been standardized, this method\n     * can be overidden to update fields in the audit events associated with a\n     * web service call.\n     */\n    protected updateAuditRecord(auditRecord?: AuditRecord) {\n    }\n\n    /**\n     * Intercept requests with a JSON body and standardize the format of the\n     * `$auditRecord` member.\n     */\n    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n        if (this.shouldIntercept(request.url) && this.isJsonable(request.body)) {\n            request.body.$auditRecord = this.ensureAuditRecord(request.body.$auditRecord);\n            this.addSessionId(request.body.$auditRecord);\n            this.updateAuditRecord(request.body.$auditRecord);\n        }\n        return next.handle(request);\n    }\n}\n","const APP_UTILS_MODULE_PROVIDERS = [];\n\nexport {APP_UTILS_MODULE_PROVIDERS};\n","import {NgModule} from \"@angular/core\";\nimport {BaseModule} from \"@sinequa/core/base\";\nimport {IntlModule} from \"@sinequa/core/intl\";\nimport {WebServicesModule} from \"@sinequa/core/web-services\";\n\nimport {APP_UTILS_MODULE_PROVIDERS} from \"./module.providers\";\n\n/**\n * This module contains a utility {@link AppService} for managing the configuration of a Sinequa SBA and a {@link FormatService}\n * for handling the formatting and parsing of Sinequa field values. It also contains an implementation of a {@link Query} class\n * as well as classes for manipulating Sinequa fielded search expressions.\n *\n * The {@link AuditInterceptor} in this module should be registered using `HTTP_INTERCEPTORS` in your app module.\n */\n@NgModule({\n    imports: [\n        BaseModule,\n        IntlModule,\n        WebServicesModule\n    ],\n    declarations: [\n    ],\n    exports: [\n    ],\n    providers: [\n        ...APP_UTILS_MODULE_PROVIDERS\n    ]\n})\nexport class AppUtilsModule {\n}\n"]}