{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/core/load-component/load-component.service.ts","../../../projects/core/load-component/load-component.directive.ts","../../../projects/core/load-component/module.providers.ts","../../../projects/core/load-component/load-component.module.ts"],"names":["Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","LoadComponentService","componentFactoryResolver","applicationRef","this","factories","Map","prototype","_bindComponent","options","loadedComponent","initialLoad","unbindComponent","simpleChanges","ngOnChanges","componentRef","instance","makeSimpleChanges","Utils","isFunction","inputs","keys","forEach","name","previousValue","undefined","currentValue","SimpleChange","outputs","eventEmitter","subscription","subscribe","subscriptions","add","bindComponent","unsubscribe","loadComponent","viewContainerRef","injector","factory","get","component","resolveComponentFactory","index","isEmpty","createComponent","appElement","components","location","nativeElement","injector1","attachView","hostView","parentElement","insertBefore","nextSibling","changeDetectorRef","detectChanges","unloadComponent","destroy","i0","ɵɵinject","ComponentFactoryResolver","ApplicationRef","ɵfac","providedIn","LoadComponentDirective","loadComponentService","EventEmitter","currentComponent","emit","ngOnDestroy","ɵɵdirectiveInject","ViewContainerRef","selectors","features","ɵɵNgOnChangesFeature","LOAD_COMPONENT_MODULE_PROVIDERS","LoadComponentModule","providers","imports","CommonModule","BaseModule","declarations","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {Injectable, ViewContainerRef, ComponentRef, Type, ComponentFactory, ComponentFactoryResolver, ApplicationRef,\n    Injector, SimpleChanges, SimpleChange, EventEmitter} from \"@angular/core\";\nimport {Subscription} from \"rxjs\";\nimport {Utils, MapOf} from \"@sinequa/core/base\";\n\n/**\n * Describes the options that can be passed to [LoadComponentService.loadComponent]{@link LoadComponentService#loadComponent}\n */\nexport interface LoadComponentOptions {\n    /**\n     * The type of the component to load\n     */\n    component: Type<any>;\n    /**\n     * The initial values for the component's `@Input` decorated properties\n     */\n    inputs?: MapOf<any>;\n    /**\n     * The handlers for the component's `@Output` decorated events\n     */\n    outputs?: MapOf<any>;\n    /**\n     * The index at which to insert the loaded component's host view into the container.\n     * If not specified, appends the new view as the last entry.\n     * See [ViewContainerRef.createComponent]{@link https://angular.io/api/core/ViewContainerRef#createComponent}\n     */\n    index?: number;\n}\n\n/**\n * Describes the object returned by [LoadComponentService.loadComponent]{@link LoadComponentService#loadComponent}\n */\nexport interface LoadedComponent {\n    /**\n     * The loaded component instance\n     */\n    componentRef: ComponentRef<any>;\n    /**\n     * The subscriptions made to the component's output events\n     */\n    subscriptions?: Subscription;\n}\n\n/**\n * This service provides methods to dynamically load and unload an angular component from its type.\n * The component's initial inputs and outputs are respected and the first call to the component's\n * `ngOnChanges` method is made.\n * Changes to the inputs and outputs can be made by calling {@link #bindComponent} which will call\n * the component's `ngOnChanges` method again\n */\n@Injectable({\n    providedIn: \"root\"\n})\nexport class LoadComponentService {\n\n    // A cache of resolved component factories\n    private factories = new Map<Type<any>, ComponentFactory<any>>();\n\n    constructor(\n        private componentFactoryResolver: ComponentFactoryResolver,\n        private applicationRef: ApplicationRef) {\n    }\n\n    private _bindComponent(options: LoadComponentOptions, loadedComponent: LoadedComponent, initialLoad: boolean) {\n        if (!initialLoad) {\n            this.unbindComponent(loadedComponent);\n        }\n        const ngOnChanges: (changes: SimpleChanges) => void = loadedComponent.componentRef.instance.ngOnChanges;\n        let simpleChanges: SimpleChanges | undefined;\n        const makeSimpleChanges = Utils.isFunction(ngOnChanges) && !!options.inputs;\n        if (!!options.inputs) {\n            // Assign inputs and generate SimpleChanges if required\n            Object.keys(options.inputs).forEach(name => {\n                if (makeSimpleChanges) {\n                    const previousValue = initialLoad ? undefined : loadedComponent.componentRef.instance[name];\n                    const currentValue = options.inputs![name];\n                    if (initialLoad || currentValue !== previousValue) {\n                        if (!simpleChanges) {\n                            simpleChanges = {};\n                        }\n                        simpleChanges[name] = new SimpleChange(previousValue, currentValue, initialLoad);\n                    }\n                }\n                loadedComponent.componentRef.instance[name] = options.inputs![name];\n            });\n        }\n        if (!!options.outputs) {\n            Object.keys(options.outputs).forEach(name => {\n                const eventEmitter: EventEmitter<any> = loadedComponent.componentRef.instance[name];\n                if (eventEmitter) {\n                    const subscription = eventEmitter.subscribe(options.outputs![name]);\n                    if (!loadedComponent.subscriptions) {\n                        loadedComponent.subscriptions = subscription;\n                    }\n                    else {\n                        loadedComponent.subscriptions.add(subscription);\n                    }\n                }\n            });\n        }\n        if (simpleChanges) {\n            ngOnChanges.call(loadedComponent.componentRef.instance, simpleChanges);\n        }\n    }\n\n    /**\n     * Bind a component's input and output properties according to the passed options. Generate a\n     * call to the component's `ngOnChanges` method if the inputs have changed since the last call.\n     * If the component has been previously bound it is first unbound by calling {@link #unbindComponent}\n     * which will unsubscribe the component's outputs\n     *\n     * @param options Specify the inputs and outputs for the component\n     * @param loadedComponent A component loaded by {@link #loadComponent}\n     */\n    public bindComponent(options: LoadComponentOptions, loadedComponent: LoadedComponent) {\n        return this._bindComponent(options, loadedComponent, false);\n    }\n\n    /**\n     * Unbind a previously bound dynamically loaded component. Subscriptions to the component's\n     * outputs are unsubscribed\n     *\n     * @param loadedComponent A component loaded by {@link #loadComponent}\n     */\n    unbindComponent(loadedComponent: LoadedComponent) {\n        if (!!loadedComponent.subscriptions) {\n            loadedComponent.subscriptions.unsubscribe();\n            loadedComponent.subscriptions = undefined;\n        }\n    }\n\n    /**\n     * Dynamically load a component from its type. The component's inputs and outputs will be initialized\n     * by calling {@link #bindComponent}.\n     *\n     * @param options The options containing the component to load and its inputs and outputs\n     * @param viewContainerRef Specifies where the loaded component should be attached. If not specified then the\n     * loaded component is inserted before the application component\n     * @param injector Overrides the injector to use as the parent for the component. By default this will be\n     * the injector held on the `viewContainerRef`\n     */\n    loadComponent<T>(options: LoadComponentOptions, viewContainerRef?: ViewContainerRef, injector?: Injector): LoadedComponent {\n        let componentRef: ComponentRef<T>;\n        let factory = this.factories.get(options.component);\n        if (!factory) {\n            factory = this.componentFactoryResolver.resolveComponentFactory(options.component);\n        }\n        if (!viewContainerRef) {\n            const appElement: Element = this.applicationRef.components[0].location.nativeElement;\n            const injector1 = this.applicationRef.components[0].injector;\n            componentRef = factory.create(injector1, [[appElement]]);\n            this.applicationRef.attachView(componentRef.hostView);\n            if (appElement.parentElement) {\n                appElement.parentElement.insertBefore(componentRef.location.nativeElement, appElement.nextSibling);\n            }\n        }\n        else {\n            if (!injector) {\n                injector = viewContainerRef.injector;\n            }\n            const index = !Utils.isEmpty(options.index) ? options.index : undefined;\n            componentRef = viewContainerRef.createComponent(factory, index, injector, []);\n        }\n        const loadedComponent: LoadedComponent = {\n            componentRef\n        };\n        this._bindComponent(options, loadedComponent, true);\n        loadedComponent.componentRef.changeDetectorRef.detectChanges();\n        return loadedComponent;\n    }\n\n    /**\n     * Unload a dynamically loaded component. It is unbound prior to being destroyed\n     *\n     * @param component A loaded component\n     */\n    unloadComponent(component: LoadedComponent) {\n        if (!!component) {\n            this.unbindComponent(component);\n            component.componentRef.destroy();\n        }\n    }\n}\n","import {Directive, Input, Output, OnChanges, OnDestroy, ViewContainerRef, ComponentRef, EventEmitter, Type} from \"@angular/core\";\nimport {LoadComponentService, LoadComponentOptions, LoadedComponent} from \"./load-component.service\";\n\n/**\n * A directive that uses the {@link LoadComponentService} to dynamically load a component.\n * The loaded component's lifecycle is automatically managed with changes to the directive's\n * `options` reflected to the component by rebinding it using {@link LoadComponentService}\n */\n@Directive({\n    selector: \"[sqLoadComponent]\"\n})\nexport class LoadComponentDirective implements OnChanges, OnDestroy {\n    /**\n     * Options for the loading of a component\n     */\n    @Input(\"sqLoadComponent\") options: LoadComponentOptions;\n    /**\n     * Used to emit events when the component is created and destroyed\n     */\n    @Output(\"sqLoadComponent\") eventEmitter = new EventEmitter<{componentRef: ComponentRef<Type<any>> | undefined}>();\n    private loadedComponent: LoadedComponent;\n    private currentComponent: Type<any>;\n\n    constructor(\n        private loadComponentService: LoadComponentService,\n        private viewContainerRef: ViewContainerRef) {\n    }\n\n    /**\n     * Handles any changes to the input `options`. On the first call the component is loaded\n     * and bound. Subsequent changes to the `options` are handled by rebinding the component unless\n     * the component type to load changes in which case the current component is unloaded before\n     * loading the new component.\n     *\n     * The component is loaded using the `ViewContainerRef` associated with the directive\n     */\n    ngOnChanges() {\n        if (this.loadedComponent) {\n            if (this.currentComponent === this.options.component) {\n                this.loadComponentService.bindComponent(this.options, this.loadedComponent);\n                return;\n            }\n            this.loadComponentService.unbindComponent(this.loadedComponent);\n            this.loadedComponent.componentRef.destroy();\n            this.eventEmitter.emit({componentRef: undefined});\n        }\n        this.loadedComponent = this.loadComponentService.loadComponent(this.options, this.viewContainerRef);\n        this.currentComponent = this.options.component;\n        this.eventEmitter.emit({componentRef: !!this.loadedComponent ? this.loadedComponent.componentRef : undefined});\n    }\n\n    /**\n     * Unbinds the loaded component. It is not destroyed here as angular will automatically destroy\n     * the component at the same time as this directive is destroyed as they share the same `ViewContainerRef`\n     */\n    ngOnDestroy() {\n        if (this.loadedComponent) {\n            this.loadComponentService.unbindComponent(this.loadedComponent);\n            this.eventEmitter.emit({componentRef: undefined});\n        }\n    }\n}\n","const LOAD_COMPONENT_MODULE_PROVIDERS = [];\n\nexport {LOAD_COMPONENT_MODULE_PROVIDERS};\n","import {NgModule} from \"@angular/core\";\nimport {CommonModule} from \"@angular/common\";\nimport {BaseModule} from \"@sinequa/core/base\";\n\nimport {LoadComponentDirective} from \"./load-component.directive\";\nimport {LOAD_COMPONENT_MODULE_PROVIDERS} from \"./module.providers\";\n\n/**\n * This module provides functionality for the dynamic loading of components based on the\n * techniques described in the [angular documentation]{@link https://angular.io/guide/dynamic-component-loader}\n */\n// @dynamic\n@NgModule({\n    imports: [\n        CommonModule,\n        BaseModule\n    ],\n    declarations: [\n        LoadComponentDirective\n    ],\n    exports: [\n        LoadComponentDirective\n    ],\n    providers: [\n        ...LOAD_COMPONENT_MODULE_PROVIDERS\n    ]\n})\nexport class LoadComponentModule {\n}\n"]}