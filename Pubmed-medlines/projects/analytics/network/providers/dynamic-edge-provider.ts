import { Query } from '@sinequa/core/app-utils';
import { Results, Record } from '@sinequa/core/web-services';
import { EdgeType, Node, Edge, NetworkProvider, NetworkDataset } from '../network-models';
import { RecordsProvider, StructuralEdgeType, RecordNode } from './records-provider';
import { combineLatest } from 'rxjs';
import { Action } from '@sinequa/components/action';

/**
 * Extension of the Edge interface, to include the record property
 * from which this edge is generated
 */
export interface DynamicEdge extends Edge {
    record: Record;
}

/**
 * Extension of the EdgeType interface, to include properties specific
 * to dynamic edges, in particular a function that returns a Query object
 * for a given source node.
 */
export interface DynamicEdgeType extends EdgeType {
    /** Returns a query object to execute to obtain dynamic edges from a node */
    getQuery: (node: Node, type: DynamicEdgeType) => Query | undefined;
    /** count limits the number of records returned by the query service and allows for pagination */
    count?: number;
    /** Defines when the dynamic edge should be executed. Warning: oninsert may generate multiple simultaneous queries */
    trigger: "oninsert" | "onclick" | "manual";
}

/**
 * Tests whether a given edge type is a DynamicEdgeType
 * @param et an edge type
 */
export function isDynamicEdgeType(et: EdgeType): et is DynamicEdgeType {
    return !!(et as DynamicEdgeType).getQuery;
}


/**
 * A extension of the RecordsProvider, where records are not directly
 * provided, but are instead fetched from the server via a Query specific
 * to a source node.
 * Concretely, the dynamic edge provider will attach one (or more) record nodes
 * (and their structural edges) to one (or more) source nodes, whose type is
 * specified in the DynamicEdgeType.
 * Dynamic edges can be attached right when the source nodes are inserted (oninsert),
 * or when a user clicks on a source node (onclick) or when a user clicks on an
 * action button displayed when a source node is clicked.
 * Note that the "source node" have to come from different providers, so it is
 * necessary to listen to these providers and update the data generated by this
 * provider accordingly.
 */
export class DynamicEdgeProvider extends RecordsProvider {

    /** List of the source nodes that have been already processed via clicks or actions */
    protected processedNodes: string[] = [];
    /** to avoid fetching the same data multiple times, we store the record objects fetched from the server in this cache */
    protected nodeCache = new Map<string, Results>();

    constructor(
        public name: string,
        protected edgeType: DynamicEdgeType,
        protected secondaryEdgeTypes: StructuralEdgeType[],
        protected permanent: boolean,
        protected sourceProviders: NetworkProvider[]
    ){
        super(name, edgeType.nodeTypes[1], secondaryEdgeTypes, [], false);

        combineLatest(sourceProviders.map(p => p.getProvider())).subscribe(dataset => {
            if(this.active) {
                // Merge the nodes from all datasets into a map
                const map = new Map<string, Node>();
                dataset.forEach(dataset => {
                    dataset.getNodes().forEach(node => {
                        if(node.visible && node.type === this.edgeType.nodeTypes[0]) {
                            map.set(node.id, node);
                        }
                    });
                });
                // Update the dataset of dynamic edges
                this.updateDynamicDataset(Array.from(map.values()));
            }
        });
    }
    
    /**
     * Rebuilds the dataset of this provider, given a list of source nodes to process.
     * @param sourceNodes A list of source node to process
     */
    protected updateDynamicDataset(sourceNodes: Node[]) {

        // We rebuild the dataset from scratch, in case some source nodes were removed
        this.dataset = new NetworkDataset();

        // If oninsert, we want to process all the source nodes. If not, we want to process the nodes in the processedNodes list
        if(this.edgeType.trigger !== "oninsert") {
            this.processedNodes = this.processedNodes.filter(id => !!sourceNodes.find(node => node.id === id)); // We want to "forget" the nodes that are not in the source anymore
            sourceNodes = sourceNodes.filter(node => this.processedNodes.indexOf(node.id) !== -1); // We want to process only the nodes currently in the processed list
        }

        // For each source, we get its query
        const queries = sourceNodes.map(node => this.nodeCache.has(node.id)? undefined : this.edgeType.getQuery(node, this.edgeType));
        const _queries = queries.filter(q => !!q) as Query[];
        // If there are queries, we process them asynchronously
        if(_queries.length > 0) {
            this.context.searchService.getMultipleResults(_queries, undefined).subscribe(res => {
                this.addDynamicEdges(sourceNodes, res.results, queries);
            });
        }
        // If not, we process them synchronously
        else {
            this.addDynamicEdges(sourceNodes, [], queries);
        }
    
    }

    /**
     * Add dynamic edges to a list of source nodes, given a results set
     * for each of these nodes (either directly provided or stored in the cache).
     * @param sourceNodes The source nodes
     * @param res The list of results sets
     * @param queries The list of queries from which we obtained the results
     */
    protected addDynamicEdges(sourceNodes: Node[], res: Results[], queries: (Query|undefined)[]){
        let j = 0;
        // For each source node
        for(let i = 0; i<sourceNodes.length; i++){
            const sourceNode = sourceNodes[i];
            const query = queries[i];
            // If it has a query or a cached result
            if(query || this.nodeCache.has(sourceNode.id)) {
                const results = this.nodeCache.has(sourceNode.id)? this.nodeCache[sourceNode.id] : res[j++]; // Get the results
                this.nodeCache[sourceNode.id] = results; // update cache
                this.dataset.addNodes(sourceNode); // This will create a duplicate node which will be merged
                const recordNodes = this.addRecordNodes(results.records); // Creates all the record nodes and their secondary edges
                const recordEdges = this.createDynamicEdges(sourceNode, recordNodes);
                this.dataset.addEdges(recordEdges);
            }
        }
        this.provider.next(this.dataset);
    }

    /**
     * Creates and returns edge objects for a given source node and the record nodes
     * that must be attached to it.
     * @param node The source node
     * @param recordNodes The new record nodes that must be attached to the source node
     */
    protected createDynamicEdges(node: Node, recordNodes: RecordNode[]): DynamicEdge[] {
        return recordNodes.map(rNode => this.createEdge(this.edgeType, node, rNode, undefined, node.visible, {record: rNode.record}) as DynamicEdge);
    }

    /**
     * Attach dynamic edges to a given node, either synchronously, if the results set
     * is available in the cache, or asynchronously, by fetching the data from the server.
     * @param node The node to process
     */
    protected processNode(node: Node) {
        const query = this.edgeType.getQuery(node, this.edgeType); // Get the search query for this node
        if(query){
            if(this.nodeCache.has(node.id)) {
                if(!this.permanent) {
                    this.dataset.clear(); // Remove data from previously clicked node
                    this.processedNodes.splice(0); // Remove the processed nodes
                }
                this.processedNodes.push(node.id);
                this.addDynamicEdges([node], [], [query]); // Insert dynamic nodes and edges for this clicked node
            }
            else {
                this.context.searchService.getResults(query, undefined, {searchInactive: true})
                    .subscribe(results => {
                        if(!this.permanent) {
                            this.dataset.clear(); // Remove data from previously clicked node
                            this.processedNodes.splice(0); // Remove the processed nodes
                        }
                        this.processedNodes.push(node.id);
                        this.addDynamicEdges([node], [results], [query]); // Insert dynamic nodes and edges for this clicked node
                    });
            }
        }
    }


    // Network provider interface

    /**
     * Process a clicked source node, if the trigger of the edge type is "onclick"
     * @param node The clicked node
     */
    onNodeClicked(node?: Node) {
        super.onNodeClicked(node);
        if(this.active && this.edgeType.trigger === "onclick" && node && node.type === this.edgeType.nodeTypes[0] && !this.dataset.hasNode(node.id)) {
            this.processNode(node);
        }
    }
    
    /**
     * Returns an Action allowing to process a node, if the trigger of the edge type
     * is "manual".
     * @param node The clicked node
     */
    getNodeActions(node: Node): Action[] {
        const actions = super.getNodeActions(node);
        if(this.active && this.edgeType.trigger === "manual" && node && node.type === this.edgeType.nodeTypes[0] && !this.dataset.hasNode(node.id)) {            
            actions.push(new Action({
                icon: "fas fa-expand-arrows-alt",
                title: this.context.intlService.formatMessage("msg#network.actions.expandNode", {label: node.label}),
                action: () => {
                    this.processNode(node);
                }
            }));            
        }
        return actions;
    }
}
