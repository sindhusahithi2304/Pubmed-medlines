<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Components</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">Components</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>FacetChangeEvent</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>facet/facet.service.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#facet">facet</a>
                                </li>
                                <li>
                                        <a href="#type">type</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="facet"></a>
                                        <span class="name"><b>facet</b><a href="#facet"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>facet:         <code><a href="../interfaces/FacetState.html" target="_self" >FacetState</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/FacetState.html" target="_self" >FacetState</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="type"></a>
                                        <span class="name"><b>type</b><a href="#type"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>type:         <code><a href="../miscellaneous/typealiases.html#EventType" target="_self" >FacetEventType</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../miscellaneous/typealiases.html#EventType" target="_self" >FacetEventType</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {Injectable, Inject, Optional, InjectionToken} from &quot;@angular/core&quot;;
import {UserSettingsWebService, UserSettings, Suggestion,
    Results, Aggregation, AggregationItem, TreeAggregation, TreeAggregationNode,
    AuditEvents, EngineType, Select, CCColumn
} from &quot;@sinequa/core/web-services&quot;;
import {IntlService} from &quot;@sinequa/core/intl&quot;;
import {Query, AppService, FormatService, ExprBuilder, Expr} from &quot;@sinequa/core/app-utils&quot;;
import {FieldValue, Utils} from &quot;@sinequa/core/base&quot;;
import {Subject, Observable} from &quot;rxjs&quot;;
import {map} from &quot;rxjs/operators&quot;;
import {SearchService, BreadcrumbsItem, Breadcrumbs} from &quot;@sinequa/components/search&quot;;
import {SuggestService} from &quot;@sinequa/components/autocomplete&quot;;

// Facet interface (from models/UserSettings)
export interface FacetState {
    name: string;
    position: number; // eg 0 &#x3D; left, 1 &#x3D; right
    expanded: boolean;
    hidden: boolean;
    view: string;
}

/**
 * Options for the [[FacetService.AddFilter]] and [[FacetService.AddFilterSearch]] methods
 *
 * and: If multiple items are filtered, determines whether they are filtered as AND or OR
 * not: Whether this is an exlusion of the filtered item
 * replaceCurrent: if true, the current filter is replaced
 */
export interface AddFilterOptions {
    and?: boolean;
    not?: boolean;
    replaceCurrent?: boolean;
}

// Audit Events (from models/Audit)
export const enum FacetEventType {
    Loaded &#x3D; &quot;Facet_Loaded&quot;,
    Add &#x3D; &quot;Facet_Added&quot;,
    AddAll &#x3D; &quot;Facets_Added&quot;,
    Remove &#x3D; &quot;Facet_Removed&quot;,
    RemoveAll &#x3D; &quot;Facets_Removed&quot;,

    Patched &#x3D; &quot;Facet_Patched&quot;,
    ClearFilters &#x3D; &quot;Facet_ClearFilters&quot;,
    AddFilter &#x3D; &quot;Facet_AddFilter&quot;,
    RemoveFilter &#x3D; &quot;Facet_RemoveFilter&quot;,
    Open &#x3D; &quot;Facet_TreeOpen&quot;
}

// Types of events triggering a change event
export const FACET_CHANGE_EVENTS &#x3D; [
    FacetEventType.Loaded,
    FacetEventType.Add,
    FacetEventType.Remove
];


// CRUD Events
export interface FacetChangeEvent {
    type: FacetEventType;
    facet?: FacetState;
}

export const ALL_FACETS &#x3D; new InjectionToken&lt;any[]&gt;(&#x27;ALL_FACETS&#x27;);
export const DEFAULT_FACETS &#x3D; new InjectionToken&lt;FacetState[]&gt;(&#x27;DEFAULT_FACETS&#x27;);

@Injectable({
    providedIn: &#x27;root&#x27;,
})
export class FacetService {

    protected readonly _events &#x3D; new Subject&lt;FacetChangeEvent&gt;();
    protected readonly _changes &#x3D; new Subject&lt;FacetChangeEvent&gt;();

    constructor(
        protected userSettingsService: UserSettingsWebService,
        protected searchService: SearchService,
        protected suggestService: SuggestService,
        protected appService: AppService,
        protected intlService: IntlService,
        protected formatService: FormatService,
        protected exprBuilder: ExprBuilder,
        @Optional() @Inject(ALL_FACETS) public allFacets: any[],
        @Optional() @Inject(DEFAULT_FACETS) public defaultFacets: FacetState[]){

        // Listen to the user settings
        this.userSettingsService.events.subscribe(event &#x3D;&gt; {
            // E.g. new login occurs
            // &#x3D;&#x3D;&gt; Menus need to be rebuilt
            this.events.next({type: FacetEventType.Loaded});
        });
        // Listen to own events, to trigger change events
        this._events.subscribe(event &#x3D;&gt; {
            if(FACET_CHANGE_EVENTS.indexOf(event.type) !&#x3D;&#x3D; -1){
                this.changes.next(event);
            }
        });
    }

    // GETTERS

    /**
     * Returns the list of this user&#x27;s facets.
     * The list is stored in the user settings (this is a redirection).
     * Using this service creates the list of facets if it does not already exist.
     */
    public get facets() : FacetState[] {
        if(!this.userSettingsService.userSettings)
            this.userSettingsService.userSettings &#x3D; {};
        if(!this.userSettingsService.userSettings[&quot;facets&quot;]) {
            this.userSettingsService.userSettings[&quot;facets&quot;] &#x3D; [];
            if(!!this.defaultFacets){
                this.userSettingsService.userSettings[&quot;facets&quot;].push(...this.defaultFacets);
                this.patchFacets();
            }
        }
        return this.userSettingsService.userSettings[&quot;facets&quot;];
    }

    /**
     * @returns a facet with the given name or undefined if it does not exist
     * @param name
     */
    public facet(name: string): FacetState | undefined {
        const i &#x3D; this.facetIndex(name);
        return i&gt;&#x3D; 0? this.facets[i] : undefined;
    }

    /**
     * Returns the list of facet config in the given container (position)
     * @param position (default to 0 if there is a single container)
     */
    public getFacets(position: number &#x3D; 0) : any[] {
        if (!this.allFacets) {
            return [];
        }
        return this.facets.filter(f &#x3D;&gt; f.position &#x3D;&#x3D;&#x3D; position)
            .map(f &#x3D;&gt; this.allFacets.find(_f &#x3D;&gt; _f.name &#x3D;&#x3D;&#x3D; f.name));
    }

    /**
     * Returns true if this facet is opened (in any container)
     * @param facetName
     */
    public isFacetOpened(facetName): boolean {
        return !!this.facets.find(f &#x3D;&gt; f.name &#x3D;&#x3D;&#x3D; facetName);
    }

    protected facetIndex(name: string): number {
        for (let i &#x3D; 0, ic &#x3D; this.facets.length; i &lt; ic; i++) {
            const facet &#x3D; this.facets[i];
            if (facet &amp;&amp; facet.name &#x3D;&#x3D;&#x3D; name) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Triggers any events regarding the facets
     */
    public get events(): Subject&lt;FacetChangeEvent&gt; {
        return this._events;
    }

    /**
     * Triggers when events affect the list of facets
     * Cf. CHANGE_EVENTS list
     */
    public get changes() : Subject&lt;FacetChangeEvent&gt; {
        return this._changes;
    }


    public addFacet(facet: FacetState){
        this.facets.push(facet);
        this.events.next({type : FacetEventType.Add, facet: facet});
        this.patchFacets([{
            type: FacetEventType.Add,
            detail: {
                facet: facet.name
            }
        }]);
    }

    public removeFacet(facet: FacetState){
        const i &#x3D; this.facetIndex(facet.name);
        if(i !&#x3D;&#x3D; -1){
            this.facets.splice(i,1);
            this.events.next({type : FacetEventType.Remove, facet: facet});
            this.patchFacets([{
                type: FacetEventType.Remove,
                detail: {
                    facet: facet.name
                }
            }]);
        }
    }

    public addAllFacet() {
        this.facets.splice(0,this.facets.length);
        if(!!this.defaultFacets) this.facets.push(...this.defaultFacets);
        this.events.next({type : FacetEventType.AddAll});
        this.patchFacets([{
            type: FacetEventType.AddAll
        }]);
    }

    public removeAllFacet() {
        this.facets.splice(0,this.facets.length);
        this.events.next({type : FacetEventType.RemoveAll});
        this.patchFacets([{
            type: FacetEventType.RemoveAll
        }]);
    }

    /**
     * Updates facets in User settings.
     * @param auditEvents : Audit Events to be triggered
     * @returns an Observable which can be used to trigger further events
     */
    protected patchFacets(auditEvents?: AuditEvents) {
        return this.userSettingsService.patch({facets: this.facets} as UserSettings, auditEvents)
            .subscribe(
                next &#x3D;&gt; {
                    this.events.next({type: FacetEventType.Patched});
                },
                error &#x3D;&gt; {
                    console.error(&quot;Could not patch Facets!&quot;, error);
            });
    }

    /**
     * Filter/Exclude an item in a facet and launch a search.
     * Triggers an internal event and an Audit Event
     * @param facetName
     * @param aggregation
     * @param items
     * @param options
     */
    public addFilterSearch(
        facetName: string,
        aggregation: Aggregation,
        items: AggregationItem | AggregationItem[],
        options: AddFilterOptions &#x3D; {}): Promise&lt;boolean&gt; {

        const success &#x3D; this.addFilter(facetName, aggregation, items, options);
        if(success) {
            this.events.next({ type: FacetEventType.AddFilter, facet: this.facet(facetName) });
            return this.searchService.search(undefined, {
                type: FacetEventType.AddFilter,
                detail: {
                    item: &lt;any&gt;this.searchService.query.lastSelect(),
                    itembox: facetName,
                    itemcolumn: aggregation.column,
                    isitemexclude: options.not,
                    &quot;from-result-id&quot;: this.searchService.results?.id
                }
            });
        }
        return Promise.resolve(false);
    }


    /**
     * Filter/Exclude one or more item(s) in a facet (without launching a search)
     * @param facetName
     * @param aggregation
     * @param items
     * @param options
     * @param query the query on which to add the filter (defaults to search service query)
     * @param breadcrumbs breadcrumbs in which to look for selected items (defaults  to search service breadcrumbs)
     */
    public addFilter(
        facetName: string,
        aggregation: Aggregation,
        items: AggregationItem | AggregationItem[],
        options: AddFilterOptions &#x3D; {},
        query &#x3D; this.searchService.query,
        breadcrumbs &#x3D; this.searchService.breadcrumbs): boolean {

        if (!items) {
            return false;
        }
        if (options.replaceCurrent) {
            query.removeSelect(facetName);
        }

        if (!aggregation.isTree &amp;&amp; breadcrumbs?.activeSelects.length &amp;&amp; !options.replaceCurrent) {
            const expr &#x3D; breadcrumbs.findSelect(facetName);
            const index &#x3D; breadcrumbs.activeSelects.findIndex(select &#x3D;&gt; select.facet &#x3D;&#x3D;&#x3D; facetName &amp;&amp; (select.expr &#x3D;&#x3D;&#x3D; expr || select.expr &#x3D;&#x3D;&#x3D; expr?.parent));
            const same &#x3D; (!Array.isArray(items)) ? true : (options.and ? &quot;AND&quot; : &quot;OR&quot;) &#x3D;&#x3D;&#x3D; (expr?.and ? &quot;AND&quot; : &quot;OR&quot;) &amp;&amp; (options.not ? &quot;YES&quot; : &quot;NO&quot;) &#x3D;&#x3D;&#x3D; (expr?.not ? &quot;YES&quot; : &quot;NO&quot;);

            if (expr &amp;&amp; same &amp;&amp; index !&#x3D;&#x3D; -1){
                let _items: AggregationItem[];
                if (expr?.operands) {
                    _items &#x3D; this.exprToAggregationItem(expr.operands, aggregation.valuesAreExpressions).concat(items);
                } else {
                    // previous selection is a single value
                    _items &#x3D; this.exprToAggregationItem(expr as Expr, aggregation.valuesAreExpressions).concat(items);
                }
                // MUST reset $excluded property otherwise expression is misunderstood
                _items.forEach(item &#x3D;&gt; item.$excluded &#x3D; undefined);
                // overrides options settings with expression if any
                let _expr &#x3D; this.exprBuilder.makeAggregationExpr(aggregation, _items, options.and || expr.and);
                if (options.not || expr.not) {
                    _expr &#x3D; this.exprBuilder.makeNotExpr(_expr);
                }
                if (_expr) {
                    query.replaceSelect(index, {expression: _expr, facet: facetName});
                    return true;
                }
            }
        }
        let expr &#x3D; this.exprBuilder.makeAggregationExpr(aggregation, items, options.and);
        if (options.not) {
            expr &#x3D; this.exprBuilder.makeNotExpr(expr);
        }
        if (expr) {
            query.addSelect(expr, facetName);
            return true;
        }
        return false;
    }

    /**
     * Clears the query from the current selection on the given facet
     * @param facetName
     * @param all
     * @param query the query to clear from the facet selection (defaults to search service query)
     */
    public clearFilters(facetName: string, all?: boolean, query &#x3D; this.searchService.query) {
        query.removeSelect(facetName, all);
    }

    /**
     * Clears the query from the current selection on the given facet and perform a search
     * @param facetName
     * @param all
     */
    public clearFiltersSearch(facetName: string | string[], all?: boolean): Promise&lt;boolean&gt; {
        [].concat(facetName as []).forEach(name &#x3D;&gt; {
            this.clearFilters(name, all);
            this._events.next({type: FacetEventType.ClearFilters, facet: this.facet(name)});
        });

        return this.searchService.search(undefined, {
                type: FacetEventType.ClearFilters,
                detail: {
                    itembox: facetName,
                    &quot;from-result-id&quot;: this.searchService.results?.id
                }
            });
    }

    /**
     * Remove a filter and update the appropriate Select if it was previously included in a selection
     * @param facetName the facet that removes the filter
     * @param aggregation the aggregation that contains the item to remove
     * @param item the aggregation item to remove from the query
     * @param query the query on which to remove the filter (defaults to search service query)
     * @param breadcrumbs breadcrumbs in which to look for selected items (defaults  to search service breadcrumbs)
     */
    public removeFilter(
        facetName: string,
        aggregation: Aggregation,
        item: AggregationItem,
        query &#x3D; this.searchService.query,
        breadcrumbs &#x3D; this.searchService.breadcrumbs): Select | undefined {

        if (breadcrumbs) {
            // if item is excluded, makeAggregation() should returns a NOT expression
            const stringExpr &#x3D; item.$excluded ? this.exprBuilder.makeNotExpr(this.exprBuilder.makeAggregationExpr(aggregation, item)) : this.exprBuilder.makeAggregationExpr(aggregation, item);
            const filterExpr &#x3D; this.findItemFilter(facetName, aggregation, item, breadcrumbs) || this.appService.parseExpr(stringExpr);
            const expr &#x3D; breadcrumbs.findSelect(facetName, filterExpr);
            const i &#x3D; breadcrumbs.activeSelects.findIndex(select &#x3D;&gt; select.facet &#x3D;&#x3D;&#x3D; facetName &amp;&amp; (select.expr &#x3D;&#x3D;&#x3D; expr || select.expr &#x3D;&#x3D;&#x3D; expr?.parent));

            // &#x27;Select&#x27; can&#x27;t be created when aggregation is a tree map, so, avoid aggregation tree
            // and remove whole breadcrumbs
            if (!aggregation.isTree &amp;&amp; expr &amp;&amp; expr.parent &amp;&amp; expr.parent.operands.length &gt; 1) {
                // create a new Expr from parent and replaces Select by this new one
                // so, breadcrumbs stay ordered
                const filterByValuesAreExpression &#x3D; (it: AggregationItem) &#x3D;&gt; it.value.toString().replace(/ /g, &quot;&quot;) !&#x3D;&#x3D; item.value.toString().replace(/ /g, &quot;&quot;);
                const filterByValue &#x3D; (it: AggregationItem) &#x3D;&gt; it.value !&#x3D;&#x3D; item.value
                const filter &#x3D; (aggregation.valuesAreExpressions) ? filterByValuesAreExpression : filterByValue;

                const items: AggregationItem[] &#x3D; this.exprToAggregationItem(expr.parent.operands, aggregation.valuesAreExpressions).filter(filter);
                // MUST reset $excluded property otherwise expression is misunderstood (mainly NOT expressions)
                items.forEach(item &#x3D;&gt; item.$excluded &#x3D; undefined);
                const {not, and} &#x3D; breadcrumbs.selects[i].expr || {};
                let _expr &#x3D; this.exprBuilder.makeAggregationExpr(aggregation, items, and);
                if (not) {
                    _expr &#x3D; this.exprBuilder.makeNotExpr(_expr);
                }
                if (_expr) {
                    query.replaceSelect(i, {expression: _expr, facet: facetName});
                    return {expression: this.exprBuilder.makeAggregationExpr(aggregation, item), facet: facetName};
                }
            } else {
                // filter is a single value... remove it
                const select &#x3D; query.select ? query.select[i] : undefined;
                query.removeSelect(i);
                return select;
            }
        }
        return undefined;
    }

    /**
     * Removes the aggregation from the search service query and refresh the search
     * @param facetName
     * @param aggregation
     * @param item
     */
    public removeFilterSearch(facetName: string, aggregation: Aggregation, item: AggregationItem): Promise&lt;boolean&gt;{
        const select &#x3D; this.removeFilter(facetName, aggregation, item);
        if(select) {
            this._events.next({type: FacetEventType.RemoveFilter, facet: this.facet(facetName || &quot;&quot;)});
            delete this.searchService.query.queryId; // SBA-154
            return this.searchService.search(undefined, {
                type: FacetEventType.RemoveFilter,
                detail: {
                    item: {expression: select?.expression, facet: select?.facet},
                    itembox: facetName,
                    itemcolumn: aggregation.column,
                    &quot;from-result-id&quot;: !!this.searchService.results ? this.searchService.results.id : null
                }
            });
        }
        return Promise.resolve(false);
    }

    /**
     * Queries the server for data for this aggregation
     * @param aggregation
     * @param skip
     * @param count
     * @param query the query to use to fetch the data (default to search service query)
     */
    public loadData(
        aggregation: string,
        skip: number &#x3D; 0,
        count: number &#x3D; 10,
        query &#x3D; this.searchService.query,
        searchInactive &#x3D; true): Observable&lt;Aggregation | undefined&gt; {

        query &#x3D; Utils.copy(query);
        query.action &#x3D; &quot;aggregate&quot;;
        query.aggregations &#x3D; {};
        query.aggregations[aggregation] &#x3D; {skip: skip, count: count};
        return this.searchService.getResults(query, undefined, {searchInactive}).pipe(
            map((results: Results) &#x3D;&gt; {
                const data &#x3D; results.aggregations.find(a &#x3D;&gt; Utils.eqNC(a.name, aggregation));
                if (data) {
                    this.setColumn(data);   // Useful for formatting and i18n
                }
                return data;
            })
        );
    }

    /**
     * Get suggestions given a text and a field name, using the Suggest service
     * @param text
     * @param field
     * @param suggestQuery
     */
    public suggest(text: string, field: string, suggestQuery &#x3D; this.appService.suggestQueries[0]): Observable&lt;Suggestion[]&gt; {
        return this.suggestService.get(suggestQuery, text, [field], this.searchService.query);
    }

    /**
     * Format the given result item, using field formatter and/or i18n service
     * @param item
     */
    formatValue(item: AggregationItem): string {
        return this.intlService.formatMessage(
            this.formatService.formatFieldValue(item, item.$column));
    }

    /**
     * Returns true if this facet has at least one active selection
     * filtering the search
     * @param facetName
     * @param breadcrumbs breadcrumbs in which to look for selected items (defaults to search service breadcrumbs)
     */
    public hasFiltered(facetName: string, breadcrumbs &#x3D; this.searchService.breadcrumbs) : boolean {
        return !!this.findFilter(facetName, breadcrumbs);
    }

    /**
     * Returns an active selection of this facet filtering the search
     * Returns it as an expression
     * @param facetName
     * @param breadcrumbs breadcrumbs in which to look for selected items (defaults to search service breadcrumbs)
     */
    public findFilter(facetName: string, breadcrumbs &#x3D; this.searchService.breadcrumbs) : Expr | undefined {
        return breadcrumbs?.findSelect(facetName);
    }

    /**
     * Look for an aggregation with the given name in the search results and returns it.
     * Takes care of initializing the aggregation items to insert their $column property.
     * @param aggregationName
     * @param results The search results can be provided explicitly or taken from the SearchService implicitly.
     */
    getAggregation(
        aggregationName: string,
        results &#x3D; this.searchService.results,
        treeAggregationOptions?: {
            facetName: string,
            levelCallback?: (nodes: TreeAggregationNode[], level: number, node: TreeAggregationNode) &#x3D;&gt; void
        }
    ): Aggregation | TreeAggregation | undefined {

        if (results?.aggregations) {
            const aggregation &#x3D; results.aggregations.find(agg &#x3D;&gt; Utils.eqNC(agg.name, aggregationName))
            if (aggregation) {
                this.setColumn(aggregation);    // Useful for formatting and i18n
                if (aggregation.isTree &amp;&amp; treeAggregationOptions) {
                    const expr &#x3D; this.findFilter(treeAggregationOptions.facetName);
                    const expandPaths &#x3D; expr ? expr.getValues(aggregation.column) : [];
                    this.initTreeNodes(treeAggregationOptions.facetName, aggregation, &quot;/&quot;, aggregation.items as TreeAggregationNode[], expandPaths, treeAggregationOptions.levelCallback);

                    return aggregation as TreeAggregation;
                }
                return aggregation;
            }
        }
        return undefined;
    }

    /**
     * Look for a Tree aggregation with the given name in the search results and returns it.
     * Takes care of initializing the Node aggregation items to insert their properties ($column, $path, $opened, $level)
     * @deprecated use getAggregation() instead
     * @param facetName
     * @param aggregationName
     * @param results The search results can be provided explicitly or taken from the SearchService implicitly.
     * @param levelCallback A callback method called at every level of the tree.
     * Can be used to read or alter the properties of the nodes (opening, closing), or node list (sorting)
     */
    getTreeAggregation(
        facetName: string,
        aggregationName: string,
        results &#x3D; this.searchService.results,
        levelCallback?: (nodes: TreeAggregationNode[], level: number, node: TreeAggregationNode) &#x3D;&gt; void
    ): TreeAggregation | undefined {

        const agg &#x3D; this.getAggregation(aggregationName, results);
        if(agg?.isTree){
            const expr &#x3D; this.findFilter(facetName);
            const expandPaths &#x3D; expr ? expr.getValues(agg.column) : [];
            this.initTreeNodes(facetName, agg, &quot;/&quot;, agg.items as TreeAggregationNode[], expandPaths, levelCallback);

            return agg as TreeAggregation;
        }
        return undefined;
    }

    /**
     * Returns the count parameter of the given aggregation (default is 10)
     * @param aggregationName
     */
    getAggregationCount(aggregationName: string) : number {
        return this.appService.getCCAggregation(aggregationName)?.count || 10;
    }

    /**
     * Opens a Tree node of the given tree facet by querying data from the server
     * Takes care of initializing the Node aggregation items to insert their properties ($column, $path, $opened, $level)
     * @param facetName
     * @param aggregation
     * @param item
     * @param levelCallback A callback method called at every level of the tree.
     * Can be used to read or alter the properties of the nodes (opening, closing), or node list (sorting)
     */
    open(
        facetName: string,
        aggregation: TreeAggregation,
        item: TreeAggregationNode,
        levelCallback?: (nodes: TreeAggregationNode[], level: number, node: TreeAggregationNode) &#x3D;&gt; void,
        query &#x3D; this.searchService.query,
        searchInactive &#x3D; true
    ): Observable&lt;Results&gt; {

        const value &#x3D; item.$path + &quot;*&quot;;
        query &#x3D; Query.copy(query);
        query.action &#x3D; &quot;open&quot;;
        const expr &#x3D; this.exprBuilder.makeExpr(aggregation.column, value);
        query.addOpen(expr, aggregation.name);

        this.events.next({type: FacetEventType.Open, facet: this.facet(facetName)});
        return this.searchService.getResults(query, undefined, {searchInactive}).pipe(
            map((results: Results) &#x3D;&gt; {
                if (item.$path) {
                    const source &#x3D; FacetService.getAggregationNode(results.aggregations[0].items as TreeAggregationNode[], item.$path);
                    const target &#x3D; FacetService.getAggregationNode(aggregation.items as TreeAggregationNode[], item.$path);
                    if (source &amp;&amp; target) {
                        target.items &#x3D; source.items;    // Insert the new data (source) into the original (target)
                    }
                    if (target &amp;&amp; target.items) {
                        this.initTreeNodes(facetName, aggregation, item.$path, target.items, undefined, levelCallback);
                    }
                }
                return results;
            })
        );
    }

    /**
     * Returns true if a given aggregation item is currently actively filtering the search
     * @param facetName
     * @param aggregation
     * @param item
     * @param breadcrumbs breadcrumbs in which to look for selected items (default to search service breadcrumbs)
     */
    itemFiltered(facetName: string, aggregation: Aggregation, item: AggregationItem, breadcrumbs &#x3D; this.searchService.breadcrumbs): boolean {
        return !!this.findItemFilter(facetName, aggregation, item, breadcrumbs);
    }

    protected findItemFilter(facetName: string, aggregation: Aggregation, item: AggregationItem, breadcrumbs: Breadcrumbs | undefined) : Expr | undefined {
        let expr: Expr | undefined;
        let exprText: string;
        if (!aggregation.valuesAreExpressions) {
            let value: string;
            if (aggregation.isTree) {
                value &#x3D; Utils.toSqlValue((&lt;TreeAggregationNode&gt;item).$path + &quot;*&quot;);
            }
            else {
                value &#x3D; Utils.toSqlValue(item.value);
            }
            exprText &#x3D; this.exprBuilder.makeExpr(aggregation.column, value);
        }
        else {
            exprText &#x3D; item.value as string;
        }
        const ret &#x3D; this.appService.parseExpr(exprText);
        if (ret instanceof Expr) {
            expr &#x3D; &lt;Expr&gt;ret;
        }
        if (expr) {
            const expr2 &#x3D; breadcrumbs?.findSelect(facetName, expr);
            if(!!expr2 &amp;&amp; (!expr2.parent || !expr2.parent.parent)){
                return expr2;
            }
        }
        return undefined;
    }

    /**
     * Initializes the nodes of a tree (private, with a callback)
     * @param facetName
     * @param aggregation
     * @param root
     * @param children
     * @param expandPaths
     * @param levelCallback
     */
    protected initTreeNodes(
        facetName: string,
        aggregation: Aggregation,
        root: string,
        children: TreeAggregationNode[],
        expandPaths?: string[],
        levelCallback?: (nodes: TreeAggregationNode[], level: number, node: TreeAggregationNode) &#x3D;&gt; void
    ) {
        if (!children) {
            return;
        }
        let rootLevel: number;
        if (root) {
            rootLevel &#x3D; Utils.count(root, &quot;/&quot;, false) - 1;
        }
        else {
            root &#x3D; &quot;/&quot;;
            rootLevel &#x3D; 0;
        }
        const column &#x3D; this.appService.getColumn(aggregation.column);
        Utils.traverse(children, (_nodes) &#x3D;&gt; {
            if (!_nodes) {
                return false;
            }
            let path &#x3D; root;
            let level &#x3D; rootLevel;
            for (const _node of _nodes) {
                path &#x3D; path + _node.value + &quot;/&quot;;
                level++;
            }
            // console.log(path);
            const _node &#x3D; _nodes[_nodes.length - 1];
            _node.$path &#x3D; path;
            _node.$column &#x3D; column;
            _node.$level &#x3D; level;
            _node.$opened &#x3D; false;
            _node.$filtered &#x3D; this.itemFiltered(facetName, aggregation, _node)
            expandPaths?.forEach(expandPath &#x3D;&gt; {
                if (expandPath.indexOf(path) &#x3D;&#x3D;&#x3D; 0) {
                    const count &#x3D; !!_node.items ? _node.items.length : _node.hasChildren ? -1 : 0;
                    if (count &gt; 0) {
                        _node.$opened &#x3D; true;
                    }
                }
            });
            if (levelCallback) {
                levelCallback(_nodes, level, _node);
            }
            return false; // don&#x27;t stop
        });
    }

    protected setColumn(aggregation: Aggregation){
        if(!aggregation.isTree &amp;&amp; aggregation.items){
            const column &#x3D; this.appService.getColumn(aggregation.column);
            aggregation.items.forEach((value) &#x3D;&gt; value.$column &#x3D; column);
        }
    }



    // static methods

    protected static splitTreepath(path: string): string[] {
        if (!path) return [];
        path &#x3D; path.trim();
        if (path.length &gt; 0 &amp;&amp; path[0] &#x3D;&#x3D;&#x3D; &quot;/&quot;) {
            path &#x3D; path.substr(1);
        }
        if (path.length &gt; 0 &amp;&amp; path[path.length - 1] &#x3D;&#x3D;&#x3D; &quot;/&quot;) {
            path &#x3D; path.substr(0, path.length - 1);
        }
        if (path.length &#x3D;&#x3D;&#x3D; 0) {
            return [];
        }
        return path.split(&quot;/&quot;);
    }


    public static treepathLast(path: string): string {
        const parts &#x3D; FacetService.splitTreepath(path);
        if (!parts || parts.length &#x3D;&#x3D;&#x3D; 0) {
            return &quot;&quot;;
        }
        return parts[parts.length - 1];
    }

    protected static getAggregationNode(nodes: TreeAggregationNode[], path: string): TreeAggregationNode | undefined {
        if (!nodes || nodes.length &#x3D;&#x3D;&#x3D; 0) {
            return undefined;
        }
        const names &#x3D; FacetService.splitTreepath(path);
        let node: TreeAggregationNode | undefined;
        for (let _i &#x3D; 0, _a &#x3D; names; _i &lt; _a.length; _i++) {
            if (!nodes || nodes.length &#x3D;&#x3D;&#x3D; 0) {
                return undefined;
            }
            const name &#x3D; _a[_i].toLocaleLowerCase();
            node &#x3D; undefined;
            for (let _j &#x3D; 0, _b &#x3D; nodes; _j &lt; _b.length; _j++) {
                const _node &#x3D; _b[_j];
                if ((&lt;string&gt;_node.value).toLocaleLowerCase() &#x3D;&#x3D;&#x3D; name) {
                    node &#x3D; _node;
                    break;
                }
            }
            if (!node) {
                return undefined;
            }
            nodes &#x3D; node.items;
        }
        return node;
    }


    /**
     * Convert an Expression object or an Expression Array to their AggregationItem equivalent
     *
     * @param expr Expression object or Expression Array
     * @param valuesAreExpressions when true values should be converted to string otherwise no
     *
     * @returns AggregationItem array with converted expression or an empty array
     */
    exprToAggregationItem(expr: Expr[] | Expr, valuesAreExpressions: boolean &#x3D; false): AggregationItem[] {
        const fn &#x3D; [
            (item: Expr) &#x3D;&gt; {
                let value: FieldValue &#x3D; item.value as string;
                if (item.column?.eType &#x3D;&#x3D;&#x3D; EngineType.bool) {
                    value &#x3D; Utils.isTrue(item.value);
                }
                return ({count: 0, value, display: item.display, $column: item.column, $excluded: (item?.not || item?.parent?.not)} as AggregationItem);
            },
            (item: Expr) &#x3D;&gt; ({count: 0, value: item.toString((item.value) ? true : false), display: item.display, $column: item.column, $excluded: (item?.not || item?.parent?.not)} as AggregationItem)
        ];

        const callback &#x3D; valuesAreExpressions ? fn[1] : fn[0];
        return [].concat(expr as []).map(callback) as AggregationItem[];
    }

    /**
     * Get all Breadcrumbs items from a specific facet
     *
     * @param facetName facet name where to extract all breadcrumbs
     * @param breadcrumbs breadcrumbs in which to look for selected items
     */
    getBreadcrumbsItems(facetName: string, breadcrumbs: Breadcrumbs | undefined): BreadcrumbsItem[] {
        return breadcrumbs?.items.filter(item &#x3D;&gt; item.facet &#x3D;&#x3D;&#x3D; facetName) || [];
    }

    /**
     * Get all Aggregation items from a facet, currently filtered
     *
     * @param facetName facet name where to inspect
     * @param valuesAreExpressions when true, some transformations should be done
     * @param breadcrumbs breadcrumbs in which to look for selected items (default to search service breadcrumbs)
     */
    getAggregationItemsFiltered(facetName: string, valuesAreExpressions: boolean &#x3D; false, breadcrumbs &#x3D; this.searchService.breadcrumbs): AggregationItem[] {
        const items &#x3D; this.getBreadcrumbsItems(facetName, breadcrumbs);

        // aggregation items are constructed from nested expressions
        const expr &#x3D; [] as Expr[][];
        for (const item of items) {
            const value &#x3D; (item.expr?.display &#x3D;&#x3D;&#x3D; undefined) ? item.expr?.operands as Expr[] || item.expr : item.expr;
            if (value) {
                expr.push(value as Expr[]);
            }
        }
        // faltten results
        const flattenExpr &#x3D; [].concat.apply([], expr);

        return this.exprToAggregationItem(flattenExpr, valuesAreExpressions);
    }

    /**
     * Convert Suggestion to AggregationItem
     * @param suggest a Suggestion object
     *
     * @returns AggregationItem object with is &#x60;$column&#x60; property defined.
     * On boolean type, convert &#x60;value&#x60; property to boolean
     */
    suggestionToAggregationItem(suggest: Suggestion): AggregationItem {
        const item: AggregationItem &#x3D; {
            value: suggest.normalized || suggest.display,
            display: suggest.display,
            count: +(suggest.frequency || 0),
            $column: this.appService.getColumn(suggest.category)
        };
        if (item.$column?.eType &#x3D;&#x3D;&#x3D; EngineType.bool) {
            item.value &#x3D; Utils.isTrue(item.value);
        }
        return item;
    }

    /**
     * Converts a list of suggestions into a structure of TreeAggregationNodes
     * @param suggests Suggestions to convert
     * @param searchTerm The searched term in the suggestions
     * @param aggregation The tree aggregations
     */
    suggestionsToTreeAggregationNodes(suggests: Suggestion[], searchTerm: string, aggregation: Aggregation | undefined): TreeAggregationNode[] {
        const suggestions: TreeAggregationNode[] &#x3D; [];
        if(suggests.length &gt; 0) {
            const path2node &#x3D; new Map&lt;string,TreeAggregationNode&gt;();
            const searchPattern &#x3D; new RegExp(&#x60;\\b${searchTerm}&#x60;, &#x27;i&#x27;);
            const column &#x3D; this.appService.getColumn(aggregation?.column);
            suggests.forEach(suggest &#x3D;&gt; {
                if(suggest.display.length &gt; 1) {
                    const match &#x3D; searchPattern.exec(suggest.display);
                    this.addNode(suggestions, path2node, &quot;/&quot;, suggest.display, +(suggest.frequency || 0), 1, (match?.index || 0)+searchTerm.length, column);
                }
            });
        }
        return suggestions;
    }

    /**
     * Utility recursive function to generate a tree aggregation structure from
     * a list of suggestions
     */
    protected addNode(items: TreeAggregationNode[],
            path2node: Map&lt;string,TreeAggregationNode&gt;,
            parentPath: string,
            path: string,
            count: number,
            level: number,
            matchend: number,
            column: CCColumn | undefined) {

        const nextChild &#x3D; path.indexOf(&quot;/&quot;, parentPath.length); // path &#x3D; /Cities/Paris/17e/   parentPath &#x3D; /Cities/
        const currentPath &#x3D; path.substring(0, nextChild+1); // &#x3D;&gt; currentPath &#x3D; /Cities/Paris/
        let node &#x3D; path2node.get(currentPath);

        if(!node) {
            const value &#x3D; path.substring(parentPath.length, nextChild);
            node &#x3D; {
                value,
                count,
                items: [],
                hasChildren: false,
                $column: column,
                $level: level,
                $opened: matchend &gt;&#x3D; currentPath.length,
                $path: currentPath
            };
            path2node.set(currentPath, node);
            items.push(node);
        }

        if(currentPath.length &lt; path.length) {
            node.hasChildren &#x3D; true;
            this.addNode(node.items, path2node, currentPath, path, count, level+1, matchend, column);
        }
    }


    /**
     * Check if a facet contains items
     * @param aggregation aggregation name
     * @param results search results
     *
     * @returns true if the facet contains a least one item otherwise false
     */
    hasData(aggregation: string, results: Results): boolean {
        // Avoid calling getAggregation() which is costly
        return !!results.aggregations.find(agg &#x3D;&gt; Utils.eqNC(agg.name, aggregation))?.items?.length;
    }

    /**
     * Returns the index of the first element in the supplied array
     * corresponding to &#x60;item.value&#x60; or -1 when not found.
     * A fallback to &#x60;item.display&#x60; is done before returning -1
     * @param item item to find
     */
    filteredIndex(data: Aggregation | undefined, arr: Array&lt;AggregationItem&gt;, item: AggregationItem): number {
        let indx &#x3D; -1;
        // specific to Values Are Expressions where expression are not well formatted by Expression Parser
        // eg: when values is : &quot;&gt; 0&quot;, Expression Parser returns : &quot;&gt;0&quot; without space between operator and value
        if (data?.valuesAreExpressions) {
            const value &#x3D; this.trimAllWhitespace(item.value);
            const normalizedArr &#x3D; arr.map(item &#x3D;&gt; ({...item, value: this.trimAllWhitespace(item.value)})) || [];
            indx &#x3D; normalizedArr.findIndex(it &#x3D;&gt; it.value &#x3D;&#x3D;&#x3D; value);
        } else {
            indx &#x3D; this.findAggregationItemIndex(arr, item);
        }
        return indx;
    }

    /**
     * Utility function to returns aggregation item&#x27;s index in supplied array with fallback to &#x60;display&#x60; comparison.
     * Otherwise -1, indicating that no element passed the test.
     * @param arr The array findIndex() was called upon
     * @param value The value to be test
     */
    public findAggregationItemIndex &#x3D; (arr: Array&lt;AggregationItem&gt;, item: AggregationItem) &#x3D;&gt; {
        let index &#x3D; arr.findIndex(it &#x3D;&gt; it.value &#x3D;&#x3D;&#x3D; item.value);
        if (index &#x3D;&#x3D;&#x3D; -1 &amp;&amp; item.display) {
            // fallback to display comparison
            index &#x3D; arr.findIndex(it &#x3D;&gt; it.display &#x3D;&#x3D;&#x3D; item.display);
        }
        return index;
    };

    private trimAllWhitespace &#x3D; (value: FieldValue | undefined): FieldValue | undefined &#x3D;&gt; {
        switch (typeof value) {
            case &quot;string&quot;:
                return value.replace(/\s/g, &#x27;&#x27;);
            default:
                return value;
        }
    };
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'FacetChangeEvent.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
