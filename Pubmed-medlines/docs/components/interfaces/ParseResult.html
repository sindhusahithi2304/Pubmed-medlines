<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Components</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">Components</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>ParseResult</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>autocomplete/autocomplete-field-search.directive.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#error">error</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#result">result</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="error"></a>
                                        <span class="name"><b>error</b><a href="#error"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>error:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="result"></a>
                                        <span class="name"><b>result</b><a href="#result"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>result:     <code>Expr</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>Expr</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Directive, Input, Output, EventEmitter, SimpleChanges, ElementRef, OnChanges, OnDestroy } from &quot;@angular/core&quot;;
import { Observable, Subscription, of } from &quot;rxjs&quot;;
import { Utils, Keys} from &quot;@sinequa/core/base&quot;;
import { AppService, Expr, ExprBuilder, ExprParser, ExprValueInfo} from &quot;@sinequa/core/app-utils&quot;;
import { Autocomplete, AutocompleteItem, AutocompleteState } from &#x27;./autocomplete.directive&#x27;;
import { SuggestService } from &#x27;./suggest.service&#x27;;
import { UIService } from &#x27;@sinequa/components/utils&#x27;;

/**
 * Interface required to be implement by the component displaying
 * the fielded search items (basically the content of fieldSearchItems)
 */
export interface FieldSearchItemsContainer {

    /** Update the list of items displayed by the container */
    update(items: AutocompleteItem[]): void;

    /** Event triggered when the user removes an item from the container */
    itemRemoved: EventEmitter&lt;AutocompleteItem&gt;;
}

export interface ParseResult {
    result?: Expr;
    error?: string;
}

@Directive({
    selector: &quot;[sqAutocompleteFieldSearch]&quot;
})
export class AutocompleteFieldSearch extends Autocomplete implements OnChanges, OnDestroy {


    // FIELDED SEARCH

    /** 
     * &quot;text&quot; mode: fielded search is entirely managed as text in the &lt;input&gt; component 
     * &quot;selects&quot; mode: fielded search stores the selected autocomplete items to create selections, while keeping a clean &lt;input&gt; content (better UI/UX but does not support operators like OR, NOT, and parentheses)
     */
    @Input() fieldSearchMode: &quot;off&quot; | &quot;text&quot; | &quot;selects&quot; &#x3D; &quot;text&quot;;

    /** Fields excluded from fielded search (searched as regular strings if selected) */
    @Input() excludedFields: string[] &#x3D; [&quot;concepts&quot;];

    /* Fields included in fielded search (have precedence over excluded fields) */
    @Input() includedFields?: string[];

   /** Container displaying the fieldSearchItems (only needed if mode &#x3D;&#x3D;&#x3D; &quot;selects&quot;) */
    @Input() fieldSearchItemsContainer?: FieldSearchItemsContainer;

    /** Current selection expression needed to update the list of field search items if mode &#x3D;&#x3D;&#x3D; &quot;selects&quot; */
    @Input() fieldSearchExpression?: string;
 
    /** Stores the selected fielded search items selected via Tab */
    public readonly fieldSearchItems: AutocompleteItem[] &#x3D; [];


    // Event emitters

    @Output() parse &#x3D; new EventEmitter&lt;ParseResult&gt;();

    constructor(elementRef: ElementRef&lt;any&gt;, 
        suggestService: SuggestService,
        appService: AppService,
        uiService: UIService,
        protected exprBuilder: ExprBuilder){
        super(elementRef, suggestService, appService, uiService);
    }


    /**
     * If the off input changes state, react accordingly
     * @param changes
     */
    ngOnChanges(changes: SimpleChanges){
        super.ngOnChanges(changes);

        // Subscribe to the field search items&#x27;s container
        if(changes[&quot;fieldSearchItemsContainer&quot;] &amp;&amp; this.fieldSearchItemsContainer) {
            if(this._fieldSearchSubscription){
                this._fieldSearchSubscription.unsubscribe();
            }
            this._fieldSearchSubscription &#x3D; this.fieldSearchItemsContainer.itemRemoved.subscribe(item &#x3D;&gt; {
                this.fieldSearchItems.splice(this.fieldSearchItems.indexOf(item), 1);
                this.updatePlaceholder();
                this.submit.next();
            });
        }

        // Transform the field search expresion (Expr string) into a list of autocomplete items displayed in the field search container
        if(changes[&quot;fieldSearchExpression&quot;] &amp;&amp; this.fieldSearchMode &#x3D;&#x3D;&#x3D; &quot;selects&quot;) {
            if(this.fieldSearchExpression) {
                const expr &#x3D; this.appService.parseExpr(this.fieldSearchExpression);
                if(expr instanceof Expr &amp;&amp; this.fieldSearchItems.length !&#x3D;&#x3D; expr.getFields().length) {
                    this.fieldSearchItems.splice(0);
                    if(expr.and) {
                        expr.operands.forEach(e &#x3D;&gt; 
                            this.fieldSearchItems.push(this.exprToItem(e))
                        );
                    }
                    else {
                        this.fieldSearchItems.push(this.exprToItem(expr));
                    }
                }
            }
            else {
                this.fieldSearchItems.splice(0);
            }
        }

        // If fieldSearchMode changes from selects to something else, we must remove the field search items
        if(changes[&quot;fieldSearchMode&quot;] &amp;&amp; this.fieldSearchMode !&#x3D;&#x3D; &quot;selects&quot; &amp;&amp; this.fieldSearchItems.length &gt; 0) {
            this.fieldSearchItems.splice(0);
        }

        this.updatePlaceholder();
        this.fieldSearchItemsContainer?.update(this.fieldSearchItems);
    }


    private _fieldSearchSubscription: Subscription;
    /**
     * Unsubscribe when destroying the component
     */
    ngOnDestroy(){
        super.ngOnDestroy();
        if(this._fieldSearchSubscription){
            this._fieldSearchSubscription.unsubscribe();
        }
    }

    /**
     * Insert the given autocomplete item into the current search input
     * at the right location
     * @param item 
     */
    protected insertAutocompleteItem(item: AutocompleteItem): boolean {
        const value &#x3D; this.getInputValue(); // Current text in the input
        if(value) { // There should always be text
            const parseResult &#x3D; this.parseQuery(); // Parse the current text
            if(parseResult.result) { // (if no result, a parsing error occurred)
                const res &#x3D; parseResult.result.findValue(this.getInputPosition()); // Get the expression at the caret location
                // Autocomplete &quot;compa&quot; &#x3D;&gt; &quot;company:&quot;
                if(res &amp;&amp; item.category &#x3D;&#x3D;&#x3D; &quot;$field$&quot;) {
                    this.replaceValueInForm(res, item.display + &quot;: &quot;);
                    return false;
                }
                // Autocomplete &quot;company:Goo&quot; &#x3D;&gt; &quot;company:&#x60;GOOGLE&#x60;&quot;
                if(res &amp;&amp; res.field &#x3D;&#x3D;&#x3D; item.category) {
                    this.replaceValueInForm(res, ExprParser.escape(item.normalized || item.display));
                    return true;
                }
                // Autocomplete &quot;Goo&quot; &#x3D;&gt; &quot;company:&#x60;GOOGLE&#x60;&quot;
                if(res &amp;&amp; !res.field &amp;&amp; item.category &amp;&amp; 
                    (this.includedFields &amp;&amp; this.includedFields?.includes(item.category) || 
                    (!this.includedFields &amp;&amp; !this.excludedFields?.includes(item.category)))) { // Filter out fields if not in fieldSearch mode
                    this.replaceValueInForm(res, this.exprBuilder.makeExpr(item.category, item.normalized || item.display));
                    return true;
                }
                // Autocomplete &quot;Search eng&quot; &#x3D;&gt; &quot;Search engine&quot;
                if(res &amp;&amp; !res.field) {
                    this.replaceValueInForm(res, item.display);
                    return true;
                }
                // Remaining edge case ?
                console.error(item, parseResult.result);
            }
        }

        console.error(&quot;Shouldn&#x27;t be here: an autocomplete item is selected, but there is no text or a parse error!&quot;);
        // Default to just overriding the current value (a complex query with multiple items might become reduced to this single item!)
        if(item.category &#x3D;&#x3D;&#x3D; &quot;$field$&quot;) {
            this.setInputValue(item.display + &quot;:&quot;);
            return false;
        }
        this.setInputValue(this.exprBuilder.makeExpr(item.category, item.normalized || item.display)); // person: &#x60;Bill Gates&#x60;
        return true;
    }

    /**
     * Replaces the piece of expression (res) with a new value
     * in the input form
     * @param res The piece of expression parsed from the input content
     * @param value The new value
     */
    protected replaceValueInForm(res: ExprValueInfo, value: string) {
        this.uiService.setCaret(this.inputElement, res.start, res.start+res.length, value);
    }

    /**
     * Sets the content of the &lt;input&gt; based on the given
     * Autocomplete Item (various implementations are possible,
     * depending on the item content and nature).
     * This would be the right method to override to implement
     * fielded search autocomplete.
     * @returns true if this autocomplete item should be searched
     */
    protected setAutocompleteItem(item: AutocompleteItem): boolean {
        if(item) {
            if(this.fieldSearchMode &#x3D;&#x3D;&#x3D; &quot;text&quot;) {
                return this.insertAutocompleteItem(item);
            }

            else if(this.fieldSearchMode &#x3D;&#x3D;&#x3D; &quot;selects&quot; &amp;&amp; item.category &amp;&amp; 
                (this.includedFields &amp;&amp; this.includedFields?.includes(item.category) || 
                (!this.includedFields &amp;&amp; !this.excludedFields?.includes(item.category)))) { // Filter out fields if not in fieldSearch mode
                // In the case of of a field name, we display the field for autocomplete, but we don&#x27;t want to search for it
                if(item.category &#x3D;&#x3D;&#x3D; &quot;$field$&quot;) {
                    this.setInputValue(item.display + &quot;:&quot;);
                    return false;
                }
                // Store the autocomplete item that will be used to create a selection
                this.setInputValue(&quot;&quot;);
                this.fieldSearchItems.push(item);
                this.updatePlaceholder();
                this.fieldSearchItemsContainer?.update(this.fieldSearchItems);
                return true;
            }

            else {
                this.setInputValue(item.display);
                return true;
            }
        }
        return false;
    }

    /**
     * Returns an expression (Expr) for the fielded search items
     */
    public getFieldSearchExpression(): string | undefined {
        return this.itemsToExpr(this.fieldSearchItems);
    }

    /**
     * Transforms a list of AutocompleteItems into an expression
     * @param items list of AutocompleteItems
     */
    protected itemsToExpr(items: AutocompleteItem[]): string | undefined {
        if(items.length &gt; 0) {
            return this.exprBuilder.concatAndExpr(items.map(item &#x3D;&gt; 
                this.exprBuilder.makeExpr(item.category, item.normalized || item.display, item.display)));
        }
        return undefined;
    }

    /**
     * Transforms an expression into a list of AutocompleteItems
     * @param expr an expression
     */
    protected exprToItem(expr: Expr): AutocompleteItem {
        return {
            category: expr.field!,
            display: expr.display!,
            normalized: expr.value!,
        }
    }

    /**
     * Takes the text from the &lt;input&gt; element and parse it to
     * determine what type of suggestion to request from the server.
     * The suggestions are then fetched by getSuggestsObs() and processed
     * by processSuggests().
     */
    protected getSuggests() {
        let value &#x3D; this.getInputValue();
        if(value) { // If there is text, make a call to the suggest API
            const parseResult &#x3D; this.parseQuery(); // If using fieldSearch, the result can be used to detect an active field
            let fields: string[] | undefined;
            if(parseResult.result &amp;&amp; this.fieldSearchMode !&#x3D;&#x3D; &quot;off&quot;){
                const position &#x3D; this.getInputPosition(); // Position of the caret, if needed
                const res &#x3D; parseResult.result.findValue(position);
                // Field Search suggest
                if(!!res &amp;&amp; !!res.field){
                    fields &#x3D; Utils.startsWith(res.field, &quot;@&quot;) ? [&quot;text&quot;] : [res.field];
                    value &#x3D; res.value;
                }
                if(!!res &amp;&amp; this.fieldSearchMode &#x3D;&#x3D;&#x3D; &quot;text&quot;) {
                    value &#x3D; res.value;
                }
            }

            if(parseResult.error &amp;&amp; this.fieldSearchMode !&#x3D;&#x3D; &quot;off&quot;) {
                this.processSuggests(of([])); // Empty autocomplete if parsing errors
                return;
            }

            this.processSuggests(
                this.getSuggestsObs(value, fields)
            );

        }
        else {  // If empty input, restart autocomplete
            this.parse.next({}); // remove error messages if any
            this.start();
        }
    }

    /**
     * Process suggestions obtained (from whatever mean):
     * - If data available, filter out fields
     * - update the dropdown content
     * - Switch between OPEN and ACTIVE states
     * - Use changeDetectorRef to update display
     * @param obs an observable of AutocompleteItem suggestions
     */
    protected processSuggests(obs: Observable&lt;AutocompleteItem[]&gt;){
        obs.subscribe(
            suggests &#x3D;&gt; {
                if(this.getState() &#x3D;&#x3D;&#x3D; AutocompleteState.ACTIVE || this.getState() &#x3D;&#x3D;&#x3D; AutocompleteState.OPENED){
                    this.dropdown.update(true, suggests
                        .filter(item &#x3D;&gt; item.category !&#x3D;&#x3D; &quot;$field$&quot; || (this.fieldSearchMode !&#x3D;&#x3D; &quot;off&quot; &amp;&amp; 
                            (this.includedFields &amp;&amp; this.includedFields?.includes(item.display) || 
                            (!this.includedFields &amp;&amp; !this.excludedFields?.includes(item.display)))))  // Filter out fields if not in fieldSearch mode
                        .map(item &#x3D;&gt; {
                            if(!item.label){
                                if(item.category &#x3D;&#x3D;&#x3D; &quot;$field$&quot;) {
                                    item.label &#x3D; &quot;Field&quot;;
                                }
                                else {
                                    item.label &#x3D; this.appService.getLabel(item.category);
                                }
                            }
                            return item;
                        }));
                }
            },
            err &#x3D;&gt; {
                this.dropdown.update(false);
            },
            () &#x3D;&gt; {
                if(this.dropdown.hasItems &amp;&amp; this.getState() &#x3D;&#x3D;&#x3D; AutocompleteState.ACTIVE){
                    this.open();    // Switch from ACTIVE to OPENED (if not already)
                }
                else if(!this.dropdown.hasItems &amp;&amp; this.getState() &#x3D;&#x3D;&#x3D; AutocompleteState.OPENED){   // No data
                    this.active();  // Switch from OPENED to ACTIVE (if not already)
                }
            });
    }

    /**
     * Parse the query for syntax errors (also allows to detect field search if needed).
     * Fires a parse event.
     */
    protected parseQuery() : ParseResult {
        const value &#x3D; this.getInputValue();
        const result &#x3D; this.appService.parseExpr(value, {allowEmptyValues: true});
        const event &#x3D; result instanceof Expr? { result: result } : { error: result };
        this.parse.next(event);
        return event;
    }


    /**
     * Listen to user&#x27;s keyboard actions in the &lt;input&gt;, in order to navigate
     * and select the autocomplete suggestions.
     * Overrides the parent keydown method, adds the management of the backspace key
     * to remove field search items.
     * @param event the keyboard
     */
    keydown(event: KeyboardEvent) {

        const keydown &#x3D; super.keydown(event);

        if(keydown &#x3D;&#x3D;&#x3D; undefined) {
            // In fielded search mode, we can remove selections by typing &lt;backspace&gt; when the input is empty
            if(event.keyCode &#x3D;&#x3D;&#x3D; Keys.backspace) {
                if(this.fieldSearchMode &#x3D;&#x3D;&#x3D; &quot;selects&quot; &amp;&amp; this.getInputValue() &#x3D;&#x3D;&#x3D; &#x27;&#x27;) {
                    this.fieldSearchItems.pop();
                    this.updatePlaceholder();
                    this.fieldSearchItemsContainer?.update(this.fieldSearchItems);
                }
            }    
        }
        
        return keydown;
    }

    /**
     * Updates the &lt;input&gt;&#x27;s placeholder to avoid displaying something
     * when there are fieldSearchItems displayed to the left.
     */
    updatePlaceholder() {
        this._placeholder &#x3D; this.fieldSearchItems.length &gt; 0 ? &#x27;&#x27; : this.placeholder;
    }
}</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ParseResult.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
