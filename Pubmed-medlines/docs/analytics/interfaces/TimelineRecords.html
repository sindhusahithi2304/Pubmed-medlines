<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Analytics</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">Analytics</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>TimelineRecords</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>timeline/bootstrap/facet-timeline.component.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#display">display</a>
                                </li>
                                <li>
                                        <a href="#field">field</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#size">size</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#styles">styles</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="display"></a>
                                        <span class="name"><b>display</b><a href="#display"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>display:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/function" target="_blank" >function</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/function" target="_blank" >function</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="field"></a>
                                        <span class="name"><b>field</b><a href="#field"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>field:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="size"></a>
                                        <span class="name"><b>size</b><a href="#size"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>size:     <code>number | </code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>number | </code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="styles"></a>
                                        <span class="name"><b>styles</b><a href="#styles"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>styles:     <code>literal type | </code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type | </code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, Input, OnChanges, ChangeDetectorRef, SimpleChanges, Output, EventEmitter } from &#x27;@angular/core&#x27;;
import { Observable, of, combineLatest, ReplaySubject } from &#x27;rxjs&#x27;;
import { map } from &#x27;rxjs/operators&#x27;;
import { Results, AggregationItem, Aggregation, CCAggregation, Record, AuditWebService, AuditEventType } from &#x27;@sinequa/core/web-services&#x27;;
import { AppService, Expr, ExprBuilder } from &#x27;@sinequa/core/app-utils&#x27;;
import { Utils } from &#x27;@sinequa/core/base&#x27;;
import { AbstractFacet, FacetService } from &#x27;@sinequa/components/facet&#x27;;
import { SearchService } from &#x27;@sinequa/components/search&#x27;;
import { SelectionService } from &#x27;@sinequa/components/selection&#x27;;
import { Action } from &#x27;@sinequa/components/action&#x27;;
import { TimelineSeries, TimelineDate, TimelineEvent } from &#x27;./timeline.component&#x27;;
import moment from &#x27;moment&#x27;;
import * as d3 from &#x27;d3&#x27;;
import { TimelineEventType } from &#x27;./timeline-legend.component&#x27;;

export interface TimelineAggregation {
    name?: string;
    aggregation: string;
    primary: boolean;
    areaStyles?: {[key: string]: any};
    lineStyles?: {[key: string]: any};
}

export interface TimelineCombinedAggregations {
    aggregations: TimelineAggregation[];
    maxNMonths: number[]; // Maximum number of months for which to use this aggregation
    default: TimelineAggregation; // Aggregation to use by default 
    current?: TimelineAggregation; // (this field is overriden by the component when switching aggregation)
}

export interface TimelineRecords {
    field: string;
    size?: number | ((record: Record, selected: boolean) &#x3D;&gt; number);
    styles?: {[key: string]: any} | ((record: Record, selected: boolean) &#x3D;&gt; {[key: string]: any});
    display?: (record: Record) &#x3D;&gt; string;
}

export interface TimelineEventAggregation {
    aggregation: string;
    getDate: ((item: AggregationItem) &#x3D;&gt; Date);
    getDisplay: ((item: AggregationItem) &#x3D;&gt; string);
    size?: number | ((item: AggregationItem) &#x3D;&gt; number);
    styles?: {[key: string]: any} | ((item: AggregationItem) &#x3D;&gt; {[key: string]: any});
}

export type TimelineData &#x3D; TimelineSeries | TimelineAggregation | TimelineCombinedAggregations;

export type TimelineEventData &#x3D; TimelineEvent[] | TimelineRecords | TimelineEventAggregation;

@Component({
    selector: &#x27;sq-facet-timeline&#x27;,
    templateUrl: &#x27;./facet-timeline.component.html&#x27;,
    styleUrls: [&#x27;./facet-timeline.component.scss&#x27;]
})
export class BsFacetTimelineComponent extends AbstractFacet implements OnChanges {
    @Input() name &#x3D; &#x27;Timeline&#x27;;
    @Input() results: Results;
    
    // By default, we show the standard Timeline aggregation and the list of current records
    @Input() timeseries: TimelineData[] &#x3D; [{aggregation: &#x27;Timeline&#x27;, primary: true}];
    @Input() events: TimelineEventData[] &#x3D; [{field: &#x27;modified&#x27;}];

    // Initial scale (prior to any zoom)
    @Input() minDate?: Date;
    @Input() maxDate?: Date;
    // Date range to filter aggregations (ignored when combined aggregations are recomputed based on zoomed range)
    @Input() minAggregationDate?: Date;
    @Input() maxAggregationDate?: Date;
    
    @Input() zoomable &#x3D; true;
    @Input() minZoomDays &#x3D; 1; // Max 1 day scale
    @Input() maxZoomDays &#x3D; 365 * 100; // Max 100 years scale

    @Input() width &#x3D; 600;
    @Input() height &#x3D; 200;
    @Input() margin &#x3D; {top: 15, bottom: 20, left: 40, right: 15};

    @Input() curveType &#x3D; &quot;curveMonotoneX&quot;;

    @Input() showTooltip &#x3D; true;
    @Input() theme: &quot;light&quot; | &quot;dark&quot; &#x3D; &quot;light&quot;;

    @Input() showLegend &#x3D; false;
    @Input() legendStyles?: {[key:string]: any} &#x3D; {&#x27;justify-content&#x27; : &#x27;center&#x27;};
    @Input() legendEvents?: TimelineEventType[];
    @Input() legendOrientation?: &quot;row&quot;|&quot;column&quot; &#x3D; &quot;row&quot;;
    @Input() legendYOffset?: number &#x3D; 3;

    @Output() eventClicked &#x3D; new EventEmitter&lt;TimelineEvent&gt;();

    // List of observables (one per timeseries / event type)
    timeseries$: ReplaySubject&lt;TimelineSeries&gt;[];
    events$: ReplaySubject&lt;TimelineEvent[]&gt;[];

    // Combination (combineLastest) of the timeline observables
    mergedTimeseries$: Observable&lt;TimelineSeries[]&gt;;
    mergedEvents$: Observable&lt;TimelineEvent[]&gt;;

    // Current timeline selection
    selection?: [Date, Date];

    // Current range (undefined if no zoom / auto-scaling)
    currentRange?: [Date, Date];

    // Formating method for search queries
    formatDayRequest &#x3D; d3.timeFormat(&quot;%Y-%m-%d&quot;);

    // Actions
    clearFilters: Action;

    constructor(
        public facetService: FacetService,
        public searchService: SearchService,
        public appService: AppService,
        public selectionService: SelectionService,
        public exprBuilder: ExprBuilder,
        public cdRef: ChangeDetectorRef,
        public audit: AuditWebService
    ){
        super();

        // Update the events when the selection of records changes
        this.selectionService.events.subscribe(event &#x3D;&gt; {
            const i &#x3D; this.events.findIndex(e &#x3D;&gt; (e as TimelineRecords).field);
            if(i !&#x3D;&#x3D; -1) {
                this.events$[i].next(this.getRecordsAsEvents(this.events[i] as TimelineRecords));
            }
        });
        
        // Clear the current filters
        this.clearFilters &#x3D; new Action({
            icon: &quot;far fa-minus-square&quot;,
            title: &quot;msg#facet.clearSelects&quot;,
            action: () &#x3D;&gt; {
                this.selection &#x3D; undefined;
                this.searchService.query.removeSelect(this.name);
                this.searchService.search();
            }
        });

    }

    getMinDate(): Date | undefined {
        return this.currentRange? this.currentRange[0] : this.minDate;
    }

    getMaxDate(): Date | undefined {
        return this.currentRange? this.currentRange[1] : this.maxDate;
    }

    get actions(): Action[] {
        const actions: Action[] &#x3D; [];
        if(this.facetService.hasFiltered(this.name)){
            actions.push(this.clearFilters);
        }
        return actions;
    }

    ngOnChanges(changes: SimpleChanges) {

        // Skip simple changes (width, height, etc.) that don&#x27;t require modifying the timeline data
        if(!changes.timeseries &amp;&amp; !changes.events &amp;&amp; !changes.results) {
            return;
        }

        // Retrieve the current active selection for this timeline (if any)
        const select &#x3D; this.searchService.query.findSelect(this.name);

        // Update the selection if it is not already set (which is the case on a page refresh)
        if(select &amp;&amp; !this.selection) {
            let parsedexpr &#x3D; this.appService.parseExpr(select.expression) as Expr;
            if(!Utils.isString(parsedexpr)){
                while(!parsedexpr.isLeaf){ // The select might over multiple fields (modified between [...] AND created between [...])
                    parsedexpr &#x3D; parsedexpr.operands[0];
                }
                if(parsedexpr.values){
                    this.selection &#x3D; [new Date(parsedexpr.values[0]), new Date(parsedexpr.values[1])];
                    // Guess a current range based on the selection
                    if(!this.currentRange) {
                        const interval &#x3D; this.selection[1].getTime() - this.selection[0].getTime();
                        this.currentRange &#x3D; [ // Selected Interval +10% on each side
                            new Date(this.selection[0].getTime()-interval*0.1),
                            new Date(this.selection[1].getTime()+interval*0.1)
                        ];
                    }
                }
            }
        }
        // If no active selection we remove the selection from the timeline, along with the current zoomed range
        else if(!select) {
            this.selection &#x3D; undefined; // If no select, it was possibly removed by the user, we need to update our selection
            this.currentRange &#x3D; undefined; // current range is set by zoom events, we want to reset it only if there are no select (ie. no user interaction)
        }

        // Initialize timeseries
        if(!this.timeseries$ || changes[&quot;timeseries&quot;]) {
            // Create one observable per timeline
            this.timeseries$ &#x3D; this.timeseries.map(_ &#x3D;&gt; new ReplaySubject&lt;TimelineSeries&gt;(1));
            this.mergedTimeseries$ &#x3D; combineLatest(this.timeseries$);
        }

        this.updateTimeseries();

        // Initialize events
        if(!this.events$ || changes[&quot;events&quot;]) {
            this.events$ &#x3D; this.events.map(_ &#x3D;&gt; new ReplaySubject&lt;TimelineEvent[]&gt;(1));
            this.mergedEvents$ &#x3D; combineLatest(this.events$).pipe(
                map(events &#x3D;&gt; ([] as TimelineEvent[]).concat(...events))
            );
        }

        this.updateEvents();
        
    }

    /**
     * For each timeseries configuration given as an input,
     * update the data via the list of observables (timelines$)
     */
    updateTimeseries() {
        this.timeseries.forEach((config, i) &#x3D;&gt; {

            const subject &#x3D; this.timeseries$[i];

            if((config as TimelineSeries).dates !&#x3D;&#x3D; undefined) {
                subject.next(config as TimelineSeries);
            }

            else {
                let agg &#x3D; config as TimelineAggregation;
                if(agg.aggregation &#x3D;&#x3D;&#x3D; undefined){
                    
                    config &#x3D; config as TimelineCombinedAggregations;
                    // We want to set the default scale if it hasn&#x27;t been set before
                    // or if no zoom/selection has been made (so current scale may not be adapted to the new results)
                    if(!this.currentRange || !config.current){
                        config.current &#x3D; config.default;
                    }

                    agg &#x3D; config.current;
                }
                
                const range: [Date, Date] | undefined &#x3D; !!this.minAggregationDate &amp;&amp; !!this.maxAggregationDate ?
                    [this.minAggregationDate, this.maxAggregationDate] : undefined;

                this.getTimeseries(agg, range).subscribe({
                    next: d &#x3D;&gt; subject.next(d),
                    error: err &#x3D;&gt; subject.error(err)
                });
            }

        });
    }

    /**
     * For each event configuration given as an input, 
     * update the data via the list of observables (events$)
     */
    updateEvents() {
        this.events.forEach((config, i) &#x3D;&gt; {
            const subject &#x3D; this.events$[i];

            if((config as TimelineRecords).field) {
                subject.next(this.getRecordsAsEvents(config as TimelineRecords));
            }
            else if((config as TimelineEventAggregation).aggregation){
                this.getEventAggregation(config as TimelineEventAggregation).subscribe({
                    next: t &#x3D;&gt; subject.next(t),
                    error: err &#x3D;&gt; subject.error(err)
                });
            }
            else if(Array.isArray(config)){
                subject.next(config as TimelineEvent[]);
            }
        });
    }

    /**
     * Get a timeseries aggregation via the getAggregation method.
     * @param config 
     * @param subject 
     * @param range 
     */
    getTimeseries(config: TimelineAggregation, range?: [Date, Date]): Observable&lt;TimelineSeries&gt; {
        return this.getAggregation(config.aggregation, range).pipe(
            map(d &#x3D;&gt; BsFacetTimelineComponent.createTimeseries(config, d.aggregation, d.ccaggregation, range))
        );
    }

    /**
     * Get an aggregation of events via the getAggregation method
     * @param config 
     * @param subject 
     */
    getEventAggregation(config: TimelineEventAggregation): Observable&lt;TimelineEvent[]&gt; {
        return this.getAggregation(config.aggregation).pipe(
            map(d &#x3D;&gt; BsFacetTimelineComponent.createAggregationEvents(config, d.aggregation, d.ccaggregation))
        );
    }

    /**
     * Returns the list of records from the results as a list of TimelineEvent when they have a
     * modified date. The size and styles of the events are determined from the given configuration (TimelineRecords)
     * @param config 
     */
    getRecordsAsEvents(config: TimelineRecords): TimelineEvent[] {
        if(this.results) {
            return this.results.records
                .filter(r &#x3D;&gt; !!Utils.toDate(r[config.field]))
                .map&lt;TimelineEvent&gt;(r &#x3D;&gt; {
                    return {
                        id: r.id,
                        date: Utils.toDate(r[config.field])!,
                        size: !config.size? 6 : typeof config.size &#x3D;&#x3D;&#x3D; &#x27;function&#x27;? config.size(r, r.$selected) : config.size,
                        styles: !config.styles? BsFacetTimelineComponent.defaultRecordStyle(r.$selected) :
                                typeof config.styles &#x3D;&#x3D;&#x3D; &#x27;function&#x27;? config.styles(r, r.$selected) : 
                                config.styles,
                        display: config.display? config.display(r) : r.title,
                        // Custom property for click action
                        record: r
                    }
                });
        }
        return [];
    }


    /**
     * returns an aggregation and its configuration either directly from the facet service of
     * by fetching it from the server.
     * @param aggregationName 
     * @param range 
     */
    getAggregation(aggregationName: string, range?: [Date, Date]): Observable&lt;{aggregation: Aggregation, ccaggregation: CCAggregation}&gt; {
        
        const ccaggregation &#x3D; this.appService.getCCAggregation(aggregationName);
        const aggregation &#x3D; this.facetService.getAggregation(aggregationName, this.results);
        
        if(aggregation &amp;&amp; ccaggregation) {
            return of({aggregation: aggregation, ccaggregation: ccaggregation});
        }

        else if(ccaggregation) {
            return this.fetchAggregation(aggregationName, ccaggregation, range).pipe(
                map(agg &#x3D;&gt; {return {aggregation: agg, ccaggregation: ccaggregation} })
            );
        }

        else {
            throw new Error(&#x60;Aggregation ${aggregationName} does not exist in the Query web service&#x60;);
        }
    }

    /**
     * Get an aggregation from the server, filtering by range if provided
     * @param aggregation 
     * @param ccaggregation 
     * @param range 
     */
    fetchAggregation(aggregation: string, ccaggregation: CCAggregation, range?: [Date, Date]): Observable&lt;Aggregation&gt; {
        const query &#x3D; Utils.copy(this.searchService.query);
        query.action &#x3D; &quot;aggregate&quot;;
        query.aggregations &#x3D; [aggregation];

        if(range){
            query.addSelect(&#x60;${ccaggregation.column}:[${this.formatDayRequest(range[0])}..${this.formatDayRequest(range[1])}]&#x60;);
        }

        return this.searchService.getResults(query, undefined, {searchInactive: true}).pipe(
            map(results &#x3D;&gt; results.aggregations[0])
        );
    }

    /**
     * Given a combined aggregation configuration and a range, this method searches for the most 
     * adapted aggregation scale (years, months, weeks or days) and updates the data if necessary.
     * @param config 
     * @param range 
     * @param iTimeseries 
     */
    updateCombinedAggregation(config: TimelineCombinedAggregations, range: [Date, Date], timeseries$: ReplaySubject&lt;TimelineSeries&gt;) {
        const nmonths &#x3D; d3.timeMonth.count(range[0], range[1]);

        if(!config.maxNMonths || config.maxNMonths.length !&#x3D;&#x3D; config.aggregations.length) {
            console.error(config);
            throw new Error(&quot;maxNMonths and aggregations must have the same number of items&quot;);
        }

        // Find the aggregation with min maxNMonths with maxNMonths &gt;&#x3D; nmonths
        let jMin;
        config.maxNMonths.forEach((maxNMonths, j) &#x3D;&gt; {
            if(maxNMonths &gt;&#x3D; nmonths &amp;&amp; (jMin &#x3D;&#x3D;&#x3D; undefined || maxNMonths &lt; config.maxNMonths[jMin] || config.maxNMonths[jMin] &#x3D;&#x3D;&#x3D; -1) 
                || maxNMonths &#x3D;&#x3D;&#x3D; -1 &amp;&amp; jMin &#x3D;&#x3D;&#x3D; undefined){
                jMin &#x3D; j;
            }
        });

        const bestAggregation &#x3D; config.aggregations[jMin];

        if(bestAggregation !&#x3D;&#x3D; config.current 
            || this.currentRange &amp;&amp; (range[0] &lt; this.currentRange[0] || range[1] &gt; this.currentRange[1])) {

            config.current &#x3D; bestAggregation;
            this.getTimeseries(bestAggregation, range).subscribe({
                next: d &#x3D;&gt; timeseries$.next(d),
                error: err &#x3D;&gt; timeseries$.error(err)
            });
        }

    }


    // Interaction callbacks

    /**
     * On selection is triggered when the user selects a range of dates on the timeline.
     * This has the effect of updating the query.select (either remove it or add/replace it)
     * and it updates the search.
     * @param selection 
     */
    onSelectionChange(selection: [Date, Date] | undefined) {
        this.selection &#x3D; selection;
        if(selection) {
            const from &#x3D; this.formatDayRequest(selection[0]);
            const to &#x3D; this.formatDayRequest(selection[1]);

            const exprs: string[] &#x3D; [];
            this.searchService.query.removeSelect(this.name);

            this.timeseries.forEach((config) &#x3D;&gt; {
                    
                if((config as TimelineAggregation).aggregation !&#x3D;&#x3D; undefined 
                || (config as TimelineCombinedAggregations).default !&#x3D;&#x3D; undefined) {

                    const aggregation &#x3D; (config as TimelineAggregation).aggregation || (config as TimelineCombinedAggregations).default.aggregation;
                    const ccaggregation &#x3D; this.appService.getCCAggregation(aggregation);
                    if(ccaggregation) {
                        exprs.push(this.exprBuilder.makeRangeExpr(ccaggregation.column, from, to));
                    }
                }

            });

            if(exprs.length &gt; 0) {
                const expr &#x3D; this.exprBuilder.concatOrExpr(exprs);
                this.searchService.query.addSelect(expr, this.name);
                this.searchService.search(undefined, {type:AuditEventType.Search_Timeline_Usage, detail: { from, to }});
            }            
        }

        else if(this.searchService.query.findSelect(this.name)) {
            this.searchService.query.removeSelect(this.name);
            this.searchService.search();
        }
    }

    /**
     * On range is triggered when the user zooms in our out on the timeline,
     * which triggers a dynamic update of the combined aggregation timelines.
     * @param range 
     */
    onRangeChange(range: [Date, Date]) {

        this.timeseries.forEach((config, i) &#x3D;&gt; {
            if((config as TimelineCombinedAggregations).aggregations !&#x3D;&#x3D; undefined) {
                this.updateCombinedAggregation(config as TimelineCombinedAggregations, range, this.timeseries$[i]);
            }
        });

        // Note: updateCombinedAggregation() compares currentRange and range
        // So this update must be kept after the forEach
        this.currentRange &#x3D; range;
    }

    /**
     * When an event is clicked, the event is propagated to the parent, and the tooltip is closed
     * @param event 
     * @param closeTooltip 
     */
    onEventClicked(event: TimelineEvent, closeTooltip: () &#x3D;&gt; void) {
        this.eventClicked.next(event);
        closeTooltip();
        return false;
    }


    // Static utility methods
    
    
    /**
     * Create a time series object from its config, data (aggregation) and configuration (ccaggregation)
     * @param config 
     * @param aggregation 
     * @param ccaggregation 
     */
    static createTimeseries(config: TimelineAggregation, aggregation: Aggregation, ccaggregation: CCAggregation, range?: [Date, Date]): TimelineSeries {
        return {
            name: config.name || aggregation.name,
            primary: config.primary,
            dates: this.createDatapoints(aggregation.items, ccaggregation?.mask, range),
            lineStyles: config.lineStyles,
            areaStyles: config.areaStyles
        }
    }

    /**
     * Create a list of events from its config, data (aggregation) and configuration (ccaggregation)
     * @param config 
     * @param aggregation 
     * @param ccaggregation 
     */
    static createAggregationEvents(config: TimelineEventAggregation, aggregation: Aggregation, ccaggregation: CCAggregation): TimelineEvent[] {
        return !aggregation.items? [] : aggregation.items.map(item &#x3D;&gt; {
            return {
                id: config.getDate(item).toUTCString()+&quot;|&quot;+config.getDisplay(item),
                date: config.getDate(item),
                size: !config.size? 6 : typeof config.size &#x3D;&#x3D;&#x3D; &#x27;function&#x27;? config.size(item) : config.size,
                styles: !config.styles? undefined :
                        typeof config.styles &#x3D;&#x3D;&#x3D; &#x27;function&#x27;? config.styles(item) : 
                        config.styles,                
                display: config.getDisplay(item),

                // Custom params for click action
                item: item,
                aggregation: aggregation,
                ccaggregation: ccaggregation
            }
        });
    }

    /**
     * This methods transforms a raw list of aggregation items into
     * a time series completed with zeros, following the below scheme:
     * Aggregation:  [    # #         # # #   #     # #       # # #    ]
     * Series:       [  0 # # 0     0 # # # 0 # 0 0 # # 0   0 # # # 0  ]
     * @param items 
     * @param resolution 
     */
    static createDatapoints(items: AggregationItem[] | undefined, resolution: string, range?: [Date, Date]): TimelineDate[] {

        if(!items) {
            return [];
        }

        const timeInterval &#x3D; this.getD3TimeInterval(resolution);
        
        const series: TimelineDate[] &#x3D; [];

        const _items &#x3D; items
            .map(item &#x3D;&gt; {
                if(!!item.value &amp;&amp; !(item.value instanceof Date)){
                    const val &#x3D; item.value.toString();
                    item.value &#x3D; moment(val.length &lt;&#x3D; 4? val + &quot;-01&quot; : val).toDate();
                    if(isNaN(item.value.getTime())){
                        item.value &#x3D; &lt;Date&gt;&lt;unknown&gt; undefined; // So it gets filtered out
                    }
                }
                return item;
            })
            .filter(item &#x3D;&gt; !!item.value &amp;&amp; (!range || ((item.value as Date) &gt;&#x3D; range[0] &amp;&amp; (item.value as Date) &lt;&#x3D; range[1])));

        _items.forEach((item,i) &#x3D;&gt; {
            const date &#x3D; item.value as Date;
            
            if(i &#x3D;&#x3D;&#x3D; 0 || timeInterval.offset(series[series.length-1].date, 1) &lt; date) {
                series.push({date: timeInterval.offset(date, -1), value: 0});
            }

            series.push({date: date, value: item.count});

            if(i &#x3D;&#x3D;&#x3D; _items.length-1 || timeInterval.offset(date, 1) &lt; _items[i+1].value){
                series.push({date: timeInterval.offset(date, 1), value: 0});                    
            }
        });

        series.forEach(item &#x3D;&gt; item.date &#x3D; this.shiftDate(item.date, resolution));

        return series;
    }

    
    /**
     * Shift the date to the middle of their time bracket (2020 &#x3D; middle of the year, April &#x3D; middle of the month, etc.)
     * @param date 
     * @param resolution 
     */
    static shiftDate(date: Date, resolution: string): Date {
        switch(resolution){
            case &quot;YYYY-MM-DD&quot;: return d3.timeHour.offset(date, 12);
            case &quot;YYYY-WW&quot;: return d3.timeHour.offset(date, 84); // 3*24 + 12
            case &quot;YYYY-MM&quot;: return d3.timeDay.offset(date, 15);
            case &quot;YYYY&quot;: return d3.timeMonth.offset(date, 6);
        }
        return date;
    }


    static getD3TimeInterval(resolution: string): d3.CountableTimeInterval {
        switch(resolution){
            case &quot;YYYY-MM-DD&quot;: return d3.timeDay;
            case &quot;YYYY-WW&quot;: return d3.timeWeek;
            case &quot;YYYY-MM&quot;: return d3.timeMonth;
            case &quot;YYYY&quot;: return d3.timeYear;
        }
        return d3.timeDay;
    }

    static defaultRecordStyle(selected: boolean): {[key: string]: any} {
        return {
            &#x27;fill&#x27;: selected? &#x27;red&#x27; : &#x27;green&#x27;,
            &#x27;stroke&#x27;: selected? &#x27;red&#x27; : undefined,
            &#x27;stroke-width&#x27;: selected? &#x27;2px&#x27; : undefined
        };
    }
}</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'TimelineRecords.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
