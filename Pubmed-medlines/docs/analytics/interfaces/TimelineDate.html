<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Analytics</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">Analytics</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>TimelineDate</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>timeline/bootstrap/timeline.component.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#date">date</a>
                                </li>
                                <li>
                                        <a href="#value">value</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="date"></a>
                                        <span class="name"><b>date</b><a href="#date"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>date:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" >Date</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" >Date</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="value"></a>
                                        <span class="name"><b>value</b><a href="#value"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>value:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, Input, Output, ElementRef, ViewChild, OnChanges, AfterViewInit, EventEmitter, SimpleChanges, OnDestroy, SimpleChange, ContentChild, TemplateRef, ChangeDetectorRef } from &#x27;@angular/core&#x27;;
import { Subscription } from &#x27;rxjs&#x27;;
import * as d3 from &#x27;d3&#x27;;

import { IntlService } from &#x27;@sinequa/core/intl&#x27;;
import {Record} from &#x27;@sinequa/core/web-services&#x27;;


export interface TimelineDate {
    date: Date;
    value: number;
}

export interface TimelineSeries {
    name: string;
    dates: TimelineDate[];
    primary: boolean;
    lineStyles?: {[key:string]: any};
    areaStyles?:  {[key:string]: any};
}

export interface TimelineEvent {
    date: Date;
    id: string;
    display: string;
    size?: number;
    sizeOpened?: number;
    styles?: {[key:string]: any};
    record?: Record;
}

@Component({
    selector: &#x27;sq-timeline&#x27;,
    templateUrl: &#x27;./timeline.component.html&#x27;,
    styleUrls: [&#x27;./timeline.component.scss&#x27;]
})
export class BsTimelineComponent implements OnChanges, AfterViewInit, OnDestroy {

    @Input() data?: TimelineSeries[];
    @Input() events?: TimelineEvent[];

    @Input() selection?: [Date, Date];

    // Initial scale (prior to any zoom)
    @Input() minDate?: Date;
    @Input() maxDate?: Date;

    @Input() zoomable &#x3D; true;
    @Input() minZoomDays &#x3D; 1; // Max 1 day scale
    @Input() maxZoomDays &#x3D; 365 * 100; // Max 100 years scale

    @Input() width &#x3D; 600;
    @Input() height &#x3D; 200;
    @Input() margin &#x3D; {top: 15, bottom: 20, left: 40, right: 15};

    @Input() curveType &#x3D; &quot;curveMonotoneX&quot;;

    @Input() showTooltip &#x3D; true;
    @Input() theme: &quot;light&quot; | &quot;dark&quot; &#x3D; &quot;light&quot;;

    @Output() selectionChange &#x3D; new EventEmitter&lt;Date[]&gt;();
    @Output() rangeInit &#x3D; new EventEmitter&lt;Date[]&gt;();
    @Output() rangeChange &#x3D; new EventEmitter&lt;Date[]&gt;();

    @ContentChild(&quot;tooltipTpl&quot;, {static: false}) tooltipTpl: TemplateRef&lt;any&gt;;

    // Data
    groupedEvents: TimelineEvent[][] &#x3D; [];

    // Scales
    x: d3.ScaleTime&lt;number, number&gt;; // Read/Write
    xt: d3.ScaleTime&lt;number, number&gt;; // Transformed X axis due to Zoom
    y: d3.ScaleLinear&lt;number, number&gt;; // Read-only / domain updated

    // Shapes
    area: d3.Area&lt;TimelineDate&gt;; // Read only
    line: d3.Line&lt;TimelineDate&gt;; // Read only

    // Behaviors
    brushBehavior: d3.BrushBehavior&lt;any&gt;; // Read only
    zoomBehavior: d3.ZoomBehavior&lt;any,any&gt;; // Read/Write
    brushSelection: [number, number] | null;
    currentSelection?: Date[]; // Read/Write

    // Elements
    @ViewChild(&quot;xAxis&quot;) gx: ElementRef;
    @ViewChild(&quot;yAxis&quot;) gy: ElementRef;
    @ViewChild(&quot;brush&quot;) gbrush: ElementRef;
    
    // Selections
    xAxis$: d3.Selection&lt;SVGGElement, Date, null, undefined&gt;;
    yAxis$: d3.Selection&lt;SVGGElement, number, null, undefined&gt;;
    brush$: d3.Selection&lt;SVGGElement, undefined, null, undefined&gt;;
    grips$: d3.Selection&lt;SVGGElement, {type: string}, SVGGElement, undefined&gt;;
        
    // Tooltip
    tooltipItem: TimelineEvent[] | undefined;
    tooltipX: number | undefined;
    tooltipOrientation: &quot;left&quot; | &quot;right&quot;;
    tooltipTop: number;
    tooltipRight: number;
    tooltipLeft: number;

    // Misc
    viewInit: boolean;
    intlSubscription: Subscription;
    static counter &#x3D; 0;
    instance: number;
    
    zooming: boolean;
    brushing: boolean;

    constructor(
        protected el: ElementRef,
        protected intlService: IntlService,
        protected cdRef: ChangeDetectorRef
    ){
        // When the locale changes, we rebuild the X scale and axis
        this.intlSubscription &#x3D; this.intlService.events.subscribe(e &#x3D;&gt; this.updateXAxis());
        
        this.instance &#x3D; BsTimelineComponent.counter++;
        
    }

    get innerWidth(): number {
        return this.width - this.margin.left - this.margin.right;
    }

    get innerHeight(): number {
        return this.height - this.margin.top - this.margin.bottom;
    }

    // Note: ngOnChanges is always called once before ngAfterViewInit
    ngOnChanges(changes: SimpleChanges) {

        if(!this.x) {
            
            // Scales
            this.x &#x3D; d3.scaleUtc()
                .range([0, this.innerWidth]);
            this.xt &#x3D; this.x;

            this.y &#x3D; d3.scaleLinear()
                .range([this.innerHeight, 0]);
                
            // Shapes
            this.area &#x3D; d3.area&lt;TimelineDate&gt;()
                .curve(d3[this.curveType])
                .x(d &#x3D;&gt; this.xt(d.date))
                .y0(this.y(0))
                .y1(d &#x3D;&gt; this.y(d.value));
                
            this.line &#x3D; d3.line&lt;TimelineDate&gt;()
                .curve(d3[this.curveType])
                .x(d &#x3D;&gt; this.xt(d.date))
                .y(d &#x3D;&gt; this.y(d.value));
                
            // Behaviors
            this.brushBehavior &#x3D; d3.brushX()
                .extent([[0, 0], [this.innerWidth, this.innerHeight]])
                .on(&quot;start&quot;, () &#x3D;&gt; this.brushing &#x3D; true)
                .on(&#x27;brush&#x27;, () &#x3D;&gt; this.onBrush())
                .on(&#x27;end&#x27;, () &#x3D;&gt; this.onBrushEnd());
        }

        // Resize handling

        if(changes[&quot;height&quot;]) {
            this.y.range([this.innerHeight, 0]);
            this.area.y0(this.y(0));
            this.brushBehavior.extent([[0, 0], [this.innerWidth, this.innerHeight]]);
            if(this.viewInit) {
                this.drawYAxis();
                this.brush$.call(this.brushBehavior);
                this.grips$.selectAll(&quot;path&quot;).attr(&quot;d&quot;, this.drawGrips);
            }
        }

        if(changes[&quot;width&quot;]) {
            this.x.range([0, this.innerWidth]);
            this.brushBehavior.extent([[0, 0], [this.innerWidth, this.innerHeight]]);
            if(this.viewInit) {
                this.drawXAxis();
                if(!changes[&quot;height&quot;]) {
                    this.brush$.call(this.brushBehavior);
                    this.grips$.selectAll(&quot;path&quot;).attr(&quot;d&quot;, this.drawGrips);
                }
            }
        }

        // If the parent changes the selection, we want to update it
        // If not, we keep the current selection as is
        // (Important to keep this statement outside of the if bellow since 
        // the change of selection can be combined with a change of data)
        const selectionChanged &#x3D; changes[&quot;selection&quot;] &amp;&amp; this.updateSelection();

        // Only changes in data result in redrawing the chart
        // (other input, except selection, are expected to be static)
        if(this.viewInit &amp;&amp; changes[&quot;data&quot;] &amp;&amp; this.checkDataChanges(changes[&quot;data&quot;])){
            this.updateChart();
        }

        // If the parent changes the selection (even though the data hasn&#x27;t changed), 
        // we want to update the brush.
        // If not, we keep the current selection as is.
        // We can update the brush only if the view is initialized (viewInit).
        else if(this.viewInit &amp;&amp; ((changes[&quot;selection&quot;] &amp;&amp; selectionChanged) || changes[&quot;width&quot;])) {
            this.updateBrush();
        }

        if(changes[&quot;events&quot;]) {
            this.updateEvents();
        }
        
    }

    // Note: In onAfterViewInit we can access gx, gy, etc., obtained with @ViewChild.
    // At this point we can initialize all the primitives and call updateChart()
    ngAfterViewInit() {

        // Get native elements
        this.xAxis$ &#x3D; d3.select(this.gx.nativeElement);
        this.yAxis$ &#x3D; d3.select(this.gy.nativeElement);
        this.brush$ &#x3D; d3.select(this.gbrush.nativeElement);

        this.brush$
            .call(this.brushBehavior)
            .on(&quot;mousemove&quot;, () &#x3D;&gt; this.onMousemove())
            .on(&quot;mouseout&quot;, () &#x3D;&gt; this.onMouseout());
                        
        // Add 2 &quot;grips&quot; to the brush goup, on each side of the rectangle
        // Grips are inserted programmatically to appear on top the brush selection
        this.grips$ &#x3D; this.brush$.selectAll&lt;SVGGElement, {type: string}&gt;(&quot;.grip&quot;)
            .data([{type: &quot;w&quot;}, {type: &quot;e&quot;}])
            .enter()
            .append(&quot;g&quot;)
            .attr(&quot;class&quot;, &quot;grip&quot;)
            .attr(&quot;display&quot;, &quot;none&quot;);
            
        this.grips$.append(&quot;path&quot;)
            .attr(&quot;d&quot;, this.drawGrips);

        this.grips$.append(&quot;text&quot;)
            .attr(&quot;class&quot;, &quot;grip-text&quot;)
            .attr(&quot;text-anchor&quot;, d &#x3D;&gt; d.type &#x3D;&#x3D;&#x3D; &quot;w&quot;? &#x27;end&#x27; : &#x27;start&#x27;)
            .attr(&quot;x&quot;, d &#x3D;&gt; d.type &#x3D;&#x3D;&#x3D; &quot;w&quot;? -5 : 5)
            .attr(&quot;y&quot;, 10);

        this.viewInit &#x3D; true;

        this.updateChart();

        // This is necessary to prevent &quot;Expression has changed after check&quot; errors
        // caused by calling updateChart inside ngAfterViewInit().
        // Unfortunately this is necessary because we need the DOM to be rendered in order fill the DOM
        // (for example gAxis needs to exist so we can draw the axis)
        this.cdRef.detectChanges();
    }

    /**
     * Redraw the graph (needs to be called after ngAfterViewInit so that the DOM elements
     * are accessible)
     */
    updateChart() {

        this.turnoffTooltip();

        if(this.data &amp;&amp; this.data.length) {

            // Update scales
            // Note: does not stop the update process even if the data is invalid/empty
            this.updateScales(this.data);

            // Update Axes
            this.updateAxes();
            
            // Update Zoom
            this.updateZoom();

            // Update brush
            this.updateBrush();

        }
        
    }


    /**
     * Update the x &amp; y scales, based on the input data
     * @param data 
     */
    protected updateScales(data: TimelineSeries[]) {

        // Set x and y scales with the primary series (or first one)
        const primarySeries &#x3D; data.filter(s &#x3D;&gt; s.primary) || [data[0]];
        const allPrimaryDates &#x3D; ([] as TimelineDate[]).concat(...primarySeries.map(s &#x3D;&gt; s.dates));

        const xExtent &#x3D; d3.extent&lt;TimelineDate, Date&gt;(allPrimaryDates, d &#x3D;&gt; d.date);
        const yMax &#x3D; d3.max&lt;TimelineSeries, number&gt;(data, 
            s &#x3D;&gt; d3.max&lt;TimelineDate, number&gt;(s.dates, d &#x3D;&gt; d.value));

        // Check validity of data
        if(!xExtent[0] || !xExtent[1] || !yMax) {
            if (allPrimaryDates.length !&#x3D;&#x3D; 0) {
                console.error(&#x27;Invalid timeseries&#x27;, primarySeries);
            }
            this.x.domain(this.xt.domain());
            this.xt &#x3D; this.x;
            return;
        }

        // Enforce minimum date
        if(this.minDate) {
            xExtent[0] &#x3D; this.minDate;
        }

        // Enforce maximum date
        if(this.maxDate) {
            xExtent[1] &#x3D; this.maxDate;
        }

        // Enforce minimum scale (especially when the timeseries contains a single datapoint)
        const diff &#x3D; xExtent[1].getTime() - xExtent[0].getTime();
        const minDiff &#x3D; this.minZoomDays * 24 * 60 * 60 * 1000;
        if(diff &lt; minDiff) {
            const delta &#x3D; 0.5 * (minDiff - diff); // Delta is the amount of time missing before and after
            xExtent[0] &#x3D; new Date(xExtent[0].getTime() - delta);
            xExtent[1] &#x3D; new Date(xExtent[0].getTime() + delta);
        }

        this.x.domain(xExtent);
        this.xt &#x3D; this.x;
        this.y.domain([0, yMax*1.1]);
        
        // Fire an initial rangeInit event so that the parent can initialize the currentRange property
        // The setTimeout prevents &quot;expressionChangedAfterCheck&quot; error (since the parent then updates the min/max dates)
        setTimeout(() &#x3D;&gt; this.rangeInit.next(this.xt.domain()));
    }

    /**
     * Update the x and y axes
     */
    protected updateAxes(){
        this.drawXAxis();
        this.drawYAxis();
    }

    /**
     * The events are drawn in the template directly. This method simply
     * updates the grouping of events (when they are close to each other)
     */
    protected updateEvents() {
        this.groupedEvents &#x3D; this.groupEvents(5);
    }

    /**
     * Update/reset the zoom behavior when new data comes in (and new scales, axes...)
     */
    protected updateZoom() {
        
        if(!this.zoomable) {
            return;
        }

        // Reset the previous zoom !
        if(this.zoomBehavior){
            this.zoomBehavior.on(&quot;zoom&quot;, null);
            this.zoomBehavior.on(&quot;end&quot;, null);
            this.zoomBehavior.transform(this.brush$, d3.zoomIdentity);
        }
        
        // Compute the minimum and maximum zoom
        const xDomain &#x3D; this.x.domain();
        const scaleExtent &#x3D; (xDomain[1].getTime() - xDomain[0].getTime()) / 86400000; // current number of days on the scale

        // Create the behavior
        this.zoomBehavior &#x3D; d3.zoom()
            .extent([[0, 0], [this.innerWidth, this.innerHeight]])
            .scaleExtent([scaleExtent/this.maxZoomDays, scaleExtent/this.minZoomDays])
            .on(&quot;zoom&quot;, () &#x3D;&gt; this.onZoom())
            .on(&quot;end&quot;, () &#x3D;&gt; this.onZoomEnd());
        
        // Apply on to the brush element
        this.brush$
            .call(this.zoomBehavior)
            .on(&quot;mousedown.zoom&quot;, null) // Deactivate mouse event (taken by brush)
            .on(&quot;touchstart.zoom&quot;, null)
            .on(&quot;touchmove.zoom&quot;, null)
            .on(&quot;touchend.zoom&quot;, null);
        
    }

    /**
     * Updates the brush (or hides it if no currentSelection),
     * following a change of x scale.
     */
    protected updateBrush() {
        if(this.currentSelection) {
            const selection: [number, number] &#x3D; [this.xt(this.currentSelection[0]), this.xt(this.currentSelection[1])];
            this.brush$.call(this.brushBehavior.move, selection);
        }
        else {
            this.brush$.call(this.brushBehavior.move, null);
        }
    }

    /**
     * This method tests whether the input selection is different from the currentSelection
     * and updates it. It returns true if there is actually a change.
     */
    protected updateSelection(): boolean {
        const change &#x3D; this.checkSelectionChange(this.selection, this.currentSelection);
        this.currentSelection &#x3D; this.selection;
        return change;
    }

    /**
     * Recreate the x scale and axes (in the event of a language change)
     */
    protected updateXAxis(){        
        this.x &#x3D; d3.scaleUtc()
            .domain(this.x.domain())
            .range(this.x.range());
        
        this.xt &#x3D; d3.scaleUtc()
            .domain(this.xt.domain())
            .range(this.xt.range());

        this.drawXAxis();
    }

    /**
     * Draws the X axis
     */
    protected drawXAxis() {
        const nTicks &#x3D; Math.round(this.width / 100);
        this.xAxis$.call(d3.axisBottom(this.xt).ticks(nTicks));
        this.xAxis$.selectAll(&quot;.domain&quot;).remove(); // Remove the axis line
    }

    /**
     * Draws the Y axis
     */
    protected drawYAxis() {
        const nTicks &#x3D; Math.round(this.height / 40);

        const yAxisTicks &#x3D; this.y.ticks(nTicks)
            .filter(tick &#x3D;&gt; Number.isInteger(tick)); // Keep only integer ticks https://stackoverflow.com/questions/13576906/d3-tick-marks-on-integers-only/56821215

        const yAxis &#x3D; d3.axisLeft&lt;number&gt;(this.y)
            .tickValues(yAxisTicks)
            .tickFormat(d3.format(&quot;~s&quot;)); //https://github.com/d3/d3-format
        this.yAxis$.call(yAxis);
        this.yAxis$.selectAll(&quot;.domain&quot;).remove(); // Remove the axis line
    }
    
    /**
     * Updates the display of the brush&#x27;s grips when the brush has moved
     * @param selection 
     */
    protected updateGrips(selection: [number, number] | null) {
        if (!selection) {
            this.grips$.attr(&quot;display&quot;, &quot;none&quot;);
        }
        else {
            this.grips$
                .attr(&quot;display&quot;, null)
                .attr(&quot;transform&quot;, (d, i) &#x3D;&gt; &quot;translate(&quot; + selection[i] + &quot;)&quot;);
            this.grips$.selectAll&lt;SVGTextElement, {type:string}&gt;(&#x27;.grip-text&#x27;)
                .text(d &#x3D;&gt; this.intlService.formatDate(this.xt.invert(selection[d.type &#x3D;&#x3D;&#x3D; &#x27;w&#x27;? 0 : 1])));
        }
    }


    // Interaction callbacks

    onBrush() {
        this.turnoffTooltip();
        this.brushSelection &#x3D; d3.brushSelection(this.gbrush.nativeElement) as [number, number] | null;
        this.updateGrips(this.brushSelection);
    }

    onBrushEnd(){
        this.brushing &#x3D; false;
        this.onBrush();
        const newSelection &#x3D; this.brushSelection?.sort((a,b)&#x3D;&gt;a-b).map(this.xt.invert);
        if(this.checkSelectionChange(this.currentSelection, newSelection)) {
            this.currentSelection &#x3D; newSelection;
            this.selectionChange.next(this.currentSelection);
        }
    }    

    onZoom(){

        this.turnoffTooltip();

        this.zooming &#x3D; true;

        // Create a transformed scale without modifying the original (to enforce the limit of scaleExtent)
        const transform &#x3D; d3.zoomTransform(this.brush$.node() as Element);
        this.xt &#x3D; transform.rescaleX(this.x);

        // Redraw the axis
        this.drawXAxis();
            
        // Update the brush position
        if(this.currentSelection){
            const selection: [number, number] &#x3D; [this.xt(this.currentSelection[0]), this.xt(this.currentSelection[1])];
            this.brushBehavior.move(this.brush$, selection);
        }

    }

    onZoomEnd(){
        this.zooming &#x3D; false;

        // At the end of a zoom, we need to reorganize the grouping of events
        this.updateEvents();

        // Fire an event
        this.rangeChange.next(this.xt.domain());
    }

    /**
     * Redraw the simple tooltip (vertical line)
     */
    onMousemove() {
        if(!this.tooltipItem &amp;&amp; this.showTooltip) {
            this.tooltipX &#x3D; d3.mouse(this.gbrush.nativeElement)[0];
        }
    }

    /**
     * Remove the simple tooltip (vertical line)
     */
    onMouseout() {
        if(!this.tooltipItem) {
            this.tooltipX &#x3D; undefined
        }
    }

    /**
     * Responds to a click on an event (triangle) by essentially turning tooltip on/off
     * @param event 
     */
    onEventClick(event: TimelineEvent[]) {

        if(this.tooltipItem &#x3D;&#x3D;&#x3D; event) {
            this.turnoffTooltip();
        }

        else {

            if(this.tooltipItem) {
                this.turnoffTooltip();
            }

            this.tooltipItem &#x3D; event;
            this.tooltipX &#x3D; this.xt(event[0].date);

            // Since we use viewBox to auto-adjust the SVG to the container size, we have to
            // convert from the SVG coordinate system to the HTML coordinate system
            const x &#x3D; this.margin.left + this.tooltipX;
            const actualWidth &#x3D; (this.el.nativeElement as HTMLElement).offsetWidth;
            const scale &#x3D; actualWidth / this.width;
            const relativeX &#x3D; x / this.width;

            // Tooltip to the right
            if(relativeX &lt; 0.5) {
                this.tooltipOrientation &#x3D; &quot;right&quot;;
                this.tooltipLeft &#x3D; scale * x;
            }
            // Tooltip to the left
            else {
                this.tooltipOrientation &#x3D; &quot;left&quot;;
                this.tooltipRight &#x3D; actualWidth - scale * x;
            }
            this.tooltipTop &#x3D; scale * (this.margin.top + 0.3*this.innerHeight); // Align tooltip arrow

        }
    }

    /**
     * Turns off the tooltip
     */
    turnoffTooltip &#x3D; () &#x3D;&gt; {
        if(this.tooltipItem) {
            this.tooltipItem &#x3D; undefined;
            this.tooltipX &#x3D; undefined;
        }
    }

    ngOnDestroy(){
        this.intlSubscription.unsubscribe();
    }

    // Utilities

    /**
     * Transforms the input list of events into a list of list, by grouping events within a bin
     * when their dates are close together. This closeness is measured in &quot;pixel per event&quot;.
     * Note: this currently uses a histogram-like algorithm, which could probably be improved (clustering?)
     * @param pixPerEvent 
     */
    protected groupEvents(pixPerEvent: number): TimelineEvent[][] {
        const events: TimelineEvent[][] &#x3D; [];

        if(this.events) {
            const nbins &#x3D; Math.floor(this.innerWidth / pixPerEvent);
            const domain &#x3D; this.xt.domain();
            const timeinterval &#x3D; (domain[1].getTime() - domain[0].getTime()) / nbins;
            this.events.concat()
                .sort((a,b) &#x3D;&gt; a.date.getTime() - b.date.getTime())
                .forEach(event &#x3D;&gt; {
                    if(events.length &#x3D;&#x3D;&#x3D; 0) {
                        events.push([event]);
                    }
                    else {
                        const last &#x3D; events[events.length-1];
                        const lastbin &#x3D; Math.floor(last[0].date.getTime() / timeinterval);
                        const bin &#x3D; Math.floor(event.date.getTime() / timeinterval);
                        if(bin &#x3D;&#x3D;&#x3D; lastbin) {
                            last.push(event);
                        }
                        else {
                            events.push([event]);
                        }
                    }
                });
        }

        return events;
    }

    /**
     * Return true if there are actual changes in the data
     * (in particular will ignore data refresh which change nothing)
     * @param change 
     */
    protected checkDataChanges(change: SimpleChange): boolean {
        const previousValue &#x3D; change.previousValue as TimelineSeries[] | undefined;
        const currentValue &#x3D; change.currentValue as TimelineSeries[] | undefined;
        
        // Ignore null/undefined difference cause by | async
        // See: https://github.com/angular/angular/issues/16982
        if(currentValue &#x3D;&#x3D;&#x3D; null &amp;&amp; previousValue &#x3D;&#x3D;&#x3D; undefined || currentValue &#x3D;&#x3D;&#x3D; undefined &amp;&amp; previousValue &#x3D;&#x3D;&#x3D; null)
            return false;

        // Else, if one of them is null/undefined (or difference in length), there&#x27;s clearly a change
        if(!previousValue || !currentValue || previousValue.length !&#x3D;&#x3D; currentValue.length)
            return true;
        
        // If both defined and same size, we need to compare the data piece by piece
        for(let i&#x3D;0; i&lt;currentValue.length; i++) {

            const previousSeries &#x3D; previousValue[i];
            const currentSeries &#x3D; currentValue[i];
            if(previousSeries.name !&#x3D;&#x3D; currentSeries.name 
                || previousSeries.primary !&#x3D;&#x3D; currentSeries.primary 
                || previousSeries.areaStyles !&#x3D;&#x3D; currentSeries.areaStyles
                || previousSeries.lineStyles !&#x3D;&#x3D; currentSeries.lineStyles
                || previousSeries.dates.length !&#x3D;&#x3D; currentSeries.dates.length) {
                return true;
            }
            for(let j&#x3D;0; j&lt;previousSeries.dates.length; j++) {
                if(previousSeries.dates[j].value !&#x3D;&#x3D; currentSeries.dates[j].value
                    || previousSeries.dates[j].date.getTime() !&#x3D;&#x3D; currentSeries.dates[j].date.getTime()){
                    return true;
                }                
            }
        }
        
        return false;
    }

    /**
     * Compare the date selections with a second of tolerance (to handle interpolation errors)
     * @param selection1 
     * @param selection2 
     */
    protected checkSelectionChange(selection1: Date[] | undefined, selection2: Date[] | undefined): boolean {
        return !selection1 &amp;&amp; !!selection2 ||
              !!selection1 &amp;&amp; !selection2 ||
              !!selection1 &amp;&amp; !!selection2 &amp;&amp; 
                (Math.floor((selection1[0].getTime() - selection2[0].getTime())/1000) !&#x3D;&#x3D; 0 ||
                 Math.floor((selection1[1].getTime() - selection2[1].getTime())/1000) !&#x3D;&#x3D; 0);
    }
    
    /**
     * Returns a string containing the path coordinates of a &quot;grip&quot; to draw on each side of
     * the brush object
     */
    protected drawGrips &#x3D; (d) &#x3D;&gt; {
        const gripHeight &#x3D; Math.min(10, Math.max((this.innerHeight) / 8, 4));
        const gripWidth &#x3D; gripHeight;

        const x &#x3D; -gripWidth / 2;
        const y &#x3D; this.innerHeight / 2 - gripHeight / 2;

        const path &#x3D;
            &#x27;M &#x27; + x + &#x27; &#x27; + y +
            &#x27; l &#x27; + -gripWidth + &#x27; &#x27; + gripHeight / 2 +
            &#x27; l &#x27; + gripWidth + &#x27; &#x27; + gripHeight / 2 + &#x27; z &#x27; +
            &#x27;M &#x27; + -x + &#x27; &#x27; + y +
            &#x27; l &#x27; + gripWidth + &#x27; &#x27; + gripHeight / 2 +
            &#x27; l &#x27; + -gripWidth + &#x27; &#x27; + gripHeight / 2 + &#x27; z &#x27; +
            &#x27;M 0 &#x27; + 0 + &#x27; l 0 &#x27; + this.innerHeight + &#x27; z &#x27;;
        return path;
    }

    /**
     * Returns the size of the triangle drawn for one event (or a group of events)
     * @param events 
     */
    eventSize(events: TimelineEvent[]): number {
        if(events!&#x3D;&#x3D;this.tooltipItem) {
            return events[0].size || 6;
        }
        else {
            return events[0].sizeOpened || (events[0].size || 6)*2;
        }
    }

    /**
     * Return a string containing the path coordinates of a triangle for a given event (or group of events)
     * @param events 
     * @param size 
     */
    drawEvents(events: TimelineEvent[], size: number): string {
        const x &#x3D; this.xt(events[0].date);
        return &#x27;M &#x27; + x + &#x27; &#x27; + (this.innerHeight - 3*size/2) +
            &#x27; l &#x27; + -size + &#x27; &#x27; + (3*size/2) +
            &#x27; l &#x27; + (2*size) + &#x27; &#x27; + 0 + &#x27; z &#x27;;
    }
}</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'TimelineDate.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
