<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Core</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">Core</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>AppEvent</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>app-utils/app.service.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>A base event from which all events that can be issued by the <a href="../injectables/AppService.html">AppService</a> are derived</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#type">type</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="type"></a>
                                        <span class="name"><b>type</b><a href="#type"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>type:     <code></code>
</code>
                                    </td>
                                </tr>







                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {Injectable, Inject, OnDestroy} from &quot;@angular/core&quot;;
import {Observable, Subject} from &quot;rxjs&quot;;
import {map} from &quot;rxjs/operators&quot;;
import {Utils, MapOf, PatternMatcher} from &quot;@sinequa/core/base&quot;;
import {IntlService} from &quot;@sinequa/core/intl&quot;;
import {FormatService} from &quot;./format.service&quot;;
import {AppWebService, AuditEvents, START_CONFIG, StartConfig,
    CCApp, CCQuery, CCLabels, CCAutocomplete, CCColumn, CCIndex, CCWebService, CCConfig, CCList, CCAggregation,
    EngineType, EngineTypeModifier, MINIMUM_COMPATIBLE_SERVER_API_VERSION} from &quot;@sinequa/core/web-services&quot;;
import {ExprParser, ExprParserOptions, Expr} from &quot;./query/expr-parser&quot;;
import {AppServiceHelpers} from &quot;./app-service-helpers&quot;;

/**
 * A base event from which all events that can be issued by the {@link AppService} are derived
 */
export interface AppEvent {
    type: &quot;query-changed&quot;;
}

/**
 * This event is fired each time the [ccquery]{@link AppService#ccquery} member is modified.
 */
export interface QueryChangedEvent extends AppEvent {
    type: &quot;query-changed&quot;;
    current?: CCQuery;
    previous?: CCQuery;
}

/**
 * A union of the different events that the {@link AppService} can generate
 */
export type AppEvents &#x3D; QueryChangedEvent;

/**
 * A service to manage the Sinequa SBA configuration
 */
@Injectable({
    providedIn: &quot;root&quot;
})
export class AppService implements OnDestroy {
    // Should match AdditionalQueryableColumns in Engine.cs
    private static extraColumns: MapOf&lt;CCColumn&gt; &#x3D; {
        id: AppService.makeColumn(&quot;id&quot;, &quot;string&quot;),
        text: AppService.makeColumn(&quot;text&quot;, &quot;varchar&quot;),
        documentlanguages: AppService.makeColumn(&quot;documentlanguages&quot;, &quot;csv&quot;, &quot;ci&quot;),
        databasealias: AppService.makeColumn(&quot;databasealias&quot;, &quot;varchar&quot;),
        globalrelevance: AppService.makeColumn(&quot;globalrelevance&quot;, &quot;double&quot;),
        matchingpartnames: AppService.makeColumn(&quot;matchingpartnames&quot;, &quot;csv&quot;),
        matchlocations: AppService.makeColumn(&quot;matchlocations&quot;, &quot;csv&quot;),
        matchlocationsperpartname: AppService.makeColumn(&quot;matchlocationsperpartname&quot;, &quot;varchar&quot;), // json
        extracts: AppService.makeColumn(&quot;extracts&quot;, &quot;csv&quot;),
        extractsperpartname: AppService.makeColumn(&quot;extractsperpartname&quot;, &quot;varchar&quot;), // json
        extractslocations: AppService.makeColumn(&quot;extractslocations&quot;, &quot;csv&quot;),
        documentweight: AppService.makeColumn(&quot;documentweight&quot;, &quot;varchar&quot;),
        groupcount: AppService.makeColumn(&quot;groupcount&quot;, &quot;integer&quot;),
        accesslists: AppService.makeColumn(&quot;accesslists&quot;, &quot;varchar&quot;, undefined, [&quot;accessLists&quot;]) // json
    };

    /**
     * The app configuration
     */
    app?: CCApp;
    /**
     * The labels configuration
     */
    cclabels?: CCLabels;
    /**
     * The autocomplete configuration
     */
    ccautocomplete?: CCAutocomplete;
    /**
     * The suggest queries configured on the application
     */
    suggestQueries: string[];
    private columnsByQuery: MapOf&lt;MapOf&lt;CCColumn&gt;&gt;;
    private columnsByIndex: MapOf&lt;MapOf&lt;CCColumn&gt;&gt;;
    private fieldsByQuery: MapOf&lt;string[]&gt;;
    private _defaultCCQuery?: CCQuery;
    private _ccquery?: CCQuery;

    protected _events &#x3D; new Subject&lt;AppEvents&gt;();

    private static toEngineType(type: string): EngineType {
        if (!type) {
            return EngineType.none;
        }
        switch (Utils.toLowerCase(type)) {
            case &quot;bool&quot;     :
            case &quot;boolean&quot;  : return EngineType.bool;
            case &quot;date&quot;     : return EngineType.date;
            case &quot;datetime&quot; : return EngineType.dateTime;
            case &quot;time&quot;     : return EngineType.time;
            case &quot;unsigned&quot; : return EngineType.unsigned;
            case &quot;integer&quot;  : return EngineType.integer;
            case &quot;float&quot;    : return EngineType.float;
            case &quot;double&quot;   : return EngineType.double;
            case &quot;dates&quot;    : return EngineType.dates;
            case &quot;datetimes&quot;: return EngineType.dateTimes;
            case &quot;times&quot;    : return EngineType.times;
            case &quot;varchar&quot;  : return EngineType.varchar;
            case &quot;binary&quot;   : return EngineType.binary;
            case &quot;string&quot;   : return EngineType.string;
            case &quot;csv&quot;      : return EngineType.csv;
            default         : return EngineType.none;
        }
    }

    private static toEngineTypeModifierSimple(c: string): EngineTypeModifier {
        switch (c) {
            case &#x27;a&#x27;: return EngineTypeModifier.a;
            case &#x27;c&#x27;: return EngineTypeModifier.c;
            case &#x27;d&#x27;: return EngineTypeModifier.d;
            case &#x27;e&#x27;: return EngineTypeModifier.e;
            case &#x27;i&#x27;: return EngineTypeModifier.i;
            case &#x27;l&#x27;: return EngineTypeModifier.l;
            case &#x27;n&#x27;: return EngineTypeModifier.n;
            case &#x27;t&#x27;: return EngineTypeModifier.t;
            case &#x27;x&#x27;: return EngineTypeModifier.x;
            case &#x27;z&#x27;: return EngineTypeModifier.z;
            default : return EngineTypeModifier.none;
        }
    }

    private static toEngineTypeModifier(eType: EngineType, typeModifier: string): EngineTypeModifier {
        let etm &#x3D; EngineTypeModifier.none;
        if (typeModifier) {
            for (const c of typeModifier) {
                etm |&#x3D; AppService.toEngineTypeModifierSimple(c);
            }
        }
        return etm;
    }

    private static makeColumn(name: string, type: string, typeModifier?: string, aliases?: string[]) {
        const eType &#x3D; AppService.toEngineType(type);
        const eTypeModifier &#x3D; AppService.toEngineTypeModifier(eType, typeModifier || &quot;&quot;);
        return {
            name,
            type,
            typeModifier,
            eType,
            eTypeModifier,
            aliases
        };
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is a string
     */
    static isString(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isString(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is a csv
     */
    static isCsv(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isCsv(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is a tree
     */
    static isTree(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isTree(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is an entity
     */
    static isEntity(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isEntity(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is a boolean
     */
    static isBoolean(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isBoolean(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is a date
     */
    static isDate(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isDate(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is a double
     */
    static isDouble(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isDouble(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is an integer
     */
    static isInteger(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isInteger(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is a number (integer or double)
     */
    static isNumber(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isNumber(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is a scalar
     */
    static isScalar(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isScalar(column);
    }

    /**
     * Return &#x60;true&#x60; if a &#x60;column&#x60; is sortable
     */
    static isSortable(column: CCColumn | undefined): boolean {
        return AppServiceHelpers.isSortable(column);
    }

    constructor(
        @Inject(START_CONFIG) public startConfig: StartConfig,
        public appWebService: AppWebService,
        public intlService: IntlService,
        public formatService: FormatService) {

        if (!this.appName) {
            console.error(&quot;Missing app name!&quot;);
        }
    }

    ngOnDestroy() {
        this._events.complete();
    }

    /**
     * Return an &#x60;Observable&#x60; stream of the events that the &#x60;AppService&#x60; can generate
     */
    get events(): Observable&lt;AppEvents&gt; {
        return this._events;
    }

    /**
     * Return the name of the SBA
     */
    get appName(): string {
        return this.startConfig.app!;
    }

    /**
     * Return the origin of the Sinequa server
     */
    get origin(): string {
        return this.startConfig.origin!;
    }

    private initDefaultQuery() {
        if (!this.app) {
            console.warn(&quot;No app configured&quot;);
            return;
        }
        // If not set explicitly, the default query is the first in the list
        const defaultQueryName &#x3D; this.app.defaultQueryName || Utils.split(this.app.queryNames, &quot;,&quot;)[0];
        this._defaultCCQuery &#x3D; Utils.getField&lt;CCQuery&gt;(this.app.queries, defaultQueryName);
        if (!this._defaultCCQuery) {
            console.warn(&#x60;Query not configured for app: ${this.appName}&#x60;);
        }
        this.ccquery &#x3D; this._defaultCCQuery;
    }

    private setApp(app: CCApp) {
        this.app &#x3D; app;
        this.verifyServerApiVersionCompatibility(app);
        this.cclabels &#x3D; this.getWebService&lt;CCLabels&gt;(this.app.labels);
        this.ccautocomplete &#x3D; this.getWebService&lt;CCAutocomplete&gt;(this.app.autocomplete);
        this.initDefaultQuery();
        this.makeMaps();
        this.suggestQueries &#x3D; Utils.split(this.ccautocomplete ? this.ccautocomplete.suggestQueries : &quot;&quot;, &quot;,&quot;);
    }

    private verifyServerApiVersionCompatibility(app: CCApp): void {
        if (!app) {
            console.warn(&#x27;Unexpected empty app configuration.&#x27;);
            return;
        }
        if (!app.apiVersion) {
            console.error(&#x60;The App config &#x27;${app.name}&#x27; is not of &#x27;Angular Workspace application&#x27; type.&#x60;);
        } else if (app.apiVersion !&#x3D;&#x3D; MINIMUM_COMPATIBLE_SERVER_API_VERSION) {
            console.warn(&#x60;This SBA is not compatible with the REST API of Sinequa Server.\n&#x60; +
                &#x60;The SBA expects the server API version to be at least &#x27;${MINIMUM_COMPATIBLE_SERVER_API_VERSION}&#x27;,&#x60; +
                &#x60; whereas the server API version is &#x27;${app.apiVersion}&#x27;.&#x60;);
        }
    }

    /**
     * Initialize this service by retrieving the current application
     * configuration from the Sinequa server and using it to set up the data structures
     * on which the service relies
     */
    init(): Observable&lt;CCApp&gt; {
        return this.appWebService.get().pipe(
            map(app &#x3D;&gt; {
                this.setApp(app);
                return app;
            }
        ));
    }

    /**
     * Initialize this service from an application configuration object. This is typically
     * used for supporting mutiple concurrent queries within the same application by providing
     * component level instances of this service.
     */
    initFromApp(app: CCApp) {
        if (app) {
            this.setApp(app);
        }
    }

    /**
     * Refresh the application configuration, reinitializing the service if it has changed
     *
     * @param auditEvents Any associated audit events that should be stored
     */
    refresh(auditEvents?: AuditEvents): Observable&lt;CCApp | undefined&gt; {
        const observable &#x3D; this.appWebService.refresh(this.app ? this.app.versionId : &quot;&quot;, auditEvents);
        observable.subscribe(
            response &#x3D;&gt; {
                if (!response.upToDate &amp;&amp; response.app) {
                    this.setApp(response.app);
                }
                return response;
            }
        );
        return observable.pipe(map((value) &#x3D;&gt; {
            return this.app;
        }));
    }

    /**
     * Clear the data associated with the service. Typically used when processing a user logout
     */
    clear() {
        this.app &#x3D; undefined;
        this.cclabels &#x3D; undefined;
        this._defaultCCQuery &#x3D; undefined;
        this.ccquery &#x3D; undefined;
        this.clearMaps();
    }

    private indexIsNormal(ccindex: CCIndex): boolean {
        return !!ccindex &amp;&amp; (!ccindex.indexType || Utils.startsWith(ccindex.indexType, &quot;normal&quot;));
    }

    private getIndexForQuery(ccquery: CCQuery): CCIndex | undefined {
        if (!ccquery) {
            return undefined;
        }
        const indexes &#x3D; Utils.split(ccquery.searchIndexes, [&quot;,&quot;]);
        if (indexes.length &#x3D;&#x3D;&#x3D; 0) {
            return this.app ? this.app.indexes._ : undefined;
        }
        else {
            const ccindex &#x3D; this.getIndex(indexes[0]);
            if (ccindex &amp;&amp; this.indexIsNormal(ccindex)) {
                return this.app ? this.app.indexes._ : undefined;
            }
            return ccindex;
        }
    }

    private _makeColumnMapForIndex(columnMap: MapOf&lt;CCColumn&gt;, ccindex: CCIndex) {
        if (!ccindex || !ccindex.columns) {
            return;
        }
        for (const columnName of Object.keys(ccindex.columns)) {
            const column &#x3D; ccindex.columns[columnName];
            columnMap[Utils.toLowerCase(column.name)] &#x3D; column;
            if (column.aliases) {
                for (const alias of column.aliases) {
                    columnMap[Utils.toLowerCase(alias)] &#x3D; column;
                }
            }
        }
    }

    private _makeColumnMapForQuery(columnMap: MapOf&lt;CCColumn&gt;, ccquery: CCQuery) {
        if (!ccquery || !ccquery.columnsInfo || !ccquery.columnsInfo.columns) {
            return;
        }
        const ccindex &#x3D; this.getIndexForQuery(ccquery);
        if (!ccindex || !ccindex.columns) {
            return;
        }
        for (const columnInfo of ccquery.columnsInfo.columns) {
            if (columnInfo.name) {
                const columnName &#x3D; Utils.toLowerCase(columnInfo.name);
                let column &#x3D; ccindex.columns[columnName];
                if (!column) {
                    column &#x3D; AppService.extraColumns[columnName];
                }
                if (column) {
                    // Copy column so we can add the query specific aliases and labels
                    column &#x3D; Utils.copy(column);
                    columnMap[columnName] &#x3D; column;
                    if (columnInfo.aliases) {
                        column.aliases &#x3D; Utils.split(columnInfo.aliases, [&quot;,&quot;, &quot;;&quot;]);
                        for (const alias of column.aliases) {
                            columnMap[Utils.toLowerCase(alias)] &#x3D; column;
                        }
                    }
                    // Overwrite labels if defined on the query
                    if (columnInfo.label) {
                        column.label &#x3D; columnInfo.label;
                    }
                    if (columnInfo.labelPlural) {
                        column.labelPlural &#x3D; columnInfo.labelPlural;
                    }
                    if (columnInfo.formatter) {
                        column.formatter &#x3D; columnInfo.formatter;
                    }
                    if (columnInfo.transforms) {
                        column.transforms &#x3D; columnInfo.transforms;
                    }
                    if (columnInfo.parser) {
                        column.parser &#x3D; columnInfo.parser;
                    }
                    if (columnInfo.description) {
                        column.description &#x3D; columnInfo.description;
                    }
                }
            }
        }
    }

    protected makeMaps() {
        this.columnsByQuery &#x3D; {};
        this.columnsByIndex &#x3D; {};
        this.fieldsByQuery &#x3D; {};
        if (!this.app) {
            return;
        }
        let columnMap: MapOf&lt;CCColumn&gt;;

        // Queries
        if (this.app.queries) {
            for (const queryName of Object.keys(this.app.queries)) {
                const ccquery &#x3D; this.app.queries[queryName];
                if (ccquery) {
                    ccquery.$columnFieldsPattern &#x3D; new PatternMatcher(&quot;included column fields&quot;, &quot;excluded column fields&quot;);
                    ccquery.$columnFieldsPattern.includedPattern.setText(ccquery.columnFieldsIncluded);
                    ccquery.$columnFieldsPattern.excludedPattern.setText(ccquery.columnFieldsExcluded);
                    ccquery.$partnameFieldsPattern &#x3D; new PatternMatcher(&quot;included part name fields&quot;, &quot;excluded part name fields&quot;);
                    ccquery.$partnameFieldsPattern.includedPattern.setText(ccquery.partnameFieldsIncluded);
                    ccquery.$partnameFieldsPattern.excludedPattern.setText(ccquery.partnameFieldsExcluded);
                    if (ccquery.columnsInfo) {
                        columnMap &#x3D; {};
                        this.columnsByQuery[Utils.toLowerCase(ccquery.name)] &#x3D; columnMap;
                        this._makeColumnMapForQuery(columnMap, ccquery);
                    }
                }
            }
        }

        // Indexes
        if (this.app.indexes) {
            // Special normal index
            const ccindex &#x3D; this.app.indexes._;
            if (ccindex) {
                columnMap &#x3D; {};
                this.columnsByIndex._ &#x3D; columnMap;
                this._makeColumnMapForIndex(columnMap, ccindex);

            }
            for (const indexName of Object.keys(this.app.indexes)) {
                const ccindex1 &#x3D; this.app.indexes[Utils.toLowerCase(indexName)];
                if (ccindex1) {
                    if (this.indexIsNormal(ccindex1)) {
                        if (ccindex1.name !&#x3D;&#x3D; &quot;_&quot;) {
                            this.columnsByIndex[Utils.toLowerCase(ccindex1.name)] &#x3D; this.columnsByIndex._;
                        }
                    }
                    else {
                        columnMap &#x3D; {};
                        this.columnsByIndex[Utils.toLowerCase(ccindex1.name)] &#x3D; columnMap;
                        this._makeColumnMapForIndex(columnMap, ccindex1);
                    }
                }
            }
        }

        // Fields per query (contains aliases for default query and globally defined aliases)
        const globalFields &#x3D; new Map&lt;string, string&gt;();
        const columns &#x3D; this.columnsByIndex._;
        if (columns) {
            for (const key of Object.keys(columns)) {
                const column &#x3D; columns[key];
                if (column.aliases &amp;&amp; column.aliases.length &gt; 0) {
                    const alias &#x3D; column.aliases[0];
                    if (alias) {
                        globalFields.set(alias, alias);
                    }
                }
            }
        }
        for (const queryName of Object.keys(this.columnsByQuery)) {
            const queryFields &#x3D; new Map&lt;string, string&gt;(globalFields);
            const columns1 &#x3D; this.columnsByQuery[Utils.toLowerCase(this.defaultCCQuery ? this.defaultCCQuery.name : &quot;&quot;)];
            if (columns1) {
                for (const key of Object.keys(columns1)) {
                    const column &#x3D; columns1[key];
                    if (column.aliases &amp;&amp; column.aliases.length &gt; 0) {
                        const alias &#x3D; column.aliases[0];
                        if (alias) {
                            queryFields.set(alias, alias);
                        }
                    }
                }
                this.fieldsByQuery[queryName] &#x3D; Array.from(queryFields.keys());
            }
        }
    }

    protected clearMaps() {
        this.columnsByQuery &#x3D; {};
        this.columnsByIndex &#x3D; {};
        this.fieldsByQuery &#x3D; {};
    }

    /**
     * Get the configuration of the web service with the passed name
     */
    getWebService&lt;T extends CCWebService&gt;(name: string): T | undefined {
        if (!this.app) {
            return undefined;
        }
        return Utils.getField&lt;CCConfig&gt;(this.app.webServices, name) as T;
    }

    /**
     * Get the list configuration with the passed name
     */
    getList(name: string): CCList | undefined {
        if (!this.app) {
            return undefined;
        }
        return this.app.lists[name];
    }

    /**
     * Return the default {@link CCQuery}
     */
    get defaultCCQuery(): CCQuery | undefined {
        return this._defaultCCQuery;
    }

    /**
     * Return the current {@link CCQuery}
     */
    get ccquery(): CCQuery | undefined {
        if (!!this._ccquery) {
            return this._ccquery;
        }
        return this._defaultCCQuery;
    }

    /**
     * Set the current {@link CCQuery}
     */
    set ccquery(value: CCQuery | undefined) {
        if (value !&#x3D;&#x3D; this._ccquery) {
            const previous &#x3D; this._ccquery;
            this._ccquery &#x3D; value;
            this._events.next({type: &quot;query-changed&quot;, current: this._ccquery, previous: previous});
        }
    }

    /**
     * Get the {@link CCQuery} with the passed name
     */
    getCCQuery(name: string): CCQuery | undefined {
        return this.app ? this.app.queries[Utils.toLowerCase(name)] : undefined;
    }

    /**
     * Set the current {@link CCQuery} to that with the passed name
     */
    setCCQuery(name?: string): boolean {
        const ccquery &#x3D; !name ? this.defaultCCQuery : this.getCCQuery(name);
        if (ccquery) {
            this.ccquery &#x3D; ccquery;
            return true;
        }
        else {
            console.warn(&#x60;AppService.setCCQuery - query &#x27;${name}&#x27; does not exist&#x60;);
            return false;
        }
    }

    /**
     * Return the fields defined on the current {@link CCQuery}
     */
    get fields(): string[] {
        if (!this.ccquery) {
            return [];
        }
        return this.fieldsByQuery[Utils.toLowerCase(this.ccquery.name)] || [];
    }

    /**
     * Get the {@link CCAggregation} with the passed name
     */
    getCCAggregation(name: string): CCAggregation | undefined {
        if (!this.ccquery || !this.ccquery.aggregations) {
            return undefined;
        }
        return this.ccquery.aggregations.find((value) &#x3D;&gt; Utils.eqNC(name, value.name));
    }

    /**
     * Get the {@link CCIndex} with the passed name
     */
    getIndex(name: string): CCIndex | undefined {
        if (!this.app) {
            return undefined;
        }
        return Utils.getField&lt;CCIndex&gt;(this.app.indexes, name);
    }

    /**
     * Get the {@link CCColumn} with the passed name. Aliases are resolved
     */
    getColumn(name: string | null | undefined): CCColumn | undefined {
        if (!name) {
            return undefined;
        }
        if (!this.ccquery) {
            return undefined;
        }
        // First, CCQuery specific aliases
        let column: CCColumn;
        let columnAliases &#x3D; this.columnsByQuery[Utils.toLowerCase(this.ccquery.name)];
        if (columnAliases) {
            column &#x3D; columnAliases[Utils.toLowerCase(name)];
            if (column) {
                return column;
            }
        }
        // Second, aliases by index
        const indexes &#x3D; Utils.split(this.ccquery.searchIndexes, [&quot;,&quot;]);
        const firstIndex &#x3D; indexes.length &#x3D;&#x3D;&#x3D; 0 ? undefined : this.getIndex(indexes[0]);
        if (indexes.length &#x3D;&#x3D;&#x3D; 0 || (!!firstIndex &amp;&amp; this.indexIsNormal(firstIndex))) {
            columnAliases &#x3D; this.columnsByIndex._;
            if (columnAliases) {
                column &#x3D; columnAliases[Utils.toLowerCase(name)];
                if (column) {
                    return column;
                }
            }
        }
        else {
            for (const index of indexes) {
                columnAliases &#x3D; this.columnsByIndex[Utils.toLowerCase(index)];
                if (columnAliases) {
                    column &#x3D; columnAliases[Utils.toLowerCase(name)];
                    if (column) {
                        return column;
                    }
                }
            }
        }
        // Third, extra columns
        column &#x3D; AppService.extraColumns[Utils.toLowerCase(name)];
        if (column) {
            return column;
        }
        return undefined;
    }

    /**
     * Get the default alias a column
     *
     * @param column The column
     * @return The default alias or &#x60;null&#x60; if no alias is defined
     */
    getColumnDefaultAlias(column?: CCColumn): string {
        if (column) {
            if (column.aliases &amp;&amp; column.aliases.length &gt; 0) {
                return column.aliases[0];
            }
        }
        return &quot;&quot;;
    }

    /**
     * Get the name of a column
     *
     * @param column The column
     * @param _default A default name to return if &#x60;column&#x60; is empty
     */
    private getColumnName(column?: CCColumn, _default &#x3D; &quot;&quot;): string {
        if (column) {
            return column.name;
        }
        return _default;
    }

    /**
     * Get the default alias for a column
     *
     * @param column The column
     * @param _default A default alias name to return if the &#x60;column&#x60; is empty or no alias is defined
     */
    getColumnAlias(column?: CCColumn, _default &#x3D; &quot;&quot;): string {
        if (column) {
            const alias &#x3D; this.getColumnDefaultAlias(column);
            if (alias) {
                return alias;
            }
        }
        return _default;
    }

    /**
     * Return a column name from a name which can be an alias
     */
    resolveColumnName(name: string | null | undefined): string {
        const column &#x3D; this.getColumn(name);
        return this.getColumnName(column, name || &quot;&quot;);
    }

    /**
     * Return a column alias from a name which can be an alias
     */
    resolveColumnAlias(name: string | null | undefined): string {
        const column &#x3D; this.getColumn(name);
        return this.getColumnAlias(column, name || &quot;&quot;);
    }

    /**
     * Parse a fielded search expression
     *
     * @param text The expression
     * @param options Options for the parsing
     * @return The parsed {@link Expr} or an error message
     */
    parseExpr(text: string, options?: ExprParserOptions): Expr | string {
        return ExprParser.parse(text, {appService: this, formatService: this.formatService, intlService: this.intlService}, options);
    }

    /**
     * Escape a value for fielded search if necessary. &#x60;Date&#x60; objects are converted to
     * Sinequa system date strings and non-scalars fields are escaped
     * @param field The value&#x27;s field
     * @param value The value
     */
    escapeFieldValue(field: string, value: string | number | Date | boolean | undefined): string {
        if (Utils.isDate(value)) {
            return Utils.toSysDateStr(value);
        }
        value &#x3D; value + &quot;&quot;;
        const column &#x3D; this.getColumn(field);
        if (column &amp;&amp; !AppService.isScalar(column)) {
            // escaoe columns that might contain search operators in them (treating negative numbers as an ignorable edge case)
            return ExprParser.escape(value);
        }
        return value;
    }

    /**
     * Get the label of a column. The plural label is returned for csv-type columns.
     *
     * @param name The name of the column which can be an alias
     * @param _default The default label to return if no label is defined
     */
    getLabel(name: string, _default?: string): string {
        const column &#x3D; this.getColumn(name);
        if (column) {
            const label &#x3D; AppService.isCsv(column) ? column.labelPlural : column.label;
            if (label) {
                return label;
            }
        }
        if (!Utils.isUndefined(_default)) {
            return _default;
        }
        return name;
    }

    /**
     * Get the singular label of a column
     *
     * @param name The name of the column which can be an alias
     * @param _default The default label to return if no label is defined
     */
    getSingularLabel(name: string, _default?: string): string {
        const column &#x3D; this.getColumn(name);
        if (column &amp;&amp; column.label) {
            return column.label;
        }
        if (!Utils.isUndefined(_default)) {
            return _default;
        }
        return name;
    }

    /**
     * Get the plural label of a column
     *
     * @param name The name of the column which can be an alias
     * @param _default The default label to return if no label is defined
     */
    getPluralLabel(name: string, _default?: string): string {
        const column &#x3D; this.getColumn(name);
        if (column &amp;&amp; column.labelPlural) {
            return column.labelPlural;
        }
        if (!Utils.isUndefined(_default)) {
            return _default;
        }
        return name;
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is a string
     */
    isString(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isString(column);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is a csv
     */
    isCsv(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isCsv(column);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is a tree
     */
    isTree(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isTree(column);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is an entity
     */
    isEntity(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isEntity(column);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is a boolean
     */
    isBoolean(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isBoolean(column);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is a date
     */
    isDate(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isDate(column);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is a double
     */
    isDouble(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isDouble(column);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is an integer
     */
    isInteger(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isInteger(column);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is a number (integer or double)
     */
    isNumber(name: string): boolean {
        return this.isInteger(name) || this.isDouble(name);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is a scalar
     */
    isScalar(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isScalar(column);
    }

    /**
     * Return &#x60;true&#x60; if a column with the passed name or alias is sortable
     */
    isSortable(name: string): boolean {
        const column &#x3D; this.getColumn(name);
        return !!column &amp;&amp; AppService.isSortable(column);
    }

    /**
     * If the passed url is relative and CORS is active then
     * prepend it with the Sinequa server origin
     */
    updateUrlForCors(url: string): string {
        if (this.startConfig.corsActive &amp;&amp; !!url &amp;&amp; !Utils.isUrlAbsolute(url)) {
            url &#x3D; Utils.addUrl(this.origin, url);
        }
        return url;
    }

    /**
     * Return the url to the Sinequa administration console
     */
    get adminUrl(): string {
        return this.updateUrlForCors(Utils.addUrl(this.startConfig.applicationPath!, &quot;admin&quot;));
    }
}</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'AppEvent.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
