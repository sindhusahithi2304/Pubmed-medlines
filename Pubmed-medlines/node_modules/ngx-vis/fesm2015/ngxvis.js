import { __decorate } from 'tslib';
import { CommonModule } from '@angular/common';
import { EventEmitter, Injectable, ElementRef, Input, Output, Directive, NgZone, NgModule, CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA } from '@angular/core';
import { Network } from 'vis-network';
export { DataSet } from 'vis-network';
import { Timeline } from 'vis-timeline';

/**
 * A service to create, manage and control Network instances.
 *
 * @export
 * @class NetworkService
 */
let VisNetworkService = class VisNetworkService {
    /**
     * A service to create, manage and control Network instances.
     *
     * @export
     * @class NetworkService
     */
    constructor() {
        /**
         * Fired when the user clicks the mouse or taps on a touchscreen device.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.click = new EventEmitter();
        /**
         * Fired when the user double clicks the mouse or double taps on a touchscreen device.
         * Since a double click is in fact 2 clicks, 2 click events are fired, followed by a double click event.
         * If you do not want to use the click events if a double click event is fired,
         * just check the time between click events before processing them.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.doubleClick = new EventEmitter();
        /**
         * Fired when the user click on the canvas with the right mouse button.
         * The right mouse button does not select by default.
         * You can use the method getNodeAt to select the node if you want.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.oncontext = new EventEmitter();
        /**
         * Fired when the user clicks and holds the mouse or taps and holds on a touchscreen device.
         * A click event is also fired in this case.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hold = new EventEmitter();
        /**
         * Fired after drawing on the canvas has been completed.
         * Can be used to draw on top of the network.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.release = new EventEmitter();
        /**
         * Fired when the selection has changed by user action.
         * This means a node or edge has been selected, added to the selection or deselected.
         * All select events are only triggered on click and hold.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.select = new EventEmitter();
        /**
         * Fired when a node has been selected by the user.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.selectNode = new EventEmitter();
        /**
         * Fired when a edge has been selected by the user.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.selectEdge = new EventEmitter();
        /**
         * Fired when a node (or nodes) has (or have) been deselected by the user.
         * The previous selection is the list of nodes and edges that were selected before the last user event.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.deselectNode = new EventEmitter();
        /**
         * Fired when a edge (or edges) has (or have) been deselected by the user.
         * The previous selection is the list of nodes and edges that were selected before the last user event.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.deselectEdge = new EventEmitter();
        /**
         * Fired when starting a drag.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.dragStart = new EventEmitter();
        /**
         * Fired when dragging node(s) or the view.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.dragging = new EventEmitter();
        /**
         * Fired when the drag has finished.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.dragEnd = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over a node.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hoverNode = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and
         * the mouse moved away from a node it was hovering over before.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.blurNode = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over an edge.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hoverEdge = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and
         * the mouse moved away from an edge it was hovering over before.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.blurEdge = new EventEmitter();
        /**
         * Fired when the user zooms in or out.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.zoom = new EventEmitter();
        /**
         * Fired when the popup (tooltip) is shown.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.showPopup = new EventEmitter();
        /**
         * Fired when the popup (tooltip) is hidden.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hidePopup = new EventEmitter();
        /**
         * Fired when stabilization starts.
         * This is also the case when you drag a node and the physics
         * simulation restarts to stabilize again.
         * Stabilization does not neccesarily imply 'without showing'.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.startStabilizing = new EventEmitter();
        /**
         * Fired when a multiple of the updateInterval number of iterations is reached.
         * This only occurs in the 'hidden' stabilization.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.stabilizationProgress = new EventEmitter();
        /**
         * Fired when the 'hidden' stabilization finishes.
         * This does not necessarily mean the network is stabilized;
         * it could also mean that the amount of iterations defined in the options has been reached.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.stabilizationIterationsDone = new EventEmitter();
        /**
         * Fired when the 'hidden' stabilization finishes.
         * This does not necessarily mean the network is stabilized;
         * it could also mean that the amount of iterations defined in the options has been reached.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.stabilized = new EventEmitter();
        /**
         * Fired when the size of the canvas has been resized,
         * either by a redraw call when the container div has changed in size,
         * a setSize() call with new values or a setOptions() with new width and/or height values.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.resize = new EventEmitter();
        /**
         * Fired before the redrawing begins.
         * The simulation step has completed at this point.
         * Can be used to move custom elements before starting drawing the new frame.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.initRedraw = new EventEmitter();
        /**
         * Fired after the canvas has been cleared, scaled and translated to
         * the viewing position but before all edges and nodes are drawn.
         * Can be used to draw behind the network.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.beforeDrawing = new EventEmitter();
        /**
         * Fired after drawing on the canvas has been completed.
         * Can be used to draw on top of the network.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.afterDrawing = new EventEmitter();
        /**
         * Fired when an animation is finished.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.animationFinished = new EventEmitter();
        /**
         * Fired when a user changes any option in the configurator.
         * The options object can be used with the setOptions method or stringified using JSON.stringify().
         * You do not have to manually put the options into the network: this is done automatically.
         * You can use the event to store user options in the database.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.configChange = new EventEmitter();
        this.networks = {};
    }
    /**
     * Creates a new network instance.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {HTMLElement} container The HTML element that contains the network view.
     * @param {Data} data The initial network nodes and edges.
     * @param {Options} [options] The network options.
     *
     * @throws {Error} Thrown when a network with the same name already exists.
     *
     * @memberOf NetworkService
     */
    create(visNetwork, container, data, options) {
        if (this.networks[visNetwork]) {
            throw new Error(`Network with id ${visNetwork} already exists.`);
        }
        this.networks[visNetwork] = new Network(container, data, options);
    }
    /**
     * Remove the network from the DOM and remove all Hammer bindings and references.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @memberOf NetworkService
     */
    destroy(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].destroy();
            delete this.networks[visNetwork];
        }
    }
    /**
     * Activates an event.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {NetworkEvents} eventName The event name.
     * @param {boolean} preventDefault Stops the default behavior of the event.
     * @returns {boolean} Returns true when the event was activated.
     *
     * @memberOf NetworkService
     */
    on(visNetwork, eventName, preventDefault) {
        if (this.networks[visNetwork]) {
            /* tslint:disable */
            const that = this;
            /* tslint:enable */
            this.networks[visNetwork].on(eventName, (params) => {
                const emitter = that[eventName];
                if (emitter) {
                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);
                }
                if (preventDefault && params.event) {
                    params.event.preventDefault();
                }
            });
            return true;
        }
        return false;
    }
    /**
     * Deactivates an event.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {NetworkEvents} eventName The event name.
     *
     * @memberOf NetworkService
     */
    off(visNetwork, eventName) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].off(eventName);
        }
    }
    /**
     * Activates an event listener only once.
     * After it has taken place, the event listener will be removed.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {NetworkEvents} eventName The event name.
     * @returns {boolean} Returns true when the event was activated.
     *
     * @memberOf NetworkService
     */
    once(visNetwork, eventName) {
        if (this.networks[visNetwork]) {
            /* tslint:disable */
            const that = this;
            /* tslint:disable */
            this.networks[visNetwork].on(eventName, (params) => {
                const emitter = that[eventName];
                if (emitter) {
                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);
                    this.off(visNetwork, eventName);
                }
            });
            return true;
        }
        return false;
    }
    /**
     * Override all the data in the network.
     * If stabilization is enabled in the physics module,
     * the network will stabilize again.
     * This method is also performed when first initializing the network.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Data} data The network data.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    setData(visNetwork, data) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].setData(data);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Set the options.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Options} options The network options.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    setOptions(visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].setOptions(options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Selects the nodes corresponding to the id's in the input array.
     * This method unselects all other objects before selecting its own objects.
     * Does not fire events.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType[]} nodeIds The node ids that should be selected.
     * @param {boolean} [highlightEdges] If highlightEdges is true or undefined,
     *                                   the neighbouring edges will also be selected.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    selectNodes(visNetwork, nodeIds, highlightEdges) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].selectNodes(nodeIds, highlightEdges);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Selects the nodes and edges corresponding to the id's in the input arrays.
     * Does not fire events.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param { nodes: IdType[], edges: IdType[] } selection The node and edge ids that should be selected.
     * @param { unselectAll?: boolean, highlightEdges?: boolean } [options]
     * If unselectAll is true or undefined, the other objects will be deselected.
     * If highlightEdges is true or undefined, the neighbouring edges will also be selected.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    setSelection(visNetwork, selection, options = {}) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].setSelection(selection, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Returns an object with selected nodes and edges ids.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {{ nodes: IdType[], edges: IdType[] }}
     * The selected node and edge ids or undefined when the network does not exist.
     *
     * @memberOf NetworkService
     */
    getSelection(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSelection();
        }
        return undefined;
    }
    /**
     * Returns an array of selected node ids.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {IdType[]} The selected node ids or undefined when the network does not exist.
     *
     * @memberOf NetworkService
     */
    getSelectedNodes(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSelectedNodes();
        }
        return undefined;
    }
    /**
     * Returns an array of selected edge ids.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {IdType[]} The selected edge ids or undefined when the network does not exist.
     *
     * @memberOf NetworkService
     */
    getSelectedEdges(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSelectedEdges();
        }
        return undefined;
    }
    /**
     * Unselect all objects.
     * Does not fire events.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    unselectAll(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].unselectAll();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Zooms out so all nodes fit on the canvas.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {VisFitOptions} [options] Options to customize.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    fit(visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].fit(options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Redraw the network.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    redraw(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].redraw();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Go into addNode mode. Having edit mode or manipulation enabled is not required.
     * To get out of this mode, call disableEditMode(). The callback functions defined in handlerFunctions still apply.
     * To use these methods without having the manipulation GUI, make sure you set enabled to false.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    addNodeMode(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].addNodeMode();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Programatically enable the edit mode.
     * Similar effect to pressing the edit button.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    enableEditMode(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].enableEditMode();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Go into addEdge mode.
     * The explaination from addNodeMode applies here as well.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    addEdgeMode(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].addEdgeMode();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Programatically disable the edit mode.
     * Similar effect to pressing the close icon
     * (small cross in the corner of the toolbar).
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    disableEditMode(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].disableEditMode();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Delete selected.
     * Having edit mode or manipulation enabled is not required.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    deleteSelected(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].deleteSelected();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Makes a cluster.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {ClusterOptions} [options] The joinCondition function is presented with all nodes.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    cluster(visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].cluster(options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * This method looks at the provided node and makes a cluster of it and all it's connected nodes.
     * The behaviour can be customized by proving the options object.
     * All options of this object are explained below.
     * The joinCondition is only presented with the connected nodes.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId the id of the node
     * @param {ClusterOptions} [options] the cluster options
     *
     * @memberOf NetworkService
     */
    clusterByConnection(visNetwork, nodeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].clusterByConnection(nodeId, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * This method checks all nodes in the network and those with a equal or higher
     * amount of edges than specified with the hubsize qualify.
     * If a hubsize is not defined, the hubsize will be determined as the average
     * value plus two standard deviations.
     * For all qualifying nodes, clusterByConnection is performed on each of them.
     * The options object is described for clusterByConnection and does the same here.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {number} [hubsize] optional hubsize
     * @param {ClusterOptions} [options] optional cluster options
     *
     * @memberOf NetworkService
     */
    clusterByHubsize(visNetwork, hubsize, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].clusterByHubsize(hubsize, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * This method will cluster all nodes with 1 edge with their respective connected node.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {ClusterOptions} [options] optional cluster options
     *
     * @memberOf NetworkService
     */
    clusterOutliers(visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].clusterOutliers(options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Nodes can be in clusters.
     * Clusters can also be in clusters.
     * This function returns an array of nodeIds showing where the node is.
     *
     * Example:
     * cluster 'A' contains cluster 'B', cluster 'B' contains cluster 'C',
     * cluster 'C' contains node 'fred'.
     *
     * network.clustering.findNode('fred') will return ['A','B','C','fred'].
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId the node id.
     * @returns {IdType[]} an array of nodeIds showing where the node is
     *
     * @memberOf NetworkService
     */
    findNode(visNetwork, nodeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].findNode(nodeId);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Similar to findNode in that it returns all the edge ids that were
     * created from the provided edge during clustering.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} baseEdgeId the base edge id
     * @returns {IdType[]} an array of edgeIds
     *
     * @memberOf NetworkService
     */
    getClusteredEdges(visNetwork, baseEdgeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getClusteredEdges(baseEdgeId);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * When a clusteredEdgeId is available, this method will return the original
     * baseEdgeId provided in data.edges ie.
     * After clustering the 'SelectEdge' event is fired but provides only the clustered edge.
     * This method can then be used to return the baseEdgeId.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} clusteredEdgeId
     * @returns {IdType}
     *
     * @memberOf NetworkService
     *
     */
    getBaseEdge(visNetwork, clusteredEdgeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getBaseEdge(clusteredEdgeId);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Visible edges between clustered nodes are not the same edge as the ones provided
     * in data.edges passed on network creation. With each layer of clustering, copies of
     * the edges between clusters are created and the previous edges are hidden,
     * until the cluster is opened. This method takes an edgeId (ie. a base edgeId from data.edges)
     * and applys the options to it and any edges that were created from it while clustering.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} startEdgeId
     * @param {VisEdgeOptions} [options]
     *
     * @memberOf NetworkService
     *
     */
    updateEdge(visNetwork, startEdgeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].updateEdge(startEdgeId, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Clustered Nodes when created are not contained in the original data.nodes
     * passed on network creation. This method updates the cluster node.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} clusteredNodeId
     * @param {NodeOptions} options
     *
     * @memberOf NetworkService
     */
    updateClusteredNode(visNetwork, clusteredNodeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].updateClusteredNode(clusteredNodeId, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Returns an array of all nodeIds of the nodes that
     * would be released if you open the cluster.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} clusterNodeId the id of the cluster node
     * @returns {IdType[]}
     *
     * @memberOf NetworkService
     */
    getNodesInCluster(visNetwork, clusterNodeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getNodesInCluster(clusterNodeId);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Opens the cluster, releases the contained nodes and edges,
     * removing the cluster node and cluster edges.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId The node id that represents the cluster.
     * @param {OpenClusterOptions} [options] Cluster options.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    openCluster(visNetwork, nodeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].openCluster(nodeId, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Returns true if the node whose ID has been supplied is a cluster.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId The associated node id.
     * @returns {boolean} True if the node whose ID has been supplied is a cluster.
     *
     * @memberOf NetworkService
     */
    isCluster(visNetwork, nodeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].isCluster(nodeId);
        }
        return false;
    }
    /**
     * If you like the layout of your network and would like it to start in the same way next time,
     * ask for the seed using this method and put it in the layout.randomSeed option.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {number} The seed of the current network or -1 when the network is not defined.
     *
     * @memberOf NetworkService
     */
    getSeed(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSeed();
        }
        return -1;
    }
    /**
     * This function converts canvas coordinates to coordinates on the DOM.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The canvas position.
     * @returns {Position} The DOM position.
     *
     * @memberOf NetworkService
     */
    canvasToDOM(visNetwork, position) {
        return this.networks[visNetwork].canvasToDOM(position);
    }
    /**
     * This function converts DOM coordinates to coordinates on the canvas.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The DOM position.
     * @returns {Position} The canvas position.
     *
     * @memberOf NetworkService
     */
    DOMtoCanvas(visNetwork, position) {
        return this.networks[visNetwork].DOMtoCanvas(position);
    }
    /**
     * This function looks up the node at the given DOM coordinates on the canvas.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container -> DOM not Canvas coords.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The DOM position.
     * @returns {IdType} nodeId The associated node id.
     *
     * @memberOf NetworkService
     */
    getNodeAt(visNetwork, position) {
        return this.networks[visNetwork].getNodeAt(position);
    }
    /**
     * This function looks up the edge at the given DOM coordinates on the canvas.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container -> DOM not Canvas coords.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The DOM position.
     * @returns {IdType} edgeId The associated edge id.
     *
     * @memberOf NetworkService
     */
    getEdgeAt(visNetwork, position) {
        return this.networks[visNetwork].getEdgeAt(position);
    }
    /**
     * This function looks up the edges for a given nodeId.
     * The DOM values are relative to the network container -> DOM not Canvas coords.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId The associated node id.
     * @returns {IdType[]} Return array of edge ids
     *
     * @memberOf NetworkService
     */
    getConnectedEdges(visNetwork, nodeId) {
        return this.networks[visNetwork].getConnectedEdges(nodeId);
    }
    /**
     * Returns an array of nodeIds of the all the nodes that are directly connected to this node.
     * If you supply an edgeId, vis will first match the id to nodes.
     * If no match is found, it will search in the edgelist and return an array: [fromId, toId].
     *
     * @param {string} visNetwork The network name/identifier.
     * @param nodeOrEdgeId a node or edge id
     * @returns {IdType[]} Return array of node ids
     */
    getConnectedNodes(visNetwork, nodeOrEdgeId) {
        return this.networks[visNetwork].getConnectedNodes(nodeOrEdgeId);
    }
    /**
     * Returns the positions of the nodes.
     * @param {string} visNetwork The network name/identifier.
     * @param {Array.<Node.id>|String} [ids]  --> optional, can be array of nodeIds, can be string
     * @returns {{}}
     */
    getPositions(visNetwork, nodeIds) {
        return this.networks[visNetwork].getPositions(nodeIds);
    }
    /**
     * Returns the positions of the nodes.
     * @param {string} visNetwork The network name/identifier.
     */
    getBoundingBox(visNetwork, nodeId) {
        return this.networks[visNetwork].getBoundingBox(nodeId);
    }
    /**
     * Returns the positions of the nodes.
     * @param {string} visNetwork The network name/identifier.
     */
    storePositions(visNetwork) {
        return this.networks[visNetwork].storePositions();
    }
    /**
     * You can animate or move the camera using the moveTo method.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {MoveToOptions} options Options for moveTo function.
     */
    moveTo(visNetwork, moveToOptions) {
        return this.networks[visNetwork].moveTo(moveToOptions);
    }
    /**
     * Start the physics simulation.
     * This is normally done whenever needed and is only really useful
     * if you stop the simulation yourself and wish to continue it afterwards.
     * @param {string} visNetwork The network name/identifier.
     */
    startSimulation(visNetwork) {
        return this.networks[visNetwork].startSimulation();
    }
    /**
     * This stops the physics simulation and triggers a stabilized event.
     * Tt can be restarted by dragging a node,
     * altering the dataset or calling startSimulation().
     * @param {string} visNetwork The network name/identifier.
     */
    stopSimulation(visNetwork) {
        return this.networks[visNetwork].stopSimulation();
    }
    /**
     * Returns the current scale of the network. 1.0 is comparible to 100%, 0 is zoomed out infinitely.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    getScale(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getScale();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
};
VisNetworkService = __decorate([
    Injectable()
], VisNetworkService);

/**
 * Use this directive with a div container to show network data.
 *
 * @export
 * @class VisNetworkDirective
 * @implements {OnInit}
 * @implements {OnDestroy}
 * @implements {OnChanges}
 */
let VisNetworkDirective = class VisNetworkDirective {
    /**
     * Creates an instance of VisNetworkDirective.
     *
     * @param {ElementRef} elementRef The HTML element reference.
     * @param {VisNetworkService} visNetworkService The VisNetworkService.
     *
     * @memberOf VisNetworkDirective
     */
    constructor(elementRef, visNetworkService) {
        this.elementRef = elementRef;
        this.visNetworkService = visNetworkService;
        /**
         * This event will be raised when the network is initialized.
         * At this point of time the network is successfully registered
         * with the VisNetworkService and you can register to events.
         * The event data is the name of the network as a string.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisNetworkDirective
         */
        this.initialized = new EventEmitter();
        this.isInitialized = false;
        this.visNetworkContainer = elementRef.nativeElement;
    }
    /**
     * Create the network when at least visNetwork and visData
     * are defined.
     *
     * @memberOf VisNetworkDirective
     */
    ngOnInit() {
        if (!this.isInitialized && this.visNetwork && this.visNetworkData) {
            this.createNetwork();
        }
    }
    /**
     * Update the network data or options on reference changes to
     * the visData or visOptions properties.
     *
     * @param {{[propName: string]: SimpleChange}} changes
     *
     * @memberOf VisNetworkDirective
     */
    ngOnChanges(changes) {
        if (!this.isInitialized && this.visNetwork && this.visNetworkData) {
            this.createNetwork();
        }
        for (const propertyName in changes) {
            if (changes.hasOwnProperty(propertyName)) {
                const change = changes[propertyName];
                if (!change.isFirstChange()) {
                    if (propertyName === 'visData') {
                        this.visNetworkService.setData(this.visNetwork, changes[propertyName].currentValue);
                    }
                    if (propertyName === 'visOptions') {
                        this.visNetworkService.setOptions(this.visNetwork, changes[propertyName].currentValue);
                    }
                }
            }
        }
    }
    /**
     * Calls the destroy function for this network instance.
     *
     * @memberOf VisNetworkDirective
     */
    ngOnDestroy() {
        this.isInitialized = false;
        this.visNetworkService.destroy(this.visNetwork);
    }
    createNetwork() {
        this.visNetworkService.create(this.visNetwork, this.visNetworkContainer, this.visNetworkData, this.visNetworkOptions);
        this.isInitialized = true;
        this.initialized.emit(this.visNetwork);
    }
};
VisNetworkDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: VisNetworkService }
];
__decorate([
    Input('visNetwork')
], VisNetworkDirective.prototype, "visNetwork", void 0);
__decorate([
    Input()
], VisNetworkDirective.prototype, "visNetworkData", void 0);
__decorate([
    Input()
], VisNetworkDirective.prototype, "visNetworkOptions", void 0);
__decorate([
    Output()
], VisNetworkDirective.prototype, "initialized", void 0);
VisNetworkDirective = __decorate([
    Directive({
        selector: '[visNetwork]'
    })
], VisNetworkDirective);

/**
 * A service to create, manage and control VisTimeline instances.
 *
 * @export
 * @class VisTimelineService
 */
let VisTimelineService = class VisTimelineService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        /**
         * Fired when the current time bar redraws.
         * The rate depends on the zoom level.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.currentTimeTick = new EventEmitter();
        /**
         * Fired when clicked inside the Timeline.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.click = new EventEmitter();
        /**
         * Fired when right-clicked inside the Timeline.
         * Note that in order to prevent the context menu from showing up,
         * default behavior of the event must be stopped.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.contextmenu = new EventEmitter();
        /**
         * Fired when double clicked inside the Timeline.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.doubleClick = new EventEmitter();
        /**
         * 	Fired after the dragging of a group is finished.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.groupDragged = new EventEmitter();
        /**
         * Fired once after each graph redraw.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.changed = new EventEmitter();
        /**
         * Fired repeatedly when the timeline window is being changed.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.rangechange = new EventEmitter();
        /**
         * Fired once after the timeline window has been changed.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.rangechanged = new EventEmitter();
        /**
         * Fired after the user selects or deselects items by tapping or holding them.
         * When a use taps an already selected item, the select event is fired again.
         * Not fired when the method setSelectionis executed.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.select = new EventEmitter();
        /**
         * Fired when the user moves the mouse over an item.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.itemover = new EventEmitter();
        /**
         * Fired when the user moves the mouse out of an item.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.itemout = new EventEmitter();
        /**
         * Fired repeatedly when the user is dragging the custom time bar.
         * Only available when the custom time bar is enabled.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.timechange = new EventEmitter();
        /**
         * Fired once after the user has dragged the custom time bar.
         * Only available when the custom time bar is enabled.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineService
         */
        this.timechanged = new EventEmitter();
        this.events = new Map();
        this.timelines = {};
    }
    /**
     * Creates a new timeline instance.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {HTMLElement} container The HTML element that contains the timeline view.
     * @param {VisTimelineItems} items The initial timeline items.
     * @param {VisTimelineOptions} [options] The timeline options.
     *
     * @throws {Error} Thrown when timeline already exists.
     *
     * @memberOf VisTimelineService
     */
    createWithItems(visTimeline, container, items, options) {
        if (this.timelines[visTimeline]) {
            throw new Error(this.alreadyExistsError(visTimeline));
        }
        this.timelines[visTimeline] = this.ngZone.runOutsideAngular(() => new Timeline(container, items, options));
    }
    /**
     * Creates a new timeline instance.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {HTMLElement} container The HTML element that contains the timeline view.
     * @param {VisTimelineItems} items The initial timeline items.
     * @param {VisTimelineGroups} groups The initial timeline groups.
     * @param {VisTimelineOptions} [options] The timeline options.
     *
     * @throws {Error} Thrown when timeline already exists.
     *
     * @memberOf VisTimelineService
     */
    createWithItemsAndGroups(visTimeline, container, items, groups, options) {
        if (this.timelines[visTimeline]) {
            throw new Error(this.alreadyExistsError(visTimeline));
        }
        this.timelines[visTimeline] = this.ngZone.runOutsideAngular(() => new Timeline(container, items, groups, options));
    }
    /**
     * Add new vertical bar representing a custom time that can be dragged by the user.
     * The id is added as CSS class name of the custom time bar,
     * allowing to style multiple time bars differently.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {DateType} time Parameter time can be a Date, Number, or String, and is new Date() by default.
     * @param {IdType} [id] Parameter id can be Number or String and is undefined by default.
     * @returns {IdType} The method returns id of the created bar.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    addCustomTime(visTimeline, time, id) {
        if (this.timelines[visTimeline]) {
            return this.timelines[visTimeline].addCustomTime(time, id);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Adjust the visible window such that it fits all items.
     * See also function focus(id).
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {TimelineAnimationOptions} [options] Optional options.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    fit(visTimeline, options) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].fit(options);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Adjust the visible window such that the selected item is centered on screen.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {IdType} id The id of the item.
     * @param {TimelineAnimationOptions} [options] Options options.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    focusOnId(visTimeline, id, options) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].focus(id, options);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Adjust the visible window such that the selected items are centered on screen.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {IdType[]} ids The item ids.
     * @param {TimelineAnimationOptions} [options] Optional options.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    focusOnIds(visTimeline, ids, options) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].focus(ids, options);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Get the current time.
     * Only applicable when option showCurrentTime is true.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @returns {Date} The current time.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    getCurrentTime(visTimeline) {
        if (this.timelines[visTimeline]) {
            return this.timelines[visTimeline].getCurrentTime();
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Retrieve the custom time from the custom time bar with given id.
     * Id is undefined by default.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {IdType} [id] The time bar id.
     * @returns {Date} The custom time.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    getCustomTime(visTimeline, id) {
        if (this.timelines[visTimeline]) {
            return this.timelines[visTimeline].getCustomTime(id);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Returns an Object with relevant properties from an event.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {Event} event The event.
     * @returns {VisTimelineEventPropertiesResult} Properties of an event
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    getEventProperties(visTimeline, event) {
        if (this.timelines[visTimeline]) {
            return this.timelines[visTimeline].getEventProperties(event);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Get the range of all the items as an object containing min: Date and max: Date.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @returns {{ min: Date, max: Date }} The min and max dates.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    getItemRange(visTimeline) {
        if (this.timelines[visTimeline]) {
            return this.timelines[visTimeline].getItemRange();
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Get an array with the ids of the currently selected items.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @returns {IdType[]} The currently selected items.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    getSelection(visTimeline) {
        if (this.timelines[visTimeline]) {
            return this.timelines[visTimeline].getSelection();
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Get an array with the ids of the currently visible items.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @returns {IdType[]} The currently visible items.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    getVisibleItems(visTimeline) {
        if (this.timelines[visTimeline]) {
            return this.timelines[visTimeline].getVisibleItems();
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Get the current visible window.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @returns {{ start: Date, end: Date }} Returns an object with properties start: Date and end: Date.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    getWindow(visTimeline) {
        if (this.timelines[visTimeline]) {
            return this.timelines[visTimeline].getWindow();
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * 	Move the window such that given time is centered on screen.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {DateType} time Parameter time can be a Date, Number, or String.
     * @param {TimelineAnimationOptions} [options] Optional options.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    moveTo(visTimeline, time, options) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].moveTo(time, options);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Force a redraw of the Timeline.
     * The size of all items will be recalculated.
     * Can be useful to manually redraw when option autoResize=false and the window has been resized,
     * or when the items CSS has been changed.
     *
     * @param {string} visTimeline The timeline name/identifier.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    redraw(visTimeline) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].redraw();
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Remove vertical bars previously added to the timeline via addCustomTime method.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {IdType} id Parameter id is the ID of the custom vertical bar returned by addCustomTime method.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    removeCustomTime(visTimeline, id) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].removeCustomTime(id);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Set a current time.
     * This can be used for example to ensure that a client's time is synchronized
     * with a shared server time.
     * Only applicable when option showCurrentTime is true.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {DateType} time time can be a Date object, numeric timestamp, or ISO date string.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setCurrentTime(visTimeline, time) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setCurrentTime(time);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * 	Adjust the time of a custom time bar.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {DateType} time Parameter time can be a Date object, numeric timestamp, or ISO date string.
     * @param {IdType} [id] Parameter id is the id of the custom time bar, and is undefined by default.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setCustomTime(visTimeline, time, id) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setCustomTime(time, id);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Adjust the title attribute of a custom time bar.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {string} title Parameter title is the string to be set as title.
     *                       Use empty string to hide the title completely.
     * @param {IdType} [id] Parameter id is the id of the custom time bar, and is undefined by default.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setCustomTimeTitle(visTimeline, title, id) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setCustomTimeTitle(title, id);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Set both groups and items at once.
     * Both properties are optional.
     * This is a convenience method for individually calling both setItems(items) and setGroups(groups).
     * Both items and groups can be an Array with Objects, a DataSet (offering 2 way data binding),
     * or a DataView (offering 1 way data binding).
     * For each of the groups, the items of the timeline are filtered on the property group,
     * which must correspond with the id of the group.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {{ groups?: VisTimelineGroups; items?: VisTimelineItems }} data The new timline data.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setData(visTimeline, data) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setData(data);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Set a data set with groups for the Timeline.
     * For each of the groups, the items of the timeline are filtered on the property group,
     * which must correspond with the id of the group.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {VisTimelineGroups} groups a DataSet (offering 2 way data binding)
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setGroups(visTimeline, groups) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setGroups(groups);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Set a data set with items for the Timeline.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {VisTimelineItems} items can be an Array with Objects, a DataSet (offering 2 way data binding)
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setItems(visTimeline, items) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setItems(items);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Set or update options.
     * It is possible to change any option of the timeline at any time.
     * You can for example switch orientation on the fly.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {VisTimelineOptions} options The new options of the timeline.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setOptions(visTimeline, options) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setOptions(options);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Select one item by its id.#
     * The currently selected items will be unselected.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {IdType} id The id of the item that should be selected.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setSelectionToId(visTimeline, id) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setSelection(id);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Select multiple items by their id.
     * The currently selected items will be unselected.
     * To unselect all selected items, call `setSelection([])`.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {IdType[]} ids The ids of the irems that should be selected.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setSelectionToIds(visTimeline, ids) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setSelection(ids);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Set the current visible window.
     *
     * If the parameter value of start or end is null, the parameter will be left unchanged.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {DateType} start The parameters start can be a Date, Number, or String.
     * @param {DateType} end The parameters end can be a Date, Number, or String.
     * @param {TimelineAnimationOptions} [options] Optional options.
     *
     * @throws {Error} Thrown when timeline does not exist.
     *
     * @memberOf VisTimelineService
     */
    setWindow(visTimeline, start, end, options) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].setWindow(start, end, options);
        }
        else {
            throw new Error(this.doesNotExistError(visTimeline));
        }
    }
    /**
     * Destroy the Timeline.
     * The timeline is removed from memory.
     * All DOM elements and event listeners are cleaned up.
     *
     * @param {string} visTimeline The timeline name/identifier.
     *
     * @memberOf VisTimelineService
     */
    destroy(visTimeline) {
        if (this.timelines[visTimeline]) {
            this.timelines[visTimeline].destroy();
            delete this.timelines[visTimeline];
        }
    }
    /**
     * Activates an event.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {string} eventName The event name.
     * @param {boolean} preventDefault Stops the default behavior of the event.
     * @returns {boolean} Returns true when the event was activated.
     *
     * @memberOf VisTimelineService
     */
    on(visTimeline, eventName, preventDefault) {
        if (this.timelines[visTimeline]) {
            this.events.set(eventName, new EventEmitter());
            // tslint:disable-next-line
            const that = this;
            this.timelines[visTimeline].on(eventName, (params) => {
                const emitter = (that[eventName] || that.events.get(eventName));
                if (emitter) {
                    emitter.emit(params ? [visTimeline].concat(params) : visTimeline);
                }
                if (preventDefault && params.event) {
                    params.event.preventDefault();
                }
            });
            return true;
        }
        return false;
    }
    /**
     * Deactivates an event.
     *
     * @param {string} visTimeline The timeline name/identifier.
     * @param {string} eventName The event name.
     *
     * @memberOf VisTimelineService
     */
    off(visTimeline, eventName) {
        if (this.timelines[visTimeline]) {
            this.events.delete(eventName);
            this.timelines[visTimeline].off(eventName, undefined);
        }
    }
    /**
     * Get the event emitter associated with the specified event name.
     * @param {string} eventName The event name.
     * @returns {EventEmitter<any>} The event emitter of the specified event name.
     */
    getEmitter(eventName) {
        return this.events.get(eventName);
    }
    doesNotExistError(visTimeline) {
        return `Timeline with id ${visTimeline} does not exist.`;
    }
    alreadyExistsError(visTimeline) {
        return `Timeline with id ${visTimeline} already exists.`;
    }
};
VisTimelineService.ctorParameters = () => [
    { type: NgZone }
];
VisTimelineService = __decorate([
    Injectable()
], VisTimelineService);

/**
 * Use this directive with a div container to show timeline data.
 *
 * @export
 * @class VisTimelineDirective
 * @implements {OnInit}
 * @implements {OnDestroy}
 * @implements {OnChanges}
 */
let VisTimelineDirective = class VisTimelineDirective {
    /**
     * Creates an instance of VisTimelineDirective.
     *
     * @param {ElementRef} elementRef The HTML element reference.
     * @param {VisTimelineService} visTimelineService The VisTimelineService.
     *
     * @memberOf VisTimelineDirective
     */
    constructor(elementRef, visTimelineService) {
        this.elementRef = elementRef;
        this.visTimelineService = visTimelineService;
        /**
         * This event will be raised when the timline is initialized.
         * At this point of time the timeline is successfully registered
         * with the VisNetworkService and you can register to events.
         * The event data is the name of the timeline as a string.
         *
         * @type {EventEmitter<any>}
         * @memberOf VisTimelineDirective
         */
        this.initialized = new EventEmitter();
        this.isInitialized = false;
        this.visTimelineContainer = elementRef.nativeElement;
    }
    /**
     * Create the timeline when at least visNetwork and visNetworkData
     * are defined.
     *
     * @memberOf VisTimelineDirective
     */
    ngOnInit() {
        if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {
            this.createTimeline();
        }
    }
    /**
     * Update the timeline data, groups or options on reference changes to
     * the visTimelineItems, visTimelineGroups or visTimelineOptions properties.
     *
     * @param {{[propName: string]: SimpleChange}} changes
     *
     * @memberOf VisTimelineDirective
     */
    ngOnChanges(changes) {
        if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {
            this.createTimeline();
        }
        for (const propertyName in changes) {
            if (changes.hasOwnProperty(propertyName)) {
                const change = changes[propertyName];
                if (!change.isFirstChange()) {
                    if (propertyName === 'visTimelineItems') {
                        this.visTimelineService.setItems(this.visTimeline, changes[propertyName].currentValue);
                    }
                    if (propertyName === 'visTimelineOptions') {
                        this.visTimelineService.setOptions(this.visTimeline, changes[propertyName].currentValue);
                    }
                    if (propertyName === 'visTimelineGroups') {
                        this.visTimelineService.setGroups(this.visTimeline, changes[propertyName].currentValue);
                    }
                }
            }
        }
    }
    /**
     * Calls the destroy function for this timeline instance.
     *
     *
     * @memberOf VisTimelineDirective
     */
    ngOnDestroy() {
        this.isInitialized = false;
        this.visTimelineService.destroy(this.visTimeline);
    }
    createTimeline() {
        if (this.visTimelineGroups) {
            this.visTimelineService.createWithItemsAndGroups(this.visTimeline, this.visTimelineContainer, this.visTimelineItems, this.visTimelineGroups, this.visTimelineOptions);
        }
        else {
            this.visTimelineService.createWithItems(this.visTimeline, this.visTimelineContainer, this.visTimelineItems, this.visTimelineOptions);
        }
        this.isInitialized = true;
        this.initialized.emit(this.visTimeline);
    }
};
VisTimelineDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: VisTimelineService }
];
__decorate([
    Input('visTimeline')
], VisTimelineDirective.prototype, "visTimeline", void 0);
__decorate([
    Input()
], VisTimelineDirective.prototype, "visTimelineItems", void 0);
__decorate([
    Input()
], VisTimelineDirective.prototype, "visTimelineGroups", void 0);
__decorate([
    Input()
], VisTimelineDirective.prototype, "visTimelineOptions", void 0);
__decorate([
    Output()
], VisTimelineDirective.prototype, "initialized", void 0);
VisTimelineDirective = __decorate([
    Directive({
        selector: '[visTimeline]'
    })
], VisTimelineDirective);

let VisModule = class VisModule {
};
VisModule = __decorate([
    NgModule({
        declarations: [VisNetworkDirective, VisTimelineDirective],
        exports: [VisNetworkDirective, VisTimelineDirective],
        imports: [CommonModule],
        providers: [VisNetworkService, VisTimelineService],
        schemas: [CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA]
    })
], VisModule);

/**
 * Generated bundle index. Do not edit.
 */

export { VisModule, VisNetworkDirective, VisNetworkService, VisTimelineDirective, VisTimelineService };
//# sourceMappingURL=ngxvis.js.map
