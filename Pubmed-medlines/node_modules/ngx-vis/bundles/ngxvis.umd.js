(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('vis-network'), require('vis-timeline')) :
    typeof define === 'function' && define.amd ? define('ngx-vis', ['exports', '@angular/common', '@angular/core', 'vis-network', 'vis-timeline'], factory) :
    (global = global || self, factory(global['ngx-vis'] = {}, global.ng.common, global.ng.core, global.visNetwork, global.visTimeline));
}(this, (function (exports, common, core, visNetwork, visTimeline) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * A service to create, manage and control Network instances.
     *
     * @export
     * @class NetworkService
     */
    var VisNetworkService = /** @class */ (function () {
        function VisNetworkService() {
            /**
             * Fired when the user clicks the mouse or taps on a touchscreen device.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.click = new core.EventEmitter();
            /**
             * Fired when the user double clicks the mouse or double taps on a touchscreen device.
             * Since a double click is in fact 2 clicks, 2 click events are fired, followed by a double click event.
             * If you do not want to use the click events if a double click event is fired,
             * just check the time between click events before processing them.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.doubleClick = new core.EventEmitter();
            /**
             * Fired when the user click on the canvas with the right mouse button.
             * The right mouse button does not select by default.
             * You can use the method getNodeAt to select the node if you want.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.oncontext = new core.EventEmitter();
            /**
             * Fired when the user clicks and holds the mouse or taps and holds on a touchscreen device.
             * A click event is also fired in this case.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.hold = new core.EventEmitter();
            /**
             * Fired after drawing on the canvas has been completed.
             * Can be used to draw on top of the network.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.release = new core.EventEmitter();
            /**
             * Fired when the selection has changed by user action.
             * This means a node or edge has been selected, added to the selection or deselected.
             * All select events are only triggered on click and hold.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.select = new core.EventEmitter();
            /**
             * Fired when a node has been selected by the user.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.selectNode = new core.EventEmitter();
            /**
             * Fired when a edge has been selected by the user.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.selectEdge = new core.EventEmitter();
            /**
             * Fired when a node (or nodes) has (or have) been deselected by the user.
             * The previous selection is the list of nodes and edges that were selected before the last user event.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.deselectNode = new core.EventEmitter();
            /**
             * Fired when a edge (or edges) has (or have) been deselected by the user.
             * The previous selection is the list of nodes and edges that were selected before the last user event.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.deselectEdge = new core.EventEmitter();
            /**
             * Fired when starting a drag.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.dragStart = new core.EventEmitter();
            /**
             * Fired when dragging node(s) or the view.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.dragging = new core.EventEmitter();
            /**
             * Fired when the drag has finished.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.dragEnd = new core.EventEmitter();
            /**
             * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over a node.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.hoverNode = new core.EventEmitter();
            /**
             * Fired if the option interaction:{hover:true} is enabled and
             * the mouse moved away from a node it was hovering over before.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.blurNode = new core.EventEmitter();
            /**
             * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over an edge.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.hoverEdge = new core.EventEmitter();
            /**
             * Fired if the option interaction:{hover:true} is enabled and
             * the mouse moved away from an edge it was hovering over before.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.blurEdge = new core.EventEmitter();
            /**
             * Fired when the user zooms in or out.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.zoom = new core.EventEmitter();
            /**
             * Fired when the popup (tooltip) is shown.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.showPopup = new core.EventEmitter();
            /**
             * Fired when the popup (tooltip) is hidden.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.hidePopup = new core.EventEmitter();
            /**
             * Fired when stabilization starts.
             * This is also the case when you drag a node and the physics
             * simulation restarts to stabilize again.
             * Stabilization does not neccesarily imply 'without showing'.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.startStabilizing = new core.EventEmitter();
            /**
             * Fired when a multiple of the updateInterval number of iterations is reached.
             * This only occurs in the 'hidden' stabilization.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.stabilizationProgress = new core.EventEmitter();
            /**
             * Fired when the 'hidden' stabilization finishes.
             * This does not necessarily mean the network is stabilized;
             * it could also mean that the amount of iterations defined in the options has been reached.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.stabilizationIterationsDone = new core.EventEmitter();
            /**
             * Fired when the 'hidden' stabilization finishes.
             * This does not necessarily mean the network is stabilized;
             * it could also mean that the amount of iterations defined in the options has been reached.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.stabilized = new core.EventEmitter();
            /**
             * Fired when the size of the canvas has been resized,
             * either by a redraw call when the container div has changed in size,
             * a setSize() call with new values or a setOptions() with new width and/or height values.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.resize = new core.EventEmitter();
            /**
             * Fired before the redrawing begins.
             * The simulation step has completed at this point.
             * Can be used to move custom elements before starting drawing the new frame.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.initRedraw = new core.EventEmitter();
            /**
             * Fired after the canvas has been cleared, scaled and translated to
             * the viewing position but before all edges and nodes are drawn.
             * Can be used to draw behind the network.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.beforeDrawing = new core.EventEmitter();
            /**
             * Fired after drawing on the canvas has been completed.
             * Can be used to draw on top of the network.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.afterDrawing = new core.EventEmitter();
            /**
             * Fired when an animation is finished.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.animationFinished = new core.EventEmitter();
            /**
             * Fired when a user changes any option in the configurator.
             * The options object can be used with the setOptions method or stringified using JSON.stringify().
             * You do not have to manually put the options into the network: this is done automatically.
             * You can use the event to store user options in the database.
             *
             * @type {EventEmitter<any>}
             * @memberOf NetworkService
             */
            this.configChange = new core.EventEmitter();
            this.networks = {};
        }
        /**
         * Creates a new network instance.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {HTMLElement} container The HTML element that contains the network view.
         * @param {Data} data The initial network nodes and edges.
         * @param {Options} [options] The network options.
         *
         * @throws {Error} Thrown when a network with the same name already exists.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.create = function (visNetwork$1, container, data, options) {
            if (this.networks[visNetwork$1]) {
                throw new Error("Network with id " + visNetwork$1 + " already exists.");
            }
            this.networks[visNetwork$1] = new visNetwork.Network(container, data, options);
        };
        /**
         * Remove the network from the DOM and remove all Hammer bindings and references.
         *
         * @param {string} visNetwork The network name/identifier.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.destroy = function (visNetwork) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].destroy();
                delete this.networks[visNetwork];
            }
        };
        /**
         * Activates an event.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {NetworkEvents} eventName The event name.
         * @param {boolean} preventDefault Stops the default behavior of the event.
         * @returns {boolean} Returns true when the event was activated.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.on = function (visNetwork, eventName, preventDefault) {
            if (this.networks[visNetwork]) {
                /* tslint:disable */
                var that_1 = this;
                /* tslint:enable */
                this.networks[visNetwork].on(eventName, function (params) {
                    var emitter = that_1[eventName];
                    if (emitter) {
                        emitter.emit(params ? [visNetwork].concat(params) : visNetwork);
                    }
                    if (preventDefault && params.event) {
                        params.event.preventDefault();
                    }
                });
                return true;
            }
            return false;
        };
        /**
         * Deactivates an event.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {NetworkEvents} eventName The event name.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.off = function (visNetwork, eventName) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].off(eventName);
            }
        };
        /**
         * Activates an event listener only once.
         * After it has taken place, the event listener will be removed.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {NetworkEvents} eventName The event name.
         * @returns {boolean} Returns true when the event was activated.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.once = function (visNetwork, eventName) {
            var _this = this;
            if (this.networks[visNetwork]) {
                /* tslint:disable */
                var that_2 = this;
                /* tslint:disable */
                this.networks[visNetwork].on(eventName, function (params) {
                    var emitter = that_2[eventName];
                    if (emitter) {
                        emitter.emit(params ? [visNetwork].concat(params) : visNetwork);
                        _this.off(visNetwork, eventName);
                    }
                });
                return true;
            }
            return false;
        };
        /**
         * Override all the data in the network.
         * If stabilization is enabled in the physics module,
         * the network will stabilize again.
         * This method is also performed when first initializing the network.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {Data} data The network data.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.setData = function (visNetwork, data) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].setData(data);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Set the options.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {Options} options The network options.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.setOptions = function (visNetwork, options) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].setOptions(options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Selects the nodes corresponding to the id's in the input array.
         * This method unselects all other objects before selecting its own objects.
         * Does not fire events.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType[]} nodeIds The node ids that should be selected.
         * @param {boolean} [highlightEdges] If highlightEdges is true or undefined,
         *                                   the neighbouring edges will also be selected.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.selectNodes = function (visNetwork, nodeIds, highlightEdges) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].selectNodes(nodeIds, highlightEdges);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Selects the nodes and edges corresponding to the id's in the input arrays.
         * Does not fire events.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param { nodes: IdType[], edges: IdType[] } selection The node and edge ids that should be selected.
         * @param { unselectAll?: boolean, highlightEdges?: boolean } [options]
         * If unselectAll is true or undefined, the other objects will be deselected.
         * If highlightEdges is true or undefined, the neighbouring edges will also be selected.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.setSelection = function (visNetwork, selection, options) {
            if (options === void 0) { options = {}; }
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].setSelection(selection, options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Returns an object with selected nodes and edges ids.
         *
         * @param {string} visNetwork The network name/identifier.
         * @returns {{ nodes: IdType[], edges: IdType[] }}
         * The selected node and edge ids or undefined when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getSelection = function (visNetwork) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].getSelection();
            }
            return undefined;
        };
        /**
         * Returns an array of selected node ids.
         *
         * @param {string} visNetwork The network name/identifier.
         * @returns {IdType[]} The selected node ids or undefined when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getSelectedNodes = function (visNetwork) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].getSelectedNodes();
            }
            return undefined;
        };
        /**
         * Returns an array of selected edge ids.
         *
         * @param {string} visNetwork The network name/identifier.
         * @returns {IdType[]} The selected edge ids or undefined when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getSelectedEdges = function (visNetwork) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].getSelectedEdges();
            }
            return undefined;
        };
        /**
         * Unselect all objects.
         * Does not fire events.
         *
         * @param {string} visNetwork The network name/identifier.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.unselectAll = function (visNetwork) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].unselectAll();
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Zooms out so all nodes fit on the canvas.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {VisFitOptions} [options] Options to customize.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.fit = function (visNetwork, options) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].fit(options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Redraw the network.
         *
         * @param {string} visNetwork The network name/identifier.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.redraw = function (visNetwork) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].redraw();
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Go into addNode mode. Having edit mode or manipulation enabled is not required.
         * To get out of this mode, call disableEditMode(). The callback functions defined in handlerFunctions still apply.
         * To use these methods without having the manipulation GUI, make sure you set enabled to false.
         *
         * @param {string} visNetwork The network name/identifier.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.addNodeMode = function (visNetwork) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].addNodeMode();
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Programatically enable the edit mode.
         * Similar effect to pressing the edit button.
         *
         * @param {string} visNetwork The network name/identifier.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.enableEditMode = function (visNetwork) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].enableEditMode();
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Go into addEdge mode.
         * The explaination from addNodeMode applies here as well.
         *
         * @param {string} visNetwork The network name/identifier.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.addEdgeMode = function (visNetwork) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].addEdgeMode();
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Programatically disable the edit mode.
         * Similar effect to pressing the close icon
         * (small cross in the corner of the toolbar).
         *
         * @param {string} visNetwork The network name/identifier.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.disableEditMode = function (visNetwork) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].disableEditMode();
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Delete selected.
         * Having edit mode or manipulation enabled is not required.
         *
         * @param {string} visNetwork The network name/identifier.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.deleteSelected = function (visNetwork) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].deleteSelected();
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Makes a cluster.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {ClusterOptions} [options] The joinCondition function is presented with all nodes.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.cluster = function (visNetwork, options) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].cluster(options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * This method looks at the provided node and makes a cluster of it and all it's connected nodes.
         * The behaviour can be customized by proving the options object.
         * All options of this object are explained below.
         * The joinCondition is only presented with the connected nodes.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} nodeId the id of the node
         * @param {ClusterOptions} [options] the cluster options
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.clusterByConnection = function (visNetwork, nodeId, options) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].clusterByConnection(nodeId, options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * This method checks all nodes in the network and those with a equal or higher
         * amount of edges than specified with the hubsize qualify.
         * If a hubsize is not defined, the hubsize will be determined as the average
         * value plus two standard deviations.
         * For all qualifying nodes, clusterByConnection is performed on each of them.
         * The options object is described for clusterByConnection and does the same here.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {number} [hubsize] optional hubsize
         * @param {ClusterOptions} [options] optional cluster options
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.clusterByHubsize = function (visNetwork, hubsize, options) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].clusterByHubsize(hubsize, options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * This method will cluster all nodes with 1 edge with their respective connected node.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {ClusterOptions} [options] optional cluster options
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.clusterOutliers = function (visNetwork, options) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].clusterOutliers(options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Nodes can be in clusters.
         * Clusters can also be in clusters.
         * This function returns an array of nodeIds showing where the node is.
         *
         * Example:
         * cluster 'A' contains cluster 'B', cluster 'B' contains cluster 'C',
         * cluster 'C' contains node 'fred'.
         *
         * network.clustering.findNode('fred') will return ['A','B','C','fred'].
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} nodeId the node id.
         * @returns {IdType[]} an array of nodeIds showing where the node is
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.findNode = function (visNetwork, nodeId) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].findNode(nodeId);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Similar to findNode in that it returns all the edge ids that were
         * created from the provided edge during clustering.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} baseEdgeId the base edge id
         * @returns {IdType[]} an array of edgeIds
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getClusteredEdges = function (visNetwork, baseEdgeId) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].getClusteredEdges(baseEdgeId);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * When a clusteredEdgeId is available, this method will return the original
         * baseEdgeId provided in data.edges ie.
         * After clustering the 'SelectEdge' event is fired but provides only the clustered edge.
         * This method can then be used to return the baseEdgeId.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} clusteredEdgeId
         * @returns {IdType}
         *
         * @memberOf NetworkService
         *
         */
        VisNetworkService.prototype.getBaseEdge = function (visNetwork, clusteredEdgeId) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].getBaseEdge(clusteredEdgeId);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Visible edges between clustered nodes are not the same edge as the ones provided
         * in data.edges passed on network creation. With each layer of clustering, copies of
         * the edges between clusters are created and the previous edges are hidden,
         * until the cluster is opened. This method takes an edgeId (ie. a base edgeId from data.edges)
         * and applys the options to it and any edges that were created from it while clustering.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} startEdgeId
         * @param {VisEdgeOptions} [options]
         *
         * @memberOf NetworkService
         *
         */
        VisNetworkService.prototype.updateEdge = function (visNetwork, startEdgeId, options) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].updateEdge(startEdgeId, options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Clustered Nodes when created are not contained in the original data.nodes
         * passed on network creation. This method updates the cluster node.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} clusteredNodeId
         * @param {NodeOptions} options
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.updateClusteredNode = function (visNetwork, clusteredNodeId, options) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].updateClusteredNode(clusteredNodeId, options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Returns an array of all nodeIds of the nodes that
         * would be released if you open the cluster.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} clusterNodeId the id of the cluster node
         * @returns {IdType[]}
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getNodesInCluster = function (visNetwork, clusterNodeId) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].getNodesInCluster(clusterNodeId);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Opens the cluster, releases the contained nodes and edges,
         * removing the cluster node and cluster edges.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} nodeId The node id that represents the cluster.
         * @param {OpenClusterOptions} [options] Cluster options.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.openCluster = function (visNetwork, nodeId, options) {
            if (this.networks[visNetwork]) {
                this.networks[visNetwork].openCluster(nodeId, options);
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        /**
         * Returns true if the node whose ID has been supplied is a cluster.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} nodeId The associated node id.
         * @returns {boolean} True if the node whose ID has been supplied is a cluster.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.isCluster = function (visNetwork, nodeId) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].isCluster(nodeId);
            }
            return false;
        };
        /**
         * If you like the layout of your network and would like it to start in the same way next time,
         * ask for the seed using this method and put it in the layout.randomSeed option.
         *
         * @param {string} visNetwork The network name/identifier.
         * @returns {number} The seed of the current network or -1 when the network is not defined.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getSeed = function (visNetwork) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].getSeed();
            }
            return -1;
        };
        /**
         * This function converts canvas coordinates to coordinates on the DOM.
         * Input and output are in the form of {x:Number,y:Number}.
         * The DOM values are relative to the network container.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {Position} position The canvas position.
         * @returns {Position} The DOM position.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.canvasToDOM = function (visNetwork, position) {
            return this.networks[visNetwork].canvasToDOM(position);
        };
        /**
         * This function converts DOM coordinates to coordinates on the canvas.
         * Input and output are in the form of {x:Number,y:Number}.
         * The DOM values are relative to the network container.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {Position} position The DOM position.
         * @returns {Position} The canvas position.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.DOMtoCanvas = function (visNetwork, position) {
            return this.networks[visNetwork].DOMtoCanvas(position);
        };
        /**
         * This function looks up the node at the given DOM coordinates on the canvas.
         * Input and output are in the form of {x:Number,y:Number}.
         * The DOM values are relative to the network container -> DOM not Canvas coords.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {Position} position The DOM position.
         * @returns {IdType} nodeId The associated node id.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getNodeAt = function (visNetwork, position) {
            return this.networks[visNetwork].getNodeAt(position);
        };
        /**
         * This function looks up the edge at the given DOM coordinates on the canvas.
         * Input and output are in the form of {x:Number,y:Number}.
         * The DOM values are relative to the network container -> DOM not Canvas coords.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {Position} position The DOM position.
         * @returns {IdType} edgeId The associated edge id.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getEdgeAt = function (visNetwork, position) {
            return this.networks[visNetwork].getEdgeAt(position);
        };
        /**
         * This function looks up the edges for a given nodeId.
         * The DOM values are relative to the network container -> DOM not Canvas coords.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {IdType} nodeId The associated node id.
         * @returns {IdType[]} Return array of edge ids
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getConnectedEdges = function (visNetwork, nodeId) {
            return this.networks[visNetwork].getConnectedEdges(nodeId);
        };
        /**
         * Returns an array of nodeIds of the all the nodes that are directly connected to this node.
         * If you supply an edgeId, vis will first match the id to nodes.
         * If no match is found, it will search in the edgelist and return an array: [fromId, toId].
         *
         * @param {string} visNetwork The network name/identifier.
         * @param nodeOrEdgeId a node or edge id
         * @returns {IdType[]} Return array of node ids
         */
        VisNetworkService.prototype.getConnectedNodes = function (visNetwork, nodeOrEdgeId) {
            return this.networks[visNetwork].getConnectedNodes(nodeOrEdgeId);
        };
        /**
         * Returns the positions of the nodes.
         * @param {string} visNetwork The network name/identifier.
         * @param {Array.<Node.id>|String} [ids]  --> optional, can be array of nodeIds, can be string
         * @returns {{}}
         */
        VisNetworkService.prototype.getPositions = function (visNetwork, nodeIds) {
            return this.networks[visNetwork].getPositions(nodeIds);
        };
        /**
         * Returns the positions of the nodes.
         * @param {string} visNetwork The network name/identifier.
         */
        VisNetworkService.prototype.getBoundingBox = function (visNetwork, nodeId) {
            return this.networks[visNetwork].getBoundingBox(nodeId);
        };
        /**
         * Returns the positions of the nodes.
         * @param {string} visNetwork The network name/identifier.
         */
        VisNetworkService.prototype.storePositions = function (visNetwork) {
            return this.networks[visNetwork].storePositions();
        };
        /**
         * You can animate or move the camera using the moveTo method.
         *
         * @param {string} visNetwork The network name/identifier.
         * @param {MoveToOptions} options Options for moveTo function.
         */
        VisNetworkService.prototype.moveTo = function (visNetwork, moveToOptions) {
            return this.networks[visNetwork].moveTo(moveToOptions);
        };
        /**
         * Start the physics simulation.
         * This is normally done whenever needed and is only really useful
         * if you stop the simulation yourself and wish to continue it afterwards.
         * @param {string} visNetwork The network name/identifier.
         */
        VisNetworkService.prototype.startSimulation = function (visNetwork) {
            return this.networks[visNetwork].startSimulation();
        };
        /**
         * This stops the physics simulation and triggers a stabilized event.
         * Tt can be restarted by dragging a node,
         * altering the dataset or calling startSimulation().
         * @param {string} visNetwork The network name/identifier.
         */
        VisNetworkService.prototype.stopSimulation = function (visNetwork) {
            return this.networks[visNetwork].stopSimulation();
        };
        /**
         * Returns the current scale of the network. 1.0 is comparible to 100%, 0 is zoomed out infinitely.
         *
         * @param {string} visNetwork The network name/identifier.
         *
         * @throws {Error} Thrown when the network does not exist.
         *
         * @memberOf NetworkService
         */
        VisNetworkService.prototype.getScale = function (visNetwork) {
            if (this.networks[visNetwork]) {
                return this.networks[visNetwork].getScale();
            }
            else {
                throw new Error("Network with id " + visNetwork + " not found.");
            }
        };
        VisNetworkService = __decorate([
            core.Injectable()
        ], VisNetworkService);
        return VisNetworkService;
    }());

    /**
     * Use this directive with a div container to show network data.
     *
     * @export
     * @class VisNetworkDirective
     * @implements {OnInit}
     * @implements {OnDestroy}
     * @implements {OnChanges}
     */
    var VisNetworkDirective = /** @class */ (function () {
        /**
         * Creates an instance of VisNetworkDirective.
         *
         * @param {ElementRef} elementRef The HTML element reference.
         * @param {VisNetworkService} visNetworkService The VisNetworkService.
         *
         * @memberOf VisNetworkDirective
         */
        function VisNetworkDirective(elementRef, visNetworkService) {
            this.elementRef = elementRef;
            this.visNetworkService = visNetworkService;
            /**
             * This event will be raised when the network is initialized.
             * At this point of time the network is successfully registered
             * with the VisNetworkService and you can register to events.
             * The event data is the name of the network as a string.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisNetworkDirective
             */
            this.initialized = new core.EventEmitter();
            this.isInitialized = false;
            this.visNetworkContainer = elementRef.nativeElement;
        }
        /**
         * Create the network when at least visNetwork and visData
         * are defined.
         *
         * @memberOf VisNetworkDirective
         */
        VisNetworkDirective.prototype.ngOnInit = function () {
            if (!this.isInitialized && this.visNetwork && this.visNetworkData) {
                this.createNetwork();
            }
        };
        /**
         * Update the network data or options on reference changes to
         * the visData or visOptions properties.
         *
         * @param {{[propName: string]: SimpleChange}} changes
         *
         * @memberOf VisNetworkDirective
         */
        VisNetworkDirective.prototype.ngOnChanges = function (changes) {
            if (!this.isInitialized && this.visNetwork && this.visNetworkData) {
                this.createNetwork();
            }
            for (var propertyName in changes) {
                if (changes.hasOwnProperty(propertyName)) {
                    var change = changes[propertyName];
                    if (!change.isFirstChange()) {
                        if (propertyName === 'visData') {
                            this.visNetworkService.setData(this.visNetwork, changes[propertyName].currentValue);
                        }
                        if (propertyName === 'visOptions') {
                            this.visNetworkService.setOptions(this.visNetwork, changes[propertyName].currentValue);
                        }
                    }
                }
            }
        };
        /**
         * Calls the destroy function for this network instance.
         *
         * @memberOf VisNetworkDirective
         */
        VisNetworkDirective.prototype.ngOnDestroy = function () {
            this.isInitialized = false;
            this.visNetworkService.destroy(this.visNetwork);
        };
        VisNetworkDirective.prototype.createNetwork = function () {
            this.visNetworkService.create(this.visNetwork, this.visNetworkContainer, this.visNetworkData, this.visNetworkOptions);
            this.isInitialized = true;
            this.initialized.emit(this.visNetwork);
        };
        VisNetworkDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: VisNetworkService }
        ]; };
        __decorate([
            core.Input('visNetwork')
        ], VisNetworkDirective.prototype, "visNetwork", void 0);
        __decorate([
            core.Input()
        ], VisNetworkDirective.prototype, "visNetworkData", void 0);
        __decorate([
            core.Input()
        ], VisNetworkDirective.prototype, "visNetworkOptions", void 0);
        __decorate([
            core.Output()
        ], VisNetworkDirective.prototype, "initialized", void 0);
        VisNetworkDirective = __decorate([
            core.Directive({
                selector: '[visNetwork]'
            })
        ], VisNetworkDirective);
        return VisNetworkDirective;
    }());

    /**
     * A service to create, manage and control VisTimeline instances.
     *
     * @export
     * @class VisTimelineService
     */
    var VisTimelineService = /** @class */ (function () {
        function VisTimelineService(ngZone) {
            this.ngZone = ngZone;
            /**
             * Fired when the current time bar redraws.
             * The rate depends on the zoom level.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.currentTimeTick = new core.EventEmitter();
            /**
             * Fired when clicked inside the Timeline.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.click = new core.EventEmitter();
            /**
             * Fired when right-clicked inside the Timeline.
             * Note that in order to prevent the context menu from showing up,
             * default behavior of the event must be stopped.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.contextmenu = new core.EventEmitter();
            /**
             * Fired when double clicked inside the Timeline.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.doubleClick = new core.EventEmitter();
            /**
             * 	Fired after the dragging of a group is finished.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.groupDragged = new core.EventEmitter();
            /**
             * Fired once after each graph redraw.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.changed = new core.EventEmitter();
            /**
             * Fired repeatedly when the timeline window is being changed.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.rangechange = new core.EventEmitter();
            /**
             * Fired once after the timeline window has been changed.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.rangechanged = new core.EventEmitter();
            /**
             * Fired after the user selects or deselects items by tapping or holding them.
             * When a use taps an already selected item, the select event is fired again.
             * Not fired when the method setSelectionis executed.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.select = new core.EventEmitter();
            /**
             * Fired when the user moves the mouse over an item.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.itemover = new core.EventEmitter();
            /**
             * Fired when the user moves the mouse out of an item.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.itemout = new core.EventEmitter();
            /**
             * Fired repeatedly when the user is dragging the custom time bar.
             * Only available when the custom time bar is enabled.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.timechange = new core.EventEmitter();
            /**
             * Fired once after the user has dragged the custom time bar.
             * Only available when the custom time bar is enabled.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineService
             */
            this.timechanged = new core.EventEmitter();
            this.events = new Map();
            this.timelines = {};
        }
        /**
         * Creates a new timeline instance.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {HTMLElement} container The HTML element that contains the timeline view.
         * @param {VisTimelineItems} items The initial timeline items.
         * @param {VisTimelineOptions} [options] The timeline options.
         *
         * @throws {Error} Thrown when timeline already exists.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.createWithItems = function (visTimeline$1, container, items, options) {
            if (this.timelines[visTimeline$1]) {
                throw new Error(this.alreadyExistsError(visTimeline$1));
            }
            this.timelines[visTimeline$1] = this.ngZone.runOutsideAngular(function () { return new visTimeline.Timeline(container, items, options); });
        };
        /**
         * Creates a new timeline instance.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {HTMLElement} container The HTML element that contains the timeline view.
         * @param {VisTimelineItems} items The initial timeline items.
         * @param {VisTimelineGroups} groups The initial timeline groups.
         * @param {VisTimelineOptions} [options] The timeline options.
         *
         * @throws {Error} Thrown when timeline already exists.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.createWithItemsAndGroups = function (visTimeline$1, container, items, groups, options) {
            if (this.timelines[visTimeline$1]) {
                throw new Error(this.alreadyExistsError(visTimeline$1));
            }
            this.timelines[visTimeline$1] = this.ngZone.runOutsideAngular(function () { return new visTimeline.Timeline(container, items, groups, options); });
        };
        /**
         * Add new vertical bar representing a custom time that can be dragged by the user.
         * The id is added as CSS class name of the custom time bar,
         * allowing to style multiple time bars differently.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {DateType} time Parameter time can be a Date, Number, or String, and is new Date() by default.
         * @param {IdType} [id] Parameter id can be Number or String and is undefined by default.
         * @returns {IdType} The method returns id of the created bar.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.addCustomTime = function (visTimeline, time, id) {
            if (this.timelines[visTimeline]) {
                return this.timelines[visTimeline].addCustomTime(time, id);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Adjust the visible window such that it fits all items.
         * See also function focus(id).
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {TimelineAnimationOptions} [options] Optional options.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.fit = function (visTimeline, options) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].fit(options);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Adjust the visible window such that the selected item is centered on screen.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {IdType} id The id of the item.
         * @param {TimelineAnimationOptions} [options] Options options.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.focusOnId = function (visTimeline, id, options) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].focus(id, options);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Adjust the visible window such that the selected items are centered on screen.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {IdType[]} ids The item ids.
         * @param {TimelineAnimationOptions} [options] Optional options.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.focusOnIds = function (visTimeline, ids, options) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].focus(ids, options);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Get the current time.
         * Only applicable when option showCurrentTime is true.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @returns {Date} The current time.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.getCurrentTime = function (visTimeline) {
            if (this.timelines[visTimeline]) {
                return this.timelines[visTimeline].getCurrentTime();
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Retrieve the custom time from the custom time bar with given id.
         * Id is undefined by default.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {IdType} [id] The time bar id.
         * @returns {Date} The custom time.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.getCustomTime = function (visTimeline, id) {
            if (this.timelines[visTimeline]) {
                return this.timelines[visTimeline].getCustomTime(id);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Returns an Object with relevant properties from an event.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {Event} event The event.
         * @returns {VisTimelineEventPropertiesResult} Properties of an event
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.getEventProperties = function (visTimeline, event) {
            if (this.timelines[visTimeline]) {
                return this.timelines[visTimeline].getEventProperties(event);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Get the range of all the items as an object containing min: Date and max: Date.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @returns {{ min: Date, max: Date }} The min and max dates.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.getItemRange = function (visTimeline) {
            if (this.timelines[visTimeline]) {
                return this.timelines[visTimeline].getItemRange();
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Get an array with the ids of the currently selected items.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @returns {IdType[]} The currently selected items.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.getSelection = function (visTimeline) {
            if (this.timelines[visTimeline]) {
                return this.timelines[visTimeline].getSelection();
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Get an array with the ids of the currently visible items.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @returns {IdType[]} The currently visible items.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.getVisibleItems = function (visTimeline) {
            if (this.timelines[visTimeline]) {
                return this.timelines[visTimeline].getVisibleItems();
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Get the current visible window.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @returns {{ start: Date, end: Date }} Returns an object with properties start: Date and end: Date.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.getWindow = function (visTimeline) {
            if (this.timelines[visTimeline]) {
                return this.timelines[visTimeline].getWindow();
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * 	Move the window such that given time is centered on screen.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {DateType} time Parameter time can be a Date, Number, or String.
         * @param {TimelineAnimationOptions} [options] Optional options.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.moveTo = function (visTimeline, time, options) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].moveTo(time, options);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Force a redraw of the Timeline.
         * The size of all items will be recalculated.
         * Can be useful to manually redraw when option autoResize=false and the window has been resized,
         * or when the items CSS has been changed.
         *
         * @param {string} visTimeline The timeline name/identifier.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.redraw = function (visTimeline) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].redraw();
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Remove vertical bars previously added to the timeline via addCustomTime method.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {IdType} id Parameter id is the ID of the custom vertical bar returned by addCustomTime method.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.removeCustomTime = function (visTimeline, id) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].removeCustomTime(id);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Set a current time.
         * This can be used for example to ensure that a client's time is synchronized
         * with a shared server time.
         * Only applicable when option showCurrentTime is true.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {DateType} time time can be a Date object, numeric timestamp, or ISO date string.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setCurrentTime = function (visTimeline, time) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setCurrentTime(time);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * 	Adjust the time of a custom time bar.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {DateType} time Parameter time can be a Date object, numeric timestamp, or ISO date string.
         * @param {IdType} [id] Parameter id is the id of the custom time bar, and is undefined by default.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setCustomTime = function (visTimeline, time, id) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setCustomTime(time, id);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Adjust the title attribute of a custom time bar.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {string} title Parameter title is the string to be set as title.
         *                       Use empty string to hide the title completely.
         * @param {IdType} [id] Parameter id is the id of the custom time bar, and is undefined by default.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setCustomTimeTitle = function (visTimeline, title, id) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setCustomTimeTitle(title, id);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Set both groups and items at once.
         * Both properties are optional.
         * This is a convenience method for individually calling both setItems(items) and setGroups(groups).
         * Both items and groups can be an Array with Objects, a DataSet (offering 2 way data binding),
         * or a DataView (offering 1 way data binding).
         * For each of the groups, the items of the timeline are filtered on the property group,
         * which must correspond with the id of the group.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {{ groups?: VisTimelineGroups; items?: VisTimelineItems }} data The new timline data.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setData = function (visTimeline, data) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setData(data);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Set a data set with groups for the Timeline.
         * For each of the groups, the items of the timeline are filtered on the property group,
         * which must correspond with the id of the group.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {VisTimelineGroups} groups a DataSet (offering 2 way data binding)
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setGroups = function (visTimeline, groups) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setGroups(groups);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Set a data set with items for the Timeline.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {VisTimelineItems} items can be an Array with Objects, a DataSet (offering 2 way data binding)
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setItems = function (visTimeline, items) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setItems(items);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Set or update options.
         * It is possible to change any option of the timeline at any time.
         * You can for example switch orientation on the fly.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {VisTimelineOptions} options The new options of the timeline.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setOptions = function (visTimeline, options) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setOptions(options);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Select one item by its id.#
         * The currently selected items will be unselected.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {IdType} id The id of the item that should be selected.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setSelectionToId = function (visTimeline, id) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setSelection(id);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Select multiple items by their id.
         * The currently selected items will be unselected.
         * To unselect all selected items, call `setSelection([])`.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {IdType[]} ids The ids of the irems that should be selected.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setSelectionToIds = function (visTimeline, ids) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setSelection(ids);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Set the current visible window.
         *
         * If the parameter value of start or end is null, the parameter will be left unchanged.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {DateType} start The parameters start can be a Date, Number, or String.
         * @param {DateType} end The parameters end can be a Date, Number, or String.
         * @param {TimelineAnimationOptions} [options] Optional options.
         *
         * @throws {Error} Thrown when timeline does not exist.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.setWindow = function (visTimeline, start, end, options) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].setWindow(start, end, options);
            }
            else {
                throw new Error(this.doesNotExistError(visTimeline));
            }
        };
        /**
         * Destroy the Timeline.
         * The timeline is removed from memory.
         * All DOM elements and event listeners are cleaned up.
         *
         * @param {string} visTimeline The timeline name/identifier.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.destroy = function (visTimeline) {
            if (this.timelines[visTimeline]) {
                this.timelines[visTimeline].destroy();
                delete this.timelines[visTimeline];
            }
        };
        /**
         * Activates an event.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {string} eventName The event name.
         * @param {boolean} preventDefault Stops the default behavior of the event.
         * @returns {boolean} Returns true when the event was activated.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.on = function (visTimeline, eventName, preventDefault) {
            if (this.timelines[visTimeline]) {
                this.events.set(eventName, new core.EventEmitter());
                // tslint:disable-next-line
                var that_1 = this;
                this.timelines[visTimeline].on(eventName, function (params) {
                    var emitter = (that_1[eventName] || that_1.events.get(eventName));
                    if (emitter) {
                        emitter.emit(params ? [visTimeline].concat(params) : visTimeline);
                    }
                    if (preventDefault && params.event) {
                        params.event.preventDefault();
                    }
                });
                return true;
            }
            return false;
        };
        /**
         * Deactivates an event.
         *
         * @param {string} visTimeline The timeline name/identifier.
         * @param {string} eventName The event name.
         *
         * @memberOf VisTimelineService
         */
        VisTimelineService.prototype.off = function (visTimeline, eventName) {
            if (this.timelines[visTimeline]) {
                this.events.delete(eventName);
                this.timelines[visTimeline].off(eventName, undefined);
            }
        };
        /**
         * Get the event emitter associated with the specified event name.
         * @param {string} eventName The event name.
         * @returns {EventEmitter<any>} The event emitter of the specified event name.
         */
        VisTimelineService.prototype.getEmitter = function (eventName) {
            return this.events.get(eventName);
        };
        VisTimelineService.prototype.doesNotExistError = function (visTimeline) {
            return "Timeline with id " + visTimeline + " does not exist.";
        };
        VisTimelineService.prototype.alreadyExistsError = function (visTimeline) {
            return "Timeline with id " + visTimeline + " already exists.";
        };
        VisTimelineService.ctorParameters = function () { return [
            { type: core.NgZone }
        ]; };
        VisTimelineService = __decorate([
            core.Injectable()
        ], VisTimelineService);
        return VisTimelineService;
    }());

    /**
     * Use this directive with a div container to show timeline data.
     *
     * @export
     * @class VisTimelineDirective
     * @implements {OnInit}
     * @implements {OnDestroy}
     * @implements {OnChanges}
     */
    var VisTimelineDirective = /** @class */ (function () {
        /**
         * Creates an instance of VisTimelineDirective.
         *
         * @param {ElementRef} elementRef The HTML element reference.
         * @param {VisTimelineService} visTimelineService The VisTimelineService.
         *
         * @memberOf VisTimelineDirective
         */
        function VisTimelineDirective(elementRef, visTimelineService) {
            this.elementRef = elementRef;
            this.visTimelineService = visTimelineService;
            /**
             * This event will be raised when the timline is initialized.
             * At this point of time the timeline is successfully registered
             * with the VisNetworkService and you can register to events.
             * The event data is the name of the timeline as a string.
             *
             * @type {EventEmitter<any>}
             * @memberOf VisTimelineDirective
             */
            this.initialized = new core.EventEmitter();
            this.isInitialized = false;
            this.visTimelineContainer = elementRef.nativeElement;
        }
        /**
         * Create the timeline when at least visNetwork and visNetworkData
         * are defined.
         *
         * @memberOf VisTimelineDirective
         */
        VisTimelineDirective.prototype.ngOnInit = function () {
            if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {
                this.createTimeline();
            }
        };
        /**
         * Update the timeline data, groups or options on reference changes to
         * the visTimelineItems, visTimelineGroups or visTimelineOptions properties.
         *
         * @param {{[propName: string]: SimpleChange}} changes
         *
         * @memberOf VisTimelineDirective
         */
        VisTimelineDirective.prototype.ngOnChanges = function (changes) {
            if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {
                this.createTimeline();
            }
            for (var propertyName in changes) {
                if (changes.hasOwnProperty(propertyName)) {
                    var change = changes[propertyName];
                    if (!change.isFirstChange()) {
                        if (propertyName === 'visTimelineItems') {
                            this.visTimelineService.setItems(this.visTimeline, changes[propertyName].currentValue);
                        }
                        if (propertyName === 'visTimelineOptions') {
                            this.visTimelineService.setOptions(this.visTimeline, changes[propertyName].currentValue);
                        }
                        if (propertyName === 'visTimelineGroups') {
                            this.visTimelineService.setGroups(this.visTimeline, changes[propertyName].currentValue);
                        }
                    }
                }
            }
        };
        /**
         * Calls the destroy function for this timeline instance.
         *
         *
         * @memberOf VisTimelineDirective
         */
        VisTimelineDirective.prototype.ngOnDestroy = function () {
            this.isInitialized = false;
            this.visTimelineService.destroy(this.visTimeline);
        };
        VisTimelineDirective.prototype.createTimeline = function () {
            if (this.visTimelineGroups) {
                this.visTimelineService.createWithItemsAndGroups(this.visTimeline, this.visTimelineContainer, this.visTimelineItems, this.visTimelineGroups, this.visTimelineOptions);
            }
            else {
                this.visTimelineService.createWithItems(this.visTimeline, this.visTimelineContainer, this.visTimelineItems, this.visTimelineOptions);
            }
            this.isInitialized = true;
            this.initialized.emit(this.visTimeline);
        };
        VisTimelineDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: VisTimelineService }
        ]; };
        __decorate([
            core.Input('visTimeline')
        ], VisTimelineDirective.prototype, "visTimeline", void 0);
        __decorate([
            core.Input()
        ], VisTimelineDirective.prototype, "visTimelineItems", void 0);
        __decorate([
            core.Input()
        ], VisTimelineDirective.prototype, "visTimelineGroups", void 0);
        __decorate([
            core.Input()
        ], VisTimelineDirective.prototype, "visTimelineOptions", void 0);
        __decorate([
            core.Output()
        ], VisTimelineDirective.prototype, "initialized", void 0);
        VisTimelineDirective = __decorate([
            core.Directive({
                selector: '[visTimeline]'
            })
        ], VisTimelineDirective);
        return VisTimelineDirective;
    }());

    var VisModule = /** @class */ (function () {
        function VisModule() {
        }
        VisModule = __decorate([
            core.NgModule({
                declarations: [VisNetworkDirective, VisTimelineDirective],
                exports: [VisNetworkDirective, VisTimelineDirective],
                imports: [common.CommonModule],
                providers: [VisNetworkService, VisTimelineService],
                schemas: [core.CUSTOM_ELEMENTS_SCHEMA, core.NO_ERRORS_SCHEMA]
            })
        ], VisModule);
        return VisModule;
    }());

    Object.defineProperty(exports, 'DataSet', {
        enumerable: true,
        get: function () {
            return visNetwork.DataSet;
        }
    });
    exports.VisModule = VisModule;
    exports.VisNetworkDirective = VisNetworkDirective;
    exports.VisNetworkService = VisNetworkService;
    exports.VisTimelineDirective = VisTimelineDirective;
    exports.VisTimelineService = VisTimelineService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngxvis.umd.js.map
