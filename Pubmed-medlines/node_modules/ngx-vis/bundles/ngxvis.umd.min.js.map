{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","ng://ngx-vis/components/network/vis-network.service.ts","ng://ngx-vis/components/network/vis-network.directive.ts","ng://ngx-vis/components/timeline/vis-timeline.service.ts","ng://ngx-vis/components/timeline/vis-timeline.directive.ts","ng://ngx-vis/ngx-vis.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","VisNetworkService","this","click","EventEmitter","doubleClick","oncontext","hold","release","select","selectNode","selectEdge","deselectNode","deselectEdge","dragStart","dragging","dragEnd","hoverNode","blurNode","hoverEdge","blurEdge","zoom","showPopup","hidePopup","startStabilizing","stabilizationProgress","stabilizationIterationsDone","stabilized","resize","initRedraw","beforeDrawing","afterDrawing","animationFinished","configChange","networks","prototype","create","visNetwork","container","data","options","Error","Network","destroy","on","eventName","preventDefault","that_1","params","emitter","emit","concat","event","off","once","_this","that_2","setData","setOptions","selectNodes","nodeIds","highlightEdges","setSelection","selection","getSelection","getSelectedNodes","getSelectedEdges","unselectAll","fit","redraw","addNodeMode","enableEditMode","addEdgeMode","disableEditMode","deleteSelected","cluster","clusterByConnection","nodeId","clusterByHubsize","hubsize","clusterOutliers","findNode","getClusteredEdges","baseEdgeId","getBaseEdge","clusteredEdgeId","updateEdge","startEdgeId","updateClusteredNode","clusteredNodeId","getNodesInCluster","clusterNodeId","openCluster","isCluster","getSeed","canvasToDOM","position","DOMtoCanvas","getNodeAt","getEdgeAt","getConnectedEdges","getConnectedNodes","nodeOrEdgeId","getPositions","getBoundingBox","storePositions","moveTo","moveToOptions","startSimulation","stopSimulation","getScale","Injectable","VisNetworkDirective","elementRef","visNetworkService","initialized","isInitialized","visNetworkContainer","nativeElement","ngOnInit","visNetworkData","createNetwork","ngOnChanges","changes","propertyName","hasOwnProperty","isFirstChange","currentValue","ngOnDestroy","visNetworkOptions","ElementRef","tslib_1.__decorate","Input","Output","Directive","selector","VisTimelineService","ngZone","currentTimeTick","contextmenu","groupDragged","changed","rangechange","rangechanged","itemover","itemout","timechange","timechanged","events","Map","timelines","createWithItems","visTimeline","items","alreadyExistsError","runOutsideAngular","Timeline","createWithItemsAndGroups","groups","addCustomTime","time","id","doesNotExistError","focusOnId","focus","focusOnIds","ids","getCurrentTime","getCustomTime","getEventProperties","getItemRange","getVisibleItems","getWindow","removeCustomTime","setCurrentTime","setCustomTime","setCustomTimeTitle","title","setGroups","setItems","setSelectionToId","setSelectionToIds","setWindow","start","end","set","get","delete","undefined","getEmitter","NgZone","VisTimelineDirective","visTimelineService","visTimelineContainer","visTimelineItems","createTimeline","visTimelineGroups","visTimelineOptions","VisModule","NgModule","declarations","exports","imports","CommonModule","providers","schemas","CUSTOM_ELEMENTS_SCHEMA","NO_ERRORS_SCHEMA"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { EventEmitter, Injectable } from '@angular/core';\nimport {\n  BoundingBox,\n  ClusterOptions,\n  Data,\n  EdgeOptions,\n  FitOptions,\n  IdType,\n  MoveToOptions,\n  Network,\n  NetworkEvents,\n  NodeOptions,\n  OpenClusterOptions,\n  Options,\n  Position\n} from 'vis-network';\n\n/**\n * A service to create, manage and control Network instances.\n *\n * @export\n * @class NetworkService\n */\n@Injectable()\nexport class VisNetworkService {\n  /**\n   * Fired when the user clicks the mouse or taps on a touchscreen device.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public click: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the user double clicks the mouse or double taps on a touchscreen device.\n   * Since a double click is in fact 2 clicks, 2 click events are fired, followed by a double click event.\n   * If you do not want to use the click events if a double click event is fired,\n   * just check the time between click events before processing them.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public doubleClick: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the user click on the canvas with the right mouse button.\n   * The right mouse button does not select by default.\n   * You can use the method getNodeAt to select the node if you want.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public oncontext: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the user clicks and holds the mouse or taps and holds on a touchscreen device.\n   * A click event is also fired in this case.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public hold: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired after drawing on the canvas has been completed.\n   * Can be used to draw on top of the network.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public release: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the selection has changed by user action.\n   * This means a node or edge has been selected, added to the selection or deselected.\n   * All select events are only triggered on click and hold.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public select: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when a node has been selected by the user.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public selectNode: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when a edge has been selected by the user.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public selectEdge: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when a node (or nodes) has (or have) been deselected by the user.\n   * The previous selection is the list of nodes and edges that were selected before the last user event.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public deselectNode: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when a edge (or edges) has (or have) been deselected by the user.\n   * The previous selection is the list of nodes and edges that were selected before the last user event.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public deselectEdge: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when starting a drag.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public dragStart: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when dragging node(s) or the view.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public dragging: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the drag has finished.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public dragEnd: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over a node.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public hoverNode: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired if the option interaction:{hover:true} is enabled and\n   * the mouse moved away from a node it was hovering over before.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public blurNode: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over an edge.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public hoverEdge: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired if the option interaction:{hover:true} is enabled and\n   * the mouse moved away from an edge it was hovering over before.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public blurEdge: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the user zooms in or out.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public zoom: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the popup (tooltip) is shown.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public showPopup: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the popup (tooltip) is hidden.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public hidePopup: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when stabilization starts.\n   * This is also the case when you drag a node and the physics\n   * simulation restarts to stabilize again.\n   * Stabilization does not neccesarily imply 'without showing'.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public startStabilizing: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when a multiple of the updateInterval number of iterations is reached.\n   * This only occurs in the 'hidden' stabilization.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public stabilizationProgress: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the 'hidden' stabilization finishes.\n   * This does not necessarily mean the network is stabilized;\n   * it could also mean that the amount of iterations defined in the options has been reached.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public stabilizationIterationsDone: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the 'hidden' stabilization finishes.\n   * This does not necessarily mean the network is stabilized;\n   * it could also mean that the amount of iterations defined in the options has been reached.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public stabilized: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the size of the canvas has been resized,\n   * either by a redraw call when the container div has changed in size,\n   * a setSize() call with new values or a setOptions() with new width and/or height values.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public resize: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired before the redrawing begins.\n   * The simulation step has completed at this point.\n   * Can be used to move custom elements before starting drawing the new frame.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public initRedraw: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired after the canvas has been cleared, scaled and translated to\n   * the viewing position but before all edges and nodes are drawn.\n   * Can be used to draw behind the network.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public beforeDrawing: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired after drawing on the canvas has been completed.\n   * Can be used to draw on top of the network.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public afterDrawing: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when an animation is finished.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public animationFinished: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when a user changes any option in the configurator.\n   * The options object can be used with the setOptions method or stringified using JSON.stringify().\n   * You do not have to manually put the options into the network: this is done automatically.\n   * You can use the event to store user options in the database.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf NetworkService\n   */\n  public configChange: EventEmitter<any> = new EventEmitter<any>();\n\n  private networks: { [id: string]: Network } = {};\n\n  /**\n   * Creates a new network instance.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {HTMLElement} container The HTML element that contains the network view.\n   * @param {Data} data The initial network nodes and edges.\n   * @param {Options} [options] The network options.\n   *\n   * @throws {Error} Thrown when a network with the same name already exists.\n   *\n   * @memberOf NetworkService\n   */\n  public create(visNetwork: string, container: HTMLElement, data: Data, options?: Options): void {\n    if (this.networks[visNetwork]) {\n      throw new Error(`Network with id ${visNetwork} already exists.`);\n    }\n\n    this.networks[visNetwork] = new Network(container, data, options);\n  }\n\n  /**\n   * Remove the network from the DOM and remove all Hammer bindings and references.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   *\n   * @memberOf NetworkService\n   */\n  public destroy(visNetwork: string): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].destroy();\n      delete this.networks[visNetwork];\n    }\n  }\n\n  /**\n   * Activates an event.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {NetworkEvents} eventName The event name.\n   * @param {boolean} preventDefault Stops the default behavior of the event.\n   * @returns {boolean} Returns true when the event was activated.\n   *\n   * @memberOf NetworkService\n   */\n  public on(visNetwork: string, eventName: NetworkEvents, preventDefault?: boolean): boolean {\n    if (this.networks[visNetwork]) {\n      /* tslint:disable */\n      const that: { [index: string]: any } = this;\n      /* tslint:enable */\n      this.networks[visNetwork].on(eventName, (params: any) => {\n        const emitter = that[eventName] as EventEmitter<any>;\n        if (emitter) {\n          emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\n        }\n        if (preventDefault && params.event) {\n          params.event.preventDefault();\n        }\n      });\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Deactivates an event.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {NetworkEvents} eventName The event name.\n   *\n   * @memberOf NetworkService\n   */\n  public off(visNetwork: string, eventName: NetworkEvents): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].off(eventName);\n    }\n  }\n\n  /**\n   * Activates an event listener only once.\n   * After it has taken place, the event listener will be removed.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {NetworkEvents} eventName The event name.\n   * @returns {boolean} Returns true when the event was activated.\n   *\n   * @memberOf NetworkService\n   */\n  public once(visNetwork: string, eventName: NetworkEvents): boolean {\n    if (this.networks[visNetwork]) {\n      /* tslint:disable */\n      const that: { [index: string]: any } = this;\n      /* tslint:disable */\n      this.networks[visNetwork].on(eventName, (params: any) => {\n        const emitter = that[eventName] as EventEmitter<any>;\n        if (emitter) {\n          emitter.emit(params ? [visNetwork].concat(params) : visNetwork);\n          this.off(visNetwork, eventName);\n        }\n      });\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Override all the data in the network.\n   * If stabilization is enabled in the physics module,\n   * the network will stabilize again.\n   * This method is also performed when first initializing the network.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {Data} data The network data.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public setData(visNetwork: string, data: Data): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].setData(data);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Set the options.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {Options} options The network options.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public setOptions(visNetwork: string, options: Options): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].setOptions(options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Selects the nodes corresponding to the id's in the input array.\n   * This method unselects all other objects before selecting its own objects.\n   * Does not fire events.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType[]} nodeIds The node ids that should be selected.\n   * @param {boolean} [highlightEdges] If highlightEdges is true or undefined,\n   *                                   the neighbouring edges will also be selected.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public selectNodes(visNetwork: string, nodeIds: IdType[], highlightEdges?: boolean): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].selectNodes(nodeIds, highlightEdges);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Selects the nodes and edges corresponding to the id's in the input arrays.\n   * Does not fire events.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param { nodes: IdType[], edges: IdType[] } selection The node and edge ids that should be selected.\n   * @param { unselectAll?: boolean, highlightEdges?: boolean } [options]\n   * If unselectAll is true or undefined, the other objects will be deselected.\n   * If highlightEdges is true or undefined, the neighbouring edges will also be selected.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public setSelection(\n    visNetwork: string,\n    selection: { nodes: IdType[]; edges: IdType[] },\n    options: { unselectAll?: boolean; highlightEdges?: boolean } = {}\n  ): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].setSelection(selection, options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Returns an object with selected nodes and edges ids.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @returns {{ nodes: IdType[], edges: IdType[] }}\n   * The selected node and edge ids or undefined when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public getSelection(visNetwork: string): { nodes: IdType[]; edges: IdType[] } {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].getSelection();\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns an array of selected node ids.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @returns {IdType[]} The selected node ids or undefined when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public getSelectedNodes(visNetwork: string): IdType[] {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].getSelectedNodes();\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns an array of selected edge ids.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @returns {IdType[]} The selected edge ids or undefined when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public getSelectedEdges(visNetwork: string): IdType[] {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].getSelectedEdges();\n    }\n    return undefined;\n  }\n\n  /**\n   * Unselect all objects.\n   * Does not fire events.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public unselectAll(visNetwork: string): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].unselectAll();\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Zooms out so all nodes fit on the canvas.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {VisFitOptions} [options] Options to customize.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public fit(visNetwork: string, options?: FitOptions): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].fit(options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Redraw the network.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public redraw(visNetwork: string): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].redraw();\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Go into addNode mode. Having edit mode or manipulation enabled is not required.\n   * To get out of this mode, call disableEditMode(). The callback functions defined in handlerFunctions still apply.\n   * To use these methods without having the manipulation GUI, make sure you set enabled to false.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public addNodeMode(visNetwork: string): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].addNodeMode();\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Programatically enable the edit mode.\n   * Similar effect to pressing the edit button.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public enableEditMode(visNetwork: string): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].enableEditMode();\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Go into addEdge mode.\n   * The explaination from addNodeMode applies here as well.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public addEdgeMode(visNetwork: string): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].addEdgeMode();\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Programatically disable the edit mode.\n   * Similar effect to pressing the close icon\n   * (small cross in the corner of the toolbar).\n   *\n   * @param {string} visNetwork The network name/identifier.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public disableEditMode(visNetwork: string): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].disableEditMode();\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Delete selected.\n   * Having edit mode or manipulation enabled is not required.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public deleteSelected(visNetwork: string): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].deleteSelected();\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Makes a cluster.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {ClusterOptions} [options] The joinCondition function is presented with all nodes.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public cluster(visNetwork: string, options?: ClusterOptions): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].cluster(options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * This method looks at the provided node and makes a cluster of it and all it's connected nodes.\n   * The behaviour can be customized by proving the options object.\n   * All options of this object are explained below.\n   * The joinCondition is only presented with the connected nodes.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} nodeId the id of the node\n   * @param {ClusterOptions} [options] the cluster options\n   *\n   * @memberOf NetworkService\n   */\n  public clusterByConnection(visNetwork: string, nodeId: IdType, options?: ClusterOptions): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].clusterByConnection(nodeId as any, options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * This method checks all nodes in the network and those with a equal or higher\n   * amount of edges than specified with the hubsize qualify.\n   * If a hubsize is not defined, the hubsize will be determined as the average\n   * value plus two standard deviations.\n   * For all qualifying nodes, clusterByConnection is performed on each of them.\n   * The options object is described for clusterByConnection and does the same here.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {number} [hubsize] optional hubsize\n   * @param {ClusterOptions} [options] optional cluster options\n   *\n   * @memberOf NetworkService\n   */\n  public clusterByHubsize(visNetwork: string, hubsize?: number, options?: ClusterOptions): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].clusterByHubsize(hubsize, options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * This method will cluster all nodes with 1 edge with their respective connected node.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {ClusterOptions} [options] optional cluster options\n   *\n   * @memberOf NetworkService\n   */\n  public clusterOutliers(visNetwork: string, options?: ClusterOptions): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].clusterOutliers(options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Nodes can be in clusters.\n   * Clusters can also be in clusters.\n   * This function returns an array of nodeIds showing where the node is.\n   *\n   * Example:\n   * cluster 'A' contains cluster 'B', cluster 'B' contains cluster 'C',\n   * cluster 'C' contains node 'fred'.\n   *\n   * network.clustering.findNode('fred') will return ['A','B','C','fred'].\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} nodeId the node id.\n   * @returns {IdType[]} an array of nodeIds showing where the node is\n   *\n   * @memberOf NetworkService\n   */\n  public findNode(visNetwork: string, nodeId: IdType): IdType[] {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].findNode(nodeId);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Similar to findNode in that it returns all the edge ids that were\n   * created from the provided edge during clustering.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} baseEdgeId the base edge id\n   * @returns {IdType[]} an array of edgeIds\n   *\n   * @memberOf NetworkService\n   */\n  public getClusteredEdges(visNetwork: string, baseEdgeId: IdType): IdType[] {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].getClusteredEdges(baseEdgeId);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * When a clusteredEdgeId is available, this method will return the original\n   * baseEdgeId provided in data.edges ie.\n   * After clustering the 'SelectEdge' event is fired but provides only the clustered edge.\n   * This method can then be used to return the baseEdgeId.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} clusteredEdgeId\n   * @returns {IdType}\n   *\n   * @memberOf NetworkService\n   *\n   */\n  public getBaseEdge(visNetwork: string, clusteredEdgeId: IdType): IdType {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].getBaseEdge(clusteredEdgeId);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Visible edges between clustered nodes are not the same edge as the ones provided\n   * in data.edges passed on network creation. With each layer of clustering, copies of\n   * the edges between clusters are created and the previous edges are hidden,\n   * until the cluster is opened. This method takes an edgeId (ie. a base edgeId from data.edges)\n   * and applys the options to it and any edges that were created from it while clustering.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} startEdgeId\n   * @param {VisEdgeOptions} [options]\n   *\n   * @memberOf NetworkService\n   *\n   */\n  public updateEdge(visNetwork: string, startEdgeId: IdType, options?: EdgeOptions): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].updateEdge(startEdgeId, options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Clustered Nodes when created are not contained in the original data.nodes\n   * passed on network creation. This method updates the cluster node.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} clusteredNodeId\n   * @param {NodeOptions} options\n   *\n   * @memberOf NetworkService\n   */\n  public updateClusteredNode(visNetwork: string, clusteredNodeId: IdType, options?: NodeOptions): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].updateClusteredNode(clusteredNodeId, options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Returns an array of all nodeIds of the nodes that\n   * would be released if you open the cluster.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} clusterNodeId the id of the cluster node\n   * @returns {IdType[]}\n   *\n   * @memberOf NetworkService\n   */\n  public getNodesInCluster(visNetwork: string, clusterNodeId: IdType): IdType[] {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].getNodesInCluster(clusterNodeId);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Opens the cluster, releases the contained nodes and edges,\n   * removing the cluster node and cluster edges.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} nodeId The node id that represents the cluster.\n   * @param {OpenClusterOptions} [options] Cluster options.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public openCluster(visNetwork: string, nodeId: IdType, options?: OpenClusterOptions): void {\n    if (this.networks[visNetwork]) {\n      this.networks[visNetwork].openCluster(nodeId, options);\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n\n  /**\n   * Returns true if the node whose ID has been supplied is a cluster.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} nodeId The associated node id.\n   * @returns {boolean} True if the node whose ID has been supplied is a cluster.\n   *\n   * @memberOf NetworkService\n   */\n  public isCluster(visNetwork: string, nodeId: IdType): boolean {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].isCluster(nodeId);\n    }\n\n    return false;\n  }\n\n  /**\n   * If you like the layout of your network and would like it to start in the same way next time,\n   * ask for the seed using this method and put it in the layout.randomSeed option.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @returns {number} The seed of the current network or -1 when the network is not defined.\n   *\n   * @memberOf NetworkService\n   */\n  public getSeed(visNetwork: string): number {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].getSeed();\n    }\n\n    return -1;\n  }\n\n  /**\n   * This function converts canvas coordinates to coordinates on the DOM.\n   * Input and output are in the form of {x:Number,y:Number}.\n   * The DOM values are relative to the network container.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {Position} position The canvas position.\n   * @returns {Position} The DOM position.\n   *\n   * @memberOf NetworkService\n   */\n  public canvasToDOM(visNetwork: string, position: Position) {\n    return this.networks[visNetwork].canvasToDOM(position);\n  }\n\n  /**\n   * This function converts DOM coordinates to coordinates on the canvas.\n   * Input and output are in the form of {x:Number,y:Number}.\n   * The DOM values are relative to the network container.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {Position} position The DOM position.\n   * @returns {Position} The canvas position.\n   *\n   * @memberOf NetworkService\n   */\n  public DOMtoCanvas(visNetwork: string, position: Position) {\n    return this.networks[visNetwork].DOMtoCanvas(position);\n  }\n\n  /**\n   * This function looks up the node at the given DOM coordinates on the canvas.\n   * Input and output are in the form of {x:Number,y:Number}.\n   * The DOM values are relative to the network container -> DOM not Canvas coords.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {Position} position The DOM position.\n   * @returns {IdType} nodeId The associated node id.\n   *\n   * @memberOf NetworkService\n   */\n  public getNodeAt(visNetwork: string, position: Position) {\n    return this.networks[visNetwork].getNodeAt(position);\n  }\n\n  /**\n   * This function looks up the edge at the given DOM coordinates on the canvas.\n   * Input and output are in the form of {x:Number,y:Number}.\n   * The DOM values are relative to the network container -> DOM not Canvas coords.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {Position} position The DOM position.\n   * @returns {IdType} edgeId The associated edge id.\n   *\n   * @memberOf NetworkService\n   */\n  public getEdgeAt(visNetwork: string, position: Position) {\n    return this.networks[visNetwork].getEdgeAt(position);\n  }\n\n  /**\n   * This function looks up the edges for a given nodeId.\n   * The DOM values are relative to the network container -> DOM not Canvas coords.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {IdType} nodeId The associated node id.\n   * @returns {IdType[]} Return array of edge ids\n   *\n   * @memberOf NetworkService\n   */\n  public getConnectedEdges(visNetwork: string, nodeId: IdType) {\n    return this.networks[visNetwork].getConnectedEdges(nodeId);\n  }\n\n  /**\n   * Returns an array of nodeIds of the all the nodes that are directly connected to this node.\n   * If you supply an edgeId, vis will first match the id to nodes.\n   * If no match is found, it will search in the edgelist and return an array: [fromId, toId].\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param nodeOrEdgeId a node or edge id\n   * @returns {IdType[]} Return array of node ids\n   */\n  public getConnectedNodes(visNetwork: string, nodeOrEdgeId: IdType) {\n    return this.networks[visNetwork].getConnectedNodes(nodeOrEdgeId);\n  }\n\n  /**\n   * Returns the positions of the nodes.\n   * @param {string} visNetwork The network name/identifier.\n   * @param {Array.<Node.id>|String} [ids]  --> optional, can be array of nodeIds, can be string\n   * @returns {{}}\n   */\n  public getPositions(visNetwork: string, nodeIds: IdType[]) {\n    return this.networks[visNetwork].getPositions(nodeIds);\n  }\n\n  /**\n   * Returns the positions of the nodes.\n   * @param {string} visNetwork The network name/identifier.\n   */\n  public getBoundingBox(visNetwork: string, nodeId: IdType): BoundingBox {\n    return this.networks[visNetwork].getBoundingBox(nodeId);\n  }\n\n  /**\n   * Returns the positions of the nodes.\n   * @param {string} visNetwork The network name/identifier.\n   */\n  public storePositions(visNetwork: string): void {\n    return this.networks[visNetwork].storePositions();\n  }\n\n  /**\n   * You can animate or move the camera using the moveTo method.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   * @param {MoveToOptions} options Options for moveTo function.\n   */\n  public moveTo(visNetwork: string, moveToOptions: MoveToOptions) {\n    return this.networks[visNetwork].moveTo(moveToOptions);\n  }\n\n  /**\n   * Start the physics simulation.\n   * This is normally done whenever needed and is only really useful\n   * if you stop the simulation yourself and wish to continue it afterwards.\n   * @param {string} visNetwork The network name/identifier.\n   */\n  public startSimulation(visNetwork: string) {\n    return this.networks[visNetwork].startSimulation();\n  }\n\n  /**\n   * This stops the physics simulation and triggers a stabilized event.\n   * Tt can be restarted by dragging a node,\n   * altering the dataset or calling startSimulation().\n   * @param {string} visNetwork The network name/identifier.\n   */\n  public stopSimulation(visNetwork: string) {\n    return this.networks[visNetwork].stopSimulation();\n  }\n\n  /**\n   * Returns the current scale of the network. 1.0 is comparible to 100%, 0 is zoomed out infinitely.\n   *\n   * @param {string} visNetwork The network name/identifier.\n   *\n   * @throws {Error} Thrown when the network does not exist.\n   *\n   * @memberOf NetworkService\n   */\n  public getScale(visNetwork: string): number {\n    if (this.networks[visNetwork]) {\n      return this.networks[visNetwork].getScale();\n    } else {\n      throw new Error(`Network with id ${visNetwork} not found.`);\n    }\n  }\n}\n","import { Directive, ElementRef, EventEmitter, Input, OnChanges, OnDestroy, OnInit, Output, SimpleChange } from '@angular/core';\nimport { Data, Options } from 'vis-network';\n\nimport { VisNetworkService } from './vis-network.service';\n\n/**\n * Use this directive with a div container to show network data.\n *\n * @export\n * @class VisNetworkDirective\n * @implements {OnInit}\n * @implements {OnDestroy}\n * @implements {OnChanges}\n */\n@Directive({\n  selector: '[visNetwork]'\n})\nexport class VisNetworkDirective implements OnInit, OnDestroy, OnChanges {\n  /**\n   * The name or identifier of the network (must be unique in your application).\n   * This property is used once on init and must not be changed.\n   *\n   * @type {string}\n   * @memberOf VisNetworkDirective\n   */\n  @Input('visNetwork')\n  public visNetwork: string;\n\n  /**\n   * The data that will be used to create the network.\n   * Changes to the nodes or edges property won't be detected but\n   * changes to the reference of this object.\n   * Changes lead to a call to setData of this network instance.\n   *\n   * @type {Data}\n   * @memberOf VisNetworkDirective\n   */\n  @Input()\n  public visNetworkData: Data;\n\n  /**\n   * The options that will be used with this network instance.\n   * Only reference changes to the whole options object will be detected\n   * but not changes to properties.\n   * Changes lead to a call to setOptions of the network instance.\n   *\n   * @type {VisOptions}\n   * @memberOf VisNetworkDirective\n   */\n  @Input()\n  public visNetworkOptions: Options;\n\n  /**\n   * This event will be raised when the network is initialized.\n   * At this point of time the network is successfully registered\n   * with the VisNetworkService and you can register to events.\n   * The event data is the name of the network as a string.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisNetworkDirective\n   */\n  @Output()\n  public initialized: EventEmitter<any> = new EventEmitter<any>();\n\n  private visNetworkContainer: any;\n  private isInitialized: boolean = false;\n\n  /**\n   * Creates an instance of VisNetworkDirective.\n   *\n   * @param {ElementRef} elementRef The HTML element reference.\n   * @param {VisNetworkService} visNetworkService The VisNetworkService.\n   *\n   * @memberOf VisNetworkDirective\n   */\n  public constructor(private elementRef: ElementRef, private visNetworkService: VisNetworkService) {\n    this.visNetworkContainer = elementRef.nativeElement;\n  }\n\n  /**\n   * Create the network when at least visNetwork and visData\n   * are defined.\n   *\n   * @memberOf VisNetworkDirective\n   */\n  public ngOnInit(): void {\n    if (!this.isInitialized && this.visNetwork && this.visNetworkData) {\n      this.createNetwork();\n    }\n  }\n\n  /**\n   * Update the network data or options on reference changes to\n   * the visData or visOptions properties.\n   *\n   * @param {{[propName: string]: SimpleChange}} changes\n   *\n   * @memberOf VisNetworkDirective\n   */\n  public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\n    if (!this.isInitialized && this.visNetwork && this.visNetworkData) {\n      this.createNetwork();\n    }\n\n    for (const propertyName in changes) {\n      if (changes.hasOwnProperty(propertyName)) {\n        const change = changes[propertyName];\n        if (!change.isFirstChange()) {\n          if (propertyName === 'visData') {\n            this.visNetworkService.setData(this.visNetwork, changes[propertyName].currentValue);\n          }\n          if (propertyName === 'visOptions') {\n            this.visNetworkService.setOptions(this.visNetwork, changes[propertyName].currentValue);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Calls the destroy function for this network instance.\n   *\n   * @memberOf VisNetworkDirective\n   */\n  public ngOnDestroy(): void {\n    this.isInitialized = false;\n    this.visNetworkService.destroy(this.visNetwork);\n  }\n\n  private createNetwork(): void {\n    this.visNetworkService.create(this.visNetwork, this.visNetworkContainer, this.visNetworkData, this.visNetworkOptions);\n    this.isInitialized = true;\n    this.initialized.emit(this.visNetwork);\n  }\n}\n","import { EventEmitter, Injectable, NgZone } from '@angular/core';\nimport {\n  DataGroupCollectionType,\n  DataItemCollectionType,\n  DateType,\n  IdType,\n  Timeline,\n  TimelineAnimationOptions,\n  TimelineEventPropertiesResult,\n  TimelineOptions\n} from 'vis-timeline';\n\n/**\n * A service to create, manage and control VisTimeline instances.\n *\n * @export\n * @class VisTimelineService\n */\n@Injectable()\nexport class VisTimelineService {\n  /**\n   * Fired when the current time bar redraws.\n   * The rate depends on the zoom level.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public currentTimeTick: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when clicked inside the Timeline.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public click: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when right-clicked inside the Timeline.\n   * Note that in order to prevent the context menu from showing up,\n   * default behavior of the event must be stopped.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public contextmenu: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when double clicked inside the Timeline.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public doubleClick: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * \tFired after the dragging of a group is finished.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public groupDragged: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired once after each graph redraw.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public changed: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired repeatedly when the timeline window is being changed.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public rangechange: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired once after the timeline window has been changed.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public rangechanged: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired after the user selects or deselects items by tapping or holding them.\n   * When a use taps an already selected item, the select event is fired again.\n   * Not fired when the method setSelectionis executed.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public select: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the user moves the mouse over an item.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public itemover: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired when the user moves the mouse out of an item.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public itemout: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired repeatedly when the user is dragging the custom time bar.\n   * Only available when the custom time bar is enabled.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public timechange: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Fired once after the user has dragged the custom time bar.\n   * Only available when the custom time bar is enabled.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineService\n   */\n  public timechanged: EventEmitter<any> = new EventEmitter<any>();\n\n  private events: Map<string, EventEmitter<any>> = new Map();\n\n  private timelines: { [id: string]: Timeline } = {};\n\n  constructor(\n    private ngZone: NgZone\n  ) { }\n\n  /**\n   * Creates a new timeline instance.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {HTMLElement} container The HTML element that contains the timeline view.\n   * @param {VisTimelineItems} items The initial timeline items.\n   * @param {VisTimelineOptions} [options] The timeline options.\n   *\n   * @throws {Error} Thrown when timeline already exists.\n   *\n   * @memberOf VisTimelineService\n   */\n  public createWithItems(visTimeline: string, container: HTMLElement, items: DataItemCollectionType, options?: TimelineOptions): void {\n    if (this.timelines[visTimeline]) {\n      throw new Error(this.alreadyExistsError(visTimeline));\n    }\n\n    this.timelines[visTimeline] = this.ngZone.runOutsideAngular(() => new Timeline(container, items, options));\n  }\n\n  /**\n   * Creates a new timeline instance.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {HTMLElement} container The HTML element that contains the timeline view.\n   * @param {VisTimelineItems} items The initial timeline items.\n   * @param {VisTimelineGroups} groups The initial timeline groups.\n   * @param {VisTimelineOptions} [options] The timeline options.\n   *\n   * @throws {Error} Thrown when timeline already exists.\n   *\n   * @memberOf VisTimelineService\n   */\n  public createWithItemsAndGroups(\n    visTimeline: string,\n    container: HTMLElement,\n    items: DataItemCollectionType,\n    groups: DataGroupCollectionType,\n    options?: TimelineOptions\n  ): void {\n    if (this.timelines[visTimeline]) {\n      throw new Error(this.alreadyExistsError(visTimeline));\n    }\n\n    this.timelines[visTimeline] = this.ngZone.runOutsideAngular(() => new Timeline(container, items, groups, options));\n  }\n\n  /**\n   * Add new vertical bar representing a custom time that can be dragged by the user.\n   * The id is added as CSS class name of the custom time bar,\n   * allowing to style multiple time bars differently.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {DateType} time Parameter time can be a Date, Number, or String, and is new Date() by default.\n   * @param {IdType} [id] Parameter id can be Number or String and is undefined by default.\n   * @returns {IdType} The method returns id of the created bar.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public addCustomTime(visTimeline: string, time: DateType, id?: IdType): IdType {\n    if (this.timelines[visTimeline]) {\n      return this.timelines[visTimeline].addCustomTime(time, id);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Adjust the visible window such that it fits all items.\n   * See also function focus(id).\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {TimelineAnimationOptions} [options] Optional options.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public fit(visTimeline: string, options?: TimelineAnimationOptions): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].fit(options);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Adjust the visible window such that the selected item is centered on screen.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {IdType} id The id of the item.\n   * @param {TimelineAnimationOptions} [options] Options options.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public focusOnId(visTimeline: string, id: IdType, options?: TimelineAnimationOptions): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].focus(id, options);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Adjust the visible window such that the selected items are centered on screen.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {IdType[]} ids The item ids.\n   * @param {TimelineAnimationOptions} [options] Optional options.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public focusOnIds(visTimeline: string, ids: IdType[], options?: TimelineAnimationOptions): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].focus(ids, options);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Get the current time.\n   * Only applicable when option showCurrentTime is true.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @returns {Date} The current time.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public getCurrentTime(visTimeline: string): Date {\n    if (this.timelines[visTimeline]) {\n      return this.timelines[visTimeline].getCurrentTime();\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Retrieve the custom time from the custom time bar with given id.\n   * Id is undefined by default.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {IdType} [id] The time bar id.\n   * @returns {Date} The custom time.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public getCustomTime(visTimeline: string, id?: IdType): Date {\n    if (this.timelines[visTimeline]) {\n      return this.timelines[visTimeline].getCustomTime(id);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Returns an Object with relevant properties from an event.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {Event} event The event.\n   * @returns {VisTimelineEventPropertiesResult} Properties of an event\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public getEventProperties(visTimeline: string, event: Event): TimelineEventPropertiesResult {\n    if (this.timelines[visTimeline]) {\n      return this.timelines[visTimeline].getEventProperties(event);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Get the range of all the items as an object containing min: Date and max: Date.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @returns {{ min: Date, max: Date }} The min and max dates.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public getItemRange(visTimeline: string): { min: Date; max: Date } {\n    if (this.timelines[visTimeline]) {\n      return this.timelines[visTimeline].getItemRange();\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Get an array with the ids of the currently selected items.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @returns {IdType[]} The currently selected items.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public getSelection(visTimeline: string): IdType[] {\n    if (this.timelines[visTimeline]) {\n      return this.timelines[visTimeline].getSelection();\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Get an array with the ids of the currently visible items.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @returns {IdType[]} The currently visible items.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public getVisibleItems(visTimeline: string): IdType[] {\n    if (this.timelines[visTimeline]) {\n      return this.timelines[visTimeline].getVisibleItems();\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Get the current visible window.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @returns {{ start: Date, end: Date }} Returns an object with properties start: Date and end: Date.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public getWindow(visTimeline: string): { start: Date; end: Date } {\n    if (this.timelines[visTimeline]) {\n      return this.timelines[visTimeline].getWindow();\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * \tMove the window such that given time is centered on screen.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {DateType} time Parameter time can be a Date, Number, or String.\n   * @param {TimelineAnimationOptions} [options] Optional options.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public moveTo(visTimeline: string, time: DateType, options?: TimelineAnimationOptions): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].moveTo(time, options);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Force a redraw of the Timeline.\n   * The size of all items will be recalculated.\n   * Can be useful to manually redraw when option autoResize=false and the window has been resized,\n   * or when the items CSS has been changed.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public redraw(visTimeline: string): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].redraw();\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Remove vertical bars previously added to the timeline via addCustomTime method.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {IdType} id Parameter id is the ID of the custom vertical bar returned by addCustomTime method.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public removeCustomTime(visTimeline: string, id: IdType): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].removeCustomTime(id);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Set a current time.\n   * This can be used for example to ensure that a client's time is synchronized\n   * with a shared server time.\n   * Only applicable when option showCurrentTime is true.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {DateType} time time can be a Date object, numeric timestamp, or ISO date string.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setCurrentTime(visTimeline: string, time: DateType): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setCurrentTime(time);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * \tAdjust the time of a custom time bar.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {DateType} time Parameter time can be a Date object, numeric timestamp, or ISO date string.\n   * @param {IdType} [id] Parameter id is the id of the custom time bar, and is undefined by default.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setCustomTime(visTimeline: string, time: DateType, id?: IdType): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setCustomTime(time, id);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Adjust the title attribute of a custom time bar.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {string} title Parameter title is the string to be set as title.\n   *                       Use empty string to hide the title completely.\n   * @param {IdType} [id] Parameter id is the id of the custom time bar, and is undefined by default.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setCustomTimeTitle(visTimeline: string, title: string, id?: IdType): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setCustomTimeTitle(title, id);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Set both groups and items at once.\n   * Both properties are optional.\n   * This is a convenience method for individually calling both setItems(items) and setGroups(groups).\n   * Both items and groups can be an Array with Objects, a DataSet (offering 2 way data binding),\n   * or a DataView (offering 1 way data binding).\n   * For each of the groups, the items of the timeline are filtered on the property group,\n   * which must correspond with the id of the group.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {{ groups?: VisTimelineGroups; items?: VisTimelineItems }} data The new timline data.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setData(visTimeline: string, data: { groups?: DataGroupCollectionType; items?: DataItemCollectionType }): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setData(data);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Set a data set with groups for the Timeline.\n   * For each of the groups, the items of the timeline are filtered on the property group,\n   * which must correspond with the id of the group.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {VisTimelineGroups} groups a DataSet (offering 2 way data binding)\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setGroups(visTimeline: string, groups: DataGroupCollectionType): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setGroups(groups);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Set a data set with items for the Timeline.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {VisTimelineItems} items can be an Array with Objects, a DataSet (offering 2 way data binding)\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setItems(visTimeline: string, items: DataItemCollectionType): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setItems(items);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Set or update options.\n   * It is possible to change any option of the timeline at any time.\n   * You can for example switch orientation on the fly.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {VisTimelineOptions} options The new options of the timeline.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setOptions(visTimeline: string, options: TimelineOptions): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setOptions(options);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Select one item by its id.#\n   * The currently selected items will be unselected.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {IdType} id The id of the item that should be selected.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setSelectionToId(visTimeline: string, id: IdType): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setSelection(id);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Select multiple items by their id.\n   * The currently selected items will be unselected.\n   * To unselect all selected items, call `setSelection([])`.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {IdType[]} ids The ids of the irems that should be selected.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setSelectionToIds(visTimeline: string, ids: IdType[]): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setSelection(ids);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Set the current visible window.\n   *\n   * If the parameter value of start or end is null, the parameter will be left unchanged.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {DateType} start The parameters start can be a Date, Number, or String.\n   * @param {DateType} end The parameters end can be a Date, Number, or String.\n   * @param {TimelineAnimationOptions} [options] Optional options.\n   *\n   * @throws {Error} Thrown when timeline does not exist.\n   *\n   * @memberOf VisTimelineService\n   */\n  public setWindow(visTimeline: string, start: DateType, end: DateType, options?: TimelineAnimationOptions): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].setWindow(start, end, options);\n    } else {\n      throw new Error(this.doesNotExistError(visTimeline));\n    }\n  }\n\n  /**\n   * Destroy the Timeline.\n   * The timeline is removed from memory.\n   * All DOM elements and event listeners are cleaned up.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   *\n   * @memberOf VisTimelineService\n   */\n  public destroy(visTimeline: string): void {\n    if (this.timelines[visTimeline]) {\n      this.timelines[visTimeline].destroy();\n      delete this.timelines[visTimeline];\n    }\n  }\n\n  /**\n   * Activates an event.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {string} eventName The event name.\n   * @param {boolean} preventDefault Stops the default behavior of the event.\n   * @returns {boolean} Returns true when the event was activated.\n   *\n   * @memberOf VisTimelineService\n   */\n  public on(visTimeline: string, eventName: string, preventDefault?: boolean): boolean {\n    if (this.timelines[visTimeline]) {\n      this.events.set(eventName, new EventEmitter<any>());\n      // tslint:disable-next-line\n      const that: { [index: string]: any } = this;\n      this.timelines[visTimeline].on(eventName, (params: any) => {\n        const emitter = (that[eventName] || that.events.get(eventName)) as EventEmitter<any>;\n        if (emitter) {\n          emitter.emit(params ? [visTimeline].concat(params) : visTimeline);\n        }\n        if (preventDefault && params.event) {\n          params.event.preventDefault();\n        }\n      });\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Deactivates an event.\n   *\n   * @param {string} visTimeline The timeline name/identifier.\n   * @param {string} eventName The event name.\n   *\n   * @memberOf VisTimelineService\n   */\n  public off(visTimeline: string, eventName: string): void {\n    if (this.timelines[visTimeline]) {\n      this.events.delete(eventName);\n      this.timelines[visTimeline].off(eventName, undefined);\n    }\n  }\n\n  /**\n   * Get the event emitter associated with the specified event name.\n   * @param {string} eventName The event name.\n   * @returns {EventEmitter<any>} The event emitter of the specified event name.\n   */\n  public getEmitter(eventName: string): EventEmitter<any> {\n    return this.events.get(eventName);\n  }\n\n  private doesNotExistError(visTimeline: string): string {\n    return `Timeline with id ${visTimeline} does not exist.`;\n  }\n\n  private alreadyExistsError(visTimeline: string): string {\n    return `Timeline with id ${visTimeline} already exists.`;\n  }\n}\n","import { Directive, ElementRef, EventEmitter, Input, OnChanges, OnDestroy, OnInit, Output, SimpleChange } from '@angular/core';\nimport { DataGroupCollectionType, DataItemCollectionType, TimelineOptions } from 'vis-timeline';\n\nimport { VisTimelineService } from './vis-timeline.service';\n\n/**\n * Use this directive with a div container to show timeline data.\n *\n * @export\n * @class VisTimelineDirective\n * @implements {OnInit}\n * @implements {OnDestroy}\n * @implements {OnChanges}\n */\n@Directive({\n  selector: '[visTimeline]'\n})\nexport class VisTimelineDirective implements OnInit, OnDestroy, OnChanges {\n  /**\n   * The name or identifier of the timeline (must be unique in your application).\n   * This property is used once on init and must not be changed.\n   *\n   * @type {string}\n   * @memberOf VisTimelineDirective\n   */\n  @Input('visTimeline')\n  public visTimeline: string;\n\n  /**\n   * The data that will be used to create the timeline.\n   * Changes will be detected. If the reference changes then\n   * setData will be called on this timeline instance.\n   *\n   * @type {VisTimelineItems}\n   * @memberOf VisTimelineDirective\n   */\n  @Input()\n  public visTimelineItems: DataItemCollectionType;\n\n  /**\n   * The groups that will be used to create the timeline.\n   * Changes will be detected. If the reference changes then\n   * setGroups will be called on this timeline instance.\n   *\n   * @type {VisTimelineGroups}\n   * @memberOf VisTimelineDirective\n   */\n  @Input()\n  public visTimelineGroups: DataGroupCollectionType;\n\n  /**\n   * The options that will be used with this timeline.\n   * Changes will be detected. If the reference changes then\n   * setOptions will be called on this timeline instance.\n   *\n   * @type {VisTimelineOptions}\n   * @memberOf VisTimelineDirective\n   */\n  @Input()\n  public visTimelineOptions: TimelineOptions;\n\n  /**\n   * This event will be raised when the timline is initialized.\n   * At this point of time the timeline is successfully registered\n   * with the VisNetworkService and you can register to events.\n   * The event data is the name of the timeline as a string.\n   *\n   * @type {EventEmitter<any>}\n   * @memberOf VisTimelineDirective\n   */\n  @Output()\n  public initialized: EventEmitter<any> = new EventEmitter<any>();\n\n  private visTimelineContainer: any;\n  private isInitialized: boolean = false;\n\n  /**\n   * Creates an instance of VisTimelineDirective.\n   *\n   * @param {ElementRef} elementRef The HTML element reference.\n   * @param {VisTimelineService} visTimelineService The VisTimelineService.\n   *\n   * @memberOf VisTimelineDirective\n   */\n  public constructor(private elementRef: ElementRef, private visTimelineService: VisTimelineService) {\n    this.visTimelineContainer = elementRef.nativeElement;\n  }\n\n  /**\n   * Create the timeline when at least visNetwork and visNetworkData\n   * are defined.\n   *\n   * @memberOf VisTimelineDirective\n   */\n  public ngOnInit(): void {\n    if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {\n      this.createTimeline();\n    }\n  }\n\n  /**\n   * Update the timeline data, groups or options on reference changes to\n   * the visTimelineItems, visTimelineGroups or visTimelineOptions properties.\n   *\n   * @param {{[propName: string]: SimpleChange}} changes\n   *\n   * @memberOf VisTimelineDirective\n   */\n  public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\n    if (!this.isInitialized && this.visTimeline && this.visTimelineItems) {\n      this.createTimeline();\n    }\n\n    for (const propertyName in changes) {\n      if (changes.hasOwnProperty(propertyName)) {\n        const change = changes[propertyName];\n        if (!change.isFirstChange()) {\n          if (propertyName === 'visTimelineItems') {\n            this.visTimelineService.setItems(this.visTimeline, changes[propertyName].currentValue);\n          }\n          if (propertyName === 'visTimelineOptions') {\n            this.visTimelineService.setOptions(this.visTimeline, changes[propertyName].currentValue);\n          }\n          if (propertyName === 'visTimelineGroups') {\n            this.visTimelineService.setGroups(this.visTimeline, changes[propertyName].currentValue);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Calls the destroy function for this timeline instance.\n   *\n   *\n   * @memberOf VisTimelineDirective\n   */\n  public ngOnDestroy(): void {\n    this.isInitialized = false;\n    this.visTimelineService.destroy(this.visTimeline);\n  }\n\n  private createTimeline(): void {\n    if (this.visTimelineGroups) {\n      this.visTimelineService.createWithItemsAndGroups(\n        this.visTimeline,\n        this.visTimelineContainer,\n        this.visTimelineItems,\n        this.visTimelineGroups,\n        this.visTimelineOptions\n      );\n    } else {\n      this.visTimelineService.createWithItems(this.visTimeline, this.visTimelineContainer, this.visTimelineItems, this.visTimelineOptions);\n    }\n    this.isInitialized = true;\n    this.initialized.emit(this.visTimeline);\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { CUSTOM_ELEMENTS_SCHEMA, NgModule, NO_ERRORS_SCHEMA } from '@angular/core';\nimport { Data, DataSet, Edge, Node, Options } from 'vis-network';\nimport { DataGroup, DataGroupCollectionType, DataItem, DataItemCollectionType, TimelineOptions } from 'vis-timeline';\n\nimport { VisNetworkDirective } from './components/network/vis-network.directive';\nimport { VisNetworkService } from './components/network/vis-network.service';\nimport { VisTimelineDirective } from './components/timeline/vis-timeline.directive';\nimport { VisTimelineService } from './components/timeline/vis-timeline.service';\n\nexport {\n  VisNetworkDirective,\n  VisTimelineDirective,\n  VisTimelineService,\n  VisNetworkService,\n  Data,\n  DataSet,\n  Edge,\n  Options,\n  DataItem,\n  DataGroup,\n  DataGroupCollectionType,\n  DataItemCollectionType,\n  Node,\n  TimelineOptions\n};\n\n@NgModule({\n  declarations: [VisNetworkDirective, VisTimelineDirective],\n  exports: [VisNetworkDirective, VisTimelineDirective],\n  imports: [CommonModule],\n  providers: [VisNetworkService, VisTimelineService],\n  schemas: [CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA]\n})\nexport class VisModule {}\n"]}