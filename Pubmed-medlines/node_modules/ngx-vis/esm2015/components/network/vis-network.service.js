import * as tslib_1 from "tslib";
import { EventEmitter, Injectable } from '@angular/core';
import { Network } from 'vis-network';
/**
 * A service to create, manage and control Network instances.
 *
 * @export
 * @class NetworkService
 */
let VisNetworkService = class VisNetworkService {
    /**
     * A service to create, manage and control Network instances.
     *
     * @export
     * @class NetworkService
     */
    constructor() {
        /**
         * Fired when the user clicks the mouse or taps on a touchscreen device.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.click = new EventEmitter();
        /**
         * Fired when the user double clicks the mouse or double taps on a touchscreen device.
         * Since a double click is in fact 2 clicks, 2 click events are fired, followed by a double click event.
         * If you do not want to use the click events if a double click event is fired,
         * just check the time between click events before processing them.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.doubleClick = new EventEmitter();
        /**
         * Fired when the user click on the canvas with the right mouse button.
         * The right mouse button does not select by default.
         * You can use the method getNodeAt to select the node if you want.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.oncontext = new EventEmitter();
        /**
         * Fired when the user clicks and holds the mouse or taps and holds on a touchscreen device.
         * A click event is also fired in this case.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hold = new EventEmitter();
        /**
         * Fired after drawing on the canvas has been completed.
         * Can be used to draw on top of the network.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.release = new EventEmitter();
        /**
         * Fired when the selection has changed by user action.
         * This means a node or edge has been selected, added to the selection or deselected.
         * All select events are only triggered on click and hold.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.select = new EventEmitter();
        /**
         * Fired when a node has been selected by the user.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.selectNode = new EventEmitter();
        /**
         * Fired when a edge has been selected by the user.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.selectEdge = new EventEmitter();
        /**
         * Fired when a node (or nodes) has (or have) been deselected by the user.
         * The previous selection is the list of nodes and edges that were selected before the last user event.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.deselectNode = new EventEmitter();
        /**
         * Fired when a edge (or edges) has (or have) been deselected by the user.
         * The previous selection is the list of nodes and edges that were selected before the last user event.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.deselectEdge = new EventEmitter();
        /**
         * Fired when starting a drag.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.dragStart = new EventEmitter();
        /**
         * Fired when dragging node(s) or the view.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.dragging = new EventEmitter();
        /**
         * Fired when the drag has finished.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.dragEnd = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over a node.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hoverNode = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and
         * the mouse moved away from a node it was hovering over before.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.blurNode = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over an edge.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hoverEdge = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and
         * the mouse moved away from an edge it was hovering over before.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.blurEdge = new EventEmitter();
        /**
         * Fired when the user zooms in or out.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.zoom = new EventEmitter();
        /**
         * Fired when the popup (tooltip) is shown.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.showPopup = new EventEmitter();
        /**
         * Fired when the popup (tooltip) is hidden.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hidePopup = new EventEmitter();
        /**
         * Fired when stabilization starts.
         * This is also the case when you drag a node and the physics
         * simulation restarts to stabilize again.
         * Stabilization does not neccesarily imply 'without showing'.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.startStabilizing = new EventEmitter();
        /**
         * Fired when a multiple of the updateInterval number of iterations is reached.
         * This only occurs in the 'hidden' stabilization.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.stabilizationProgress = new EventEmitter();
        /**
         * Fired when the 'hidden' stabilization finishes.
         * This does not necessarily mean the network is stabilized;
         * it could also mean that the amount of iterations defined in the options has been reached.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.stabilizationIterationsDone = new EventEmitter();
        /**
         * Fired when the 'hidden' stabilization finishes.
         * This does not necessarily mean the network is stabilized;
         * it could also mean that the amount of iterations defined in the options has been reached.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.stabilized = new EventEmitter();
        /**
         * Fired when the size of the canvas has been resized,
         * either by a redraw call when the container div has changed in size,
         * a setSize() call with new values or a setOptions() with new width and/or height values.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.resize = new EventEmitter();
        /**
         * Fired before the redrawing begins.
         * The simulation step has completed at this point.
         * Can be used to move custom elements before starting drawing the new frame.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.initRedraw = new EventEmitter();
        /**
         * Fired after the canvas has been cleared, scaled and translated to
         * the viewing position but before all edges and nodes are drawn.
         * Can be used to draw behind the network.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.beforeDrawing = new EventEmitter();
        /**
         * Fired after drawing on the canvas has been completed.
         * Can be used to draw on top of the network.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.afterDrawing = new EventEmitter();
        /**
         * Fired when an animation is finished.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.animationFinished = new EventEmitter();
        /**
         * Fired when a user changes any option in the configurator.
         * The options object can be used with the setOptions method or stringified using JSON.stringify().
         * You do not have to manually put the options into the network: this is done automatically.
         * You can use the event to store user options in the database.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.configChange = new EventEmitter();
        this.networks = {};
    }
    /**
     * Creates a new network instance.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {HTMLElement} container The HTML element that contains the network view.
     * @param {Data} data The initial network nodes and edges.
     * @param {Options} [options] The network options.
     *
     * @throws {Error} Thrown when a network with the same name already exists.
     *
     * @memberOf NetworkService
     */
    create(visNetwork, container, data, options) {
        if (this.networks[visNetwork]) {
            throw new Error(`Network with id ${visNetwork} already exists.`);
        }
        this.networks[visNetwork] = new Network(container, data, options);
    }
    /**
     * Remove the network from the DOM and remove all Hammer bindings and references.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @memberOf NetworkService
     */
    destroy(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].destroy();
            delete this.networks[visNetwork];
        }
    }
    /**
     * Activates an event.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {NetworkEvents} eventName The event name.
     * @param {boolean} preventDefault Stops the default behavior of the event.
     * @returns {boolean} Returns true when the event was activated.
     *
     * @memberOf NetworkService
     */
    on(visNetwork, eventName, preventDefault) {
        if (this.networks[visNetwork]) {
            /* tslint:disable */
            const that = this;
            /* tslint:enable */
            this.networks[visNetwork].on(eventName, (params) => {
                const emitter = that[eventName];
                if (emitter) {
                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);
                }
                if (preventDefault && params.event) {
                    params.event.preventDefault();
                }
            });
            return true;
        }
        return false;
    }
    /**
     * Deactivates an event.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {NetworkEvents} eventName The event name.
     *
     * @memberOf NetworkService
     */
    off(visNetwork, eventName) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].off(eventName);
        }
    }
    /**
     * Activates an event listener only once.
     * After it has taken place, the event listener will be removed.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {NetworkEvents} eventName The event name.
     * @returns {boolean} Returns true when the event was activated.
     *
     * @memberOf NetworkService
     */
    once(visNetwork, eventName) {
        if (this.networks[visNetwork]) {
            /* tslint:disable */
            const that = this;
            /* tslint:disable */
            this.networks[visNetwork].on(eventName, (params) => {
                const emitter = that[eventName];
                if (emitter) {
                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);
                    this.off(visNetwork, eventName);
                }
            });
            return true;
        }
        return false;
    }
    /**
     * Override all the data in the network.
     * If stabilization is enabled in the physics module,
     * the network will stabilize again.
     * This method is also performed when first initializing the network.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Data} data The network data.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    setData(visNetwork, data) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].setData(data);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Set the options.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Options} options The network options.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    setOptions(visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].setOptions(options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Selects the nodes corresponding to the id's in the input array.
     * This method unselects all other objects before selecting its own objects.
     * Does not fire events.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType[]} nodeIds The node ids that should be selected.
     * @param {boolean} [highlightEdges] If highlightEdges is true or undefined,
     *                                   the neighbouring edges will also be selected.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    selectNodes(visNetwork, nodeIds, highlightEdges) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].selectNodes(nodeIds, highlightEdges);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Selects the nodes and edges corresponding to the id's in the input arrays.
     * Does not fire events.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param { nodes: IdType[], edges: IdType[] } selection The node and edge ids that should be selected.
     * @param { unselectAll?: boolean, highlightEdges?: boolean } [options]
     * If unselectAll is true or undefined, the other objects will be deselected.
     * If highlightEdges is true or undefined, the neighbouring edges will also be selected.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    setSelection(visNetwork, selection, options = {}) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].setSelection(selection, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Returns an object with selected nodes and edges ids.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {{ nodes: IdType[], edges: IdType[] }}
     * The selected node and edge ids or undefined when the network does not exist.
     *
     * @memberOf NetworkService
     */
    getSelection(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSelection();
        }
        return undefined;
    }
    /**
     * Returns an array of selected node ids.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {IdType[]} The selected node ids or undefined when the network does not exist.
     *
     * @memberOf NetworkService
     */
    getSelectedNodes(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSelectedNodes();
        }
        return undefined;
    }
    /**
     * Returns an array of selected edge ids.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {IdType[]} The selected edge ids or undefined when the network does not exist.
     *
     * @memberOf NetworkService
     */
    getSelectedEdges(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSelectedEdges();
        }
        return undefined;
    }
    /**
     * Unselect all objects.
     * Does not fire events.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    unselectAll(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].unselectAll();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Zooms out so all nodes fit on the canvas.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {VisFitOptions} [options] Options to customize.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    fit(visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].fit(options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Redraw the network.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    redraw(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].redraw();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Go into addNode mode. Having edit mode or manipulation enabled is not required.
     * To get out of this mode, call disableEditMode(). The callback functions defined in handlerFunctions still apply.
     * To use these methods without having the manipulation GUI, make sure you set enabled to false.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    addNodeMode(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].addNodeMode();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Programatically enable the edit mode.
     * Similar effect to pressing the edit button.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    enableEditMode(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].enableEditMode();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Go into addEdge mode.
     * The explaination from addNodeMode applies here as well.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    addEdgeMode(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].addEdgeMode();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Programatically disable the edit mode.
     * Similar effect to pressing the close icon
     * (small cross in the corner of the toolbar).
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    disableEditMode(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].disableEditMode();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Delete selected.
     * Having edit mode or manipulation enabled is not required.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    deleteSelected(visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].deleteSelected();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Makes a cluster.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {ClusterOptions} [options] The joinCondition function is presented with all nodes.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    cluster(visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].cluster(options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * This method looks at the provided node and makes a cluster of it and all it's connected nodes.
     * The behaviour can be customized by proving the options object.
     * All options of this object are explained below.
     * The joinCondition is only presented with the connected nodes.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId the id of the node
     * @param {ClusterOptions} [options] the cluster options
     *
     * @memberOf NetworkService
     */
    clusterByConnection(visNetwork, nodeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].clusterByConnection(nodeId, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * This method checks all nodes in the network and those with a equal or higher
     * amount of edges than specified with the hubsize qualify.
     * If a hubsize is not defined, the hubsize will be determined as the average
     * value plus two standard deviations.
     * For all qualifying nodes, clusterByConnection is performed on each of them.
     * The options object is described for clusterByConnection and does the same here.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {number} [hubsize] optional hubsize
     * @param {ClusterOptions} [options] optional cluster options
     *
     * @memberOf NetworkService
     */
    clusterByHubsize(visNetwork, hubsize, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].clusterByHubsize(hubsize, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * This method will cluster all nodes with 1 edge with their respective connected node.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {ClusterOptions} [options] optional cluster options
     *
     * @memberOf NetworkService
     */
    clusterOutliers(visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].clusterOutliers(options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Nodes can be in clusters.
     * Clusters can also be in clusters.
     * This function returns an array of nodeIds showing where the node is.
     *
     * Example:
     * cluster 'A' contains cluster 'B', cluster 'B' contains cluster 'C',
     * cluster 'C' contains node 'fred'.
     *
     * network.clustering.findNode('fred') will return ['A','B','C','fred'].
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId the node id.
     * @returns {IdType[]} an array of nodeIds showing where the node is
     *
     * @memberOf NetworkService
     */
    findNode(visNetwork, nodeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].findNode(nodeId);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Similar to findNode in that it returns all the edge ids that were
     * created from the provided edge during clustering.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} baseEdgeId the base edge id
     * @returns {IdType[]} an array of edgeIds
     *
     * @memberOf NetworkService
     */
    getClusteredEdges(visNetwork, baseEdgeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getClusteredEdges(baseEdgeId);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * When a clusteredEdgeId is available, this method will return the original
     * baseEdgeId provided in data.edges ie.
     * After clustering the 'SelectEdge' event is fired but provides only the clustered edge.
     * This method can then be used to return the baseEdgeId.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} clusteredEdgeId
     * @returns {IdType}
     *
     * @memberOf NetworkService
     *
     */
    getBaseEdge(visNetwork, clusteredEdgeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getBaseEdge(clusteredEdgeId);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Visible edges between clustered nodes are not the same edge as the ones provided
     * in data.edges passed on network creation. With each layer of clustering, copies of
     * the edges between clusters are created and the previous edges are hidden,
     * until the cluster is opened. This method takes an edgeId (ie. a base edgeId from data.edges)
     * and applys the options to it and any edges that were created from it while clustering.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} startEdgeId
     * @param {VisEdgeOptions} [options]
     *
     * @memberOf NetworkService
     *
     */
    updateEdge(visNetwork, startEdgeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].updateEdge(startEdgeId, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Clustered Nodes when created are not contained in the original data.nodes
     * passed on network creation. This method updates the cluster node.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} clusteredNodeId
     * @param {NodeOptions} options
     *
     * @memberOf NetworkService
     */
    updateClusteredNode(visNetwork, clusteredNodeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].updateClusteredNode(clusteredNodeId, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Returns an array of all nodeIds of the nodes that
     * would be released if you open the cluster.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} clusterNodeId the id of the cluster node
     * @returns {IdType[]}
     *
     * @memberOf NetworkService
     */
    getNodesInCluster(visNetwork, clusterNodeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getNodesInCluster(clusterNodeId);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Opens the cluster, releases the contained nodes and edges,
     * removing the cluster node and cluster edges.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId The node id that represents the cluster.
     * @param {OpenClusterOptions} [options] Cluster options.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    openCluster(visNetwork, nodeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].openCluster(nodeId, options);
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
    /**
     * Returns true if the node whose ID has been supplied is a cluster.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId The associated node id.
     * @returns {boolean} True if the node whose ID has been supplied is a cluster.
     *
     * @memberOf NetworkService
     */
    isCluster(visNetwork, nodeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].isCluster(nodeId);
        }
        return false;
    }
    /**
     * If you like the layout of your network and would like it to start in the same way next time,
     * ask for the seed using this method and put it in the layout.randomSeed option.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {number} The seed of the current network or -1 when the network is not defined.
     *
     * @memberOf NetworkService
     */
    getSeed(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSeed();
        }
        return -1;
    }
    /**
     * This function converts canvas coordinates to coordinates on the DOM.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The canvas position.
     * @returns {Position} The DOM position.
     *
     * @memberOf NetworkService
     */
    canvasToDOM(visNetwork, position) {
        return this.networks[visNetwork].canvasToDOM(position);
    }
    /**
     * This function converts DOM coordinates to coordinates on the canvas.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The DOM position.
     * @returns {Position} The canvas position.
     *
     * @memberOf NetworkService
     */
    DOMtoCanvas(visNetwork, position) {
        return this.networks[visNetwork].DOMtoCanvas(position);
    }
    /**
     * This function looks up the node at the given DOM coordinates on the canvas.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container -> DOM not Canvas coords.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The DOM position.
     * @returns {IdType} nodeId The associated node id.
     *
     * @memberOf NetworkService
     */
    getNodeAt(visNetwork, position) {
        return this.networks[visNetwork].getNodeAt(position);
    }
    /**
     * This function looks up the edge at the given DOM coordinates on the canvas.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container -> DOM not Canvas coords.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The DOM position.
     * @returns {IdType} edgeId The associated edge id.
     *
     * @memberOf NetworkService
     */
    getEdgeAt(visNetwork, position) {
        return this.networks[visNetwork].getEdgeAt(position);
    }
    /**
     * This function looks up the edges for a given nodeId.
     * The DOM values are relative to the network container -> DOM not Canvas coords.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId The associated node id.
     * @returns {IdType[]} Return array of edge ids
     *
     * @memberOf NetworkService
     */
    getConnectedEdges(visNetwork, nodeId) {
        return this.networks[visNetwork].getConnectedEdges(nodeId);
    }
    /**
     * Returns an array of nodeIds of the all the nodes that are directly connected to this node.
     * If you supply an edgeId, vis will first match the id to nodes.
     * If no match is found, it will search in the edgelist and return an array: [fromId, toId].
     *
     * @param {string} visNetwork The network name/identifier.
     * @param nodeOrEdgeId a node or edge id
     * @returns {IdType[]} Return array of node ids
     */
    getConnectedNodes(visNetwork, nodeOrEdgeId) {
        return this.networks[visNetwork].getConnectedNodes(nodeOrEdgeId);
    }
    /**
     * Returns the positions of the nodes.
     * @param {string} visNetwork The network name/identifier.
     * @param {Array.<Node.id>|String} [ids]  --> optional, can be array of nodeIds, can be string
     * @returns {{}}
     */
    getPositions(visNetwork, nodeIds) {
        return this.networks[visNetwork].getPositions(nodeIds);
    }
    /**
     * Returns the positions of the nodes.
     * @param {string} visNetwork The network name/identifier.
     */
    getBoundingBox(visNetwork, nodeId) {
        return this.networks[visNetwork].getBoundingBox(nodeId);
    }
    /**
     * Returns the positions of the nodes.
     * @param {string} visNetwork The network name/identifier.
     */
    storePositions(visNetwork) {
        return this.networks[visNetwork].storePositions();
    }
    /**
     * You can animate or move the camera using the moveTo method.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {MoveToOptions} options Options for moveTo function.
     */
    moveTo(visNetwork, moveToOptions) {
        return this.networks[visNetwork].moveTo(moveToOptions);
    }
    /**
     * Start the physics simulation.
     * This is normally done whenever needed and is only really useful
     * if you stop the simulation yourself and wish to continue it afterwards.
     * @param {string} visNetwork The network name/identifier.
     */
    startSimulation(visNetwork) {
        return this.networks[visNetwork].startSimulation();
    }
    /**
     * This stops the physics simulation and triggers a stabilized event.
     * Tt can be restarted by dragging a node,
     * altering the dataset or calling startSimulation().
     * @param {string} visNetwork The network name/identifier.
     */
    stopSimulation(visNetwork) {
        return this.networks[visNetwork].stopSimulation();
    }
    /**
     * Returns the current scale of the network. 1.0 is comparible to 100%, 0 is zoomed out infinitely.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    getScale(visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getScale();
        }
        else {
            throw new Error(`Network with id ${visNetwork} not found.`);
        }
    }
};
VisNetworkService = tslib_1.__decorate([
    Injectable()
], VisNetworkService);
export { VisNetworkService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlzLW5ldHdvcmsuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC12aXMvIiwic291cmNlcyI6WyJjb21wb25lbnRzL25ldHdvcmsvdmlzLW5ldHdvcmsuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDekQsT0FBTyxFQVFMLE9BQU8sRUFNUixNQUFNLGFBQWEsQ0FBQztBQUVyQjs7Ozs7R0FLRztBQUVILElBQWEsaUJBQWlCLEdBQTlCLE1BQWEsaUJBQWlCO0lBUDlCOzs7OztPQUtHO0lBQ0g7UUFFRTs7Ozs7V0FLRztRQUNJLFVBQUssR0FBc0IsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUUxRDs7Ozs7Ozs7V0FRRztRQUNJLGdCQUFXLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFaEU7Ozs7Ozs7V0FPRztRQUNJLGNBQVMsR0FBc0IsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUU5RDs7Ozs7O1dBTUc7UUFDSSxTQUFJLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFekQ7Ozs7OztXQU1HO1FBQ0ksWUFBTyxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBRTVEOzs7Ozs7O1dBT0c7UUFDSSxXQUFNLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFM0Q7Ozs7O1dBS0c7UUFDSSxlQUFVLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFL0Q7Ozs7O1dBS0c7UUFDSSxlQUFVLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFL0Q7Ozs7OztXQU1HO1FBQ0ksaUJBQVksR0FBc0IsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUVqRTs7Ozs7O1dBTUc7UUFDSSxpQkFBWSxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBRWpFOzs7OztXQUtHO1FBQ0ksY0FBUyxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBRTlEOzs7OztX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O0lBRUQ7Ozs7O09BS0c7SUFDSSxjQUFjLENBQUMsVUFBa0I7UUFDdEMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ3BELENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLFFBQVEsQ0FBQyxVQUFrQjtRQUNoQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDN0IsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQzdDO2FBQU07WUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixVQUFVLGFBQWEsQ0FBQyxDQUFDO1NBQzdEO0lBQ0gsQ0FBQztDQUNGLENBQUE7QUEvaUNZLGlCQUFpQjtJQUQ3QixVQUFVLEVBQUU7R0FDQSxpQkFBaUIsQ0EraUM3QjtTQS9pQ1ksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBCb3VuZGluZ0JveCxcbiAgQ2x1c3Rlck9wdGlvbnMsXG4gIERhdGEsXG4gIEVkZ2VPcHRpb25zLFxuICBGaXRPcHRpb25zLFxuICBJZFR5cGUsXG4gIE1vdmVUb09wdGlvbnMsXG4gIE5ldHdvcmssXG4gIE5ldHdvcmtFdmVudHMsXG4gIE5vZGVPcHRpb25zLFxuICBPcGVuQ2x1c3Rlck9wdGlvbnMsXG4gIE9wdGlvbnMsXG4gIFBvc2l0aW9uXG59IGZyb20gJ3Zpcy1uZXR3b3JrJztcblxuLyoqXG4gKiBBIHNlcnZpY2UgdG8gY3JlYXRlLCBtYW5hZ2UgYW5kIGNvbnRyb2wgTmV0d29yayBpbnN0YW5jZXMuXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIE5ldHdvcmtTZXJ2aWNlXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBWaXNOZXR3b3JrU2VydmljZSB7XG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgbW91c2Ugb3IgdGFwcyBvbiBhIHRvdWNoc2NyZWVuIGRldmljZS5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjbGljazogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIHRoZSBtb3VzZSBvciBkb3VibGUgdGFwcyBvbiBhIHRvdWNoc2NyZWVuIGRldmljZS5cbiAgICogU2luY2UgYSBkb3VibGUgY2xpY2sgaXMgaW4gZmFjdCAyIGNsaWNrcywgMiBjbGljayBldmVudHMgYXJlIGZpcmVkLCBmb2xsb3dlZCBieSBhIGRvdWJsZSBjbGljayBldmVudC5cbiAgICogSWYgeW91IGRvIG5vdCB3YW50IHRvIHVzZSB0aGUgY2xpY2sgZXZlbnRzIGlmIGEgZG91YmxlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLFxuICAgKiBqdXN0IGNoZWNrIHRoZSB0aW1lIGJldHdlZW4gY2xpY2sgZXZlbnRzIGJlZm9yZSBwcm9jZXNzaW5nIHRoZW0uXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZG91YmxlQ2xpY2s6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2sgb24gdGhlIGNhbnZhcyB3aXRoIHRoZSByaWdodCBtb3VzZSBidXR0b24uXG4gICAqIFRoZSByaWdodCBtb3VzZSBidXR0b24gZG9lcyBub3Qgc2VsZWN0IGJ5IGRlZmF1bHQuXG4gICAqIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgZ2V0Tm9kZUF0IHRvIHNlbGVjdCB0aGUgbm9kZSBpZiB5b3Ugd2FudC5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBvbmNvbnRleHQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGFuZCBob2xkcyB0aGUgbW91c2Ugb3IgdGFwcyBhbmQgaG9sZHMgb24gYSB0b3VjaHNjcmVlbiBkZXZpY2UuXG4gICAqIEEgY2xpY2sgZXZlbnQgaXMgYWxzbyBmaXJlZCBpbiB0aGlzIGNhc2UuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgaG9sZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgYWZ0ZXIgZHJhd2luZyBvbiB0aGUgY2FudmFzIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAgICogQ2FuIGJlIHVzZWQgdG8gZHJhdyBvbiB0b3Agb2YgdGhlIG5ldHdvcmsuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcmVsZWFzZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkIGJ5IHVzZXIgYWN0aW9uLlxuICAgKiBUaGlzIG1lYW5zIGEgbm9kZSBvciBlZGdlIGhhcyBiZWVuIHNlbGVjdGVkLCBhZGRlZCB0byB0aGUgc2VsZWN0aW9uIG9yIGRlc2VsZWN0ZWQuXG4gICAqIEFsbCBzZWxlY3QgZXZlbnRzIGFyZSBvbmx5IHRyaWdnZXJlZCBvbiBjbGljayBhbmQgaG9sZC5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzZWxlY3Q6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gYSBub2RlIGhhcyBiZWVuIHNlbGVjdGVkIGJ5IHRoZSB1c2VyLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHNlbGVjdE5vZGU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gYSBlZGdlIGhhcyBiZWVuIHNlbGVjdGVkIGJ5IHRoZSB1c2VyLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHNlbGVjdEVkZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gYSBub2RlIChvciBub2RlcykgaGFzIChvciBoYXZlKSBiZWVuIGRlc2VsZWN0ZWQgYnkgdGhlIHVzZXIuXG4gICAqIFRoZSBwcmV2aW91cyBzZWxlY3Rpb24gaXMgdGhlIGxpc3Qgb2Ygbm9kZXMgYW5kIGVkZ2VzIHRoYXQgd2VyZSBzZWxlY3RlZCBiZWZvcmUgdGhlIGxhc3QgdXNlciBldmVudC5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkZXNlbGVjdE5vZGU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gYSBlZGdlIChvciBlZGdlcykgaGFzIChvciBoYXZlKSBiZWVuIGRlc2VsZWN0ZWQgYnkgdGhlIHVzZXIuXG4gICAqIFRoZSBwcmV2aW91cyBzZWxlY3Rpb24gaXMgdGhlIGxpc3Qgb2Ygbm9kZXMgYW5kIGVkZ2VzIHRoYXQgd2VyZSBzZWxlY3RlZCBiZWZvcmUgdGhlIGxhc3QgdXNlciBldmVudC5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkZXNlbGVjdEVkZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gc3RhcnRpbmcgYSBkcmFnLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGRyYWdTdGFydDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiBkcmFnZ2luZyBub2RlKHMpIG9yIHRoZSB2aWV3LlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGRyYWdnaW5nOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBkcmFnIGhhcyBmaW5pc2hlZC5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkcmFnRW5kOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCBpZiB0aGUgb3B0aW9uIGludGVyYWN0aW9uOntob3Zlcjp0cnVlfSBpcyBlbmFibGVkIGFuZCB0aGUgbW91c2UgaG92ZXJzIG92ZXIgYSBub2RlLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGhvdmVyTm9kZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgaWYgdGhlIG9wdGlvbiBpbnRlcmFjdGlvbjp7aG92ZXI6dHJ1ZX0gaXMgZW5hYmxlZCBhbmRcbiAgICogdGhlIG1vdXNlIG1vdmVkIGF3YXkgZnJvbSBhIG5vZGUgaXQgd2FzIGhvdmVyaW5nIG92ZXIgYmVmb3JlLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGJsdXJOb2RlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCBpZiB0aGUgb3B0aW9uIGludGVyYWN0aW9uOntob3Zlcjp0cnVlfSBpcyBlbmFibGVkIGFuZCB0aGUgbW91c2UgaG92ZXJzIG92ZXIgYW4gZWRnZS5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBob3ZlckVkZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIGlmIHRoZSBvcHRpb24gaW50ZXJhY3Rpb246e2hvdmVyOnRydWV9IGlzIGVuYWJsZWQgYW5kXG4gICAqIHRoZSBtb3VzZSBtb3ZlZCBhd2F5IGZyb20gYW4gZWRnZSBpdCB3YXMgaG92ZXJpbmcgb3ZlciBiZWZvcmUuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgYmx1ckVkZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgem9vbXMgaW4gb3Igb3V0LlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHpvb206IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHBvcHVwICh0b29sdGlwKSBpcyBzaG93bi5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzaG93UG9wdXA6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHBvcHVwICh0b29sdGlwKSBpcyBoaWRkZW4uXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgaGlkZVBvcHVwOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHN0YWJpbGl6YXRpb24gc3RhcnRzLlxuICAgKiBUaGlzIGlzIGFsc28gdGhlIGNhc2Ugd2hlbiB5b3UgZHJhZyBhIG5vZGUgYW5kIHRoZSBwaHlzaWNzXG4gICAqIHNpbXVsYXRpb24gcmVzdGFydHMgdG8gc3RhYmlsaXplIGFnYWluLlxuICAgKiBTdGFiaWxpemF0aW9uIGRvZXMgbm90IG5lY2Nlc2FyaWx5IGltcGx5ICd3aXRob3V0IHNob3dpbmcnLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHN0YXJ0U3RhYmlsaXppbmc6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gYSBtdWx0aXBsZSBvZiB0aGUgdXBkYXRlSW50ZXJ2YWwgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgaXMgcmVhY2hlZC5cbiAgICogVGhpcyBvbmx5IG9jY3VycyBpbiB0aGUgJ2hpZGRlbicgc3RhYmlsaXphdGlvbi5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzdGFiaWxpemF0aW9uUHJvZ3Jlc3M6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlICdoaWRkZW4nIHN0YWJpbGl6YXRpb24gZmluaXNoZXMuXG4gICAqIFRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbiB0aGUgbmV0d29yayBpcyBzdGFiaWxpemVkO1xuICAgKiBpdCBjb3VsZCBhbHNvIG1lYW4gdGhhdCB0aGUgYW1vdW50IG9mIGl0ZXJhdGlvbnMgZGVmaW5lZCBpbiB0aGUgb3B0aW9ucyBoYXMgYmVlbiByZWFjaGVkLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHN0YWJpbGl6YXRpb25JdGVyYXRpb25zRG9uZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgJ2hpZGRlbicgc3RhYmlsaXphdGlvbiBmaW5pc2hlcy5cbiAgICogVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuIHRoZSBuZXR3b3JrIGlzIHN0YWJpbGl6ZWQ7XG4gICAqIGl0IGNvdWxkIGFsc28gbWVhbiB0aGF0IHRoZSBhbW91bnQgb2YgaXRlcmF0aW9ucyBkZWZpbmVkIGluIHRoZSBvcHRpb25zIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgc3RhYmlsaXplZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGhhcyBiZWVuIHJlc2l6ZWQsXG4gICAqIGVpdGhlciBieSBhIHJlZHJhdyBjYWxsIHdoZW4gdGhlIGNvbnRhaW5lciBkaXYgaGFzIGNoYW5nZWQgaW4gc2l6ZSxcbiAgICogYSBzZXRTaXplKCkgY2FsbCB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBzZXRPcHRpb25zKCkgd2l0aCBuZXcgd2lkdGggYW5kL29yIGhlaWdodCB2YWx1ZXMuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcmVzaXplOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCBiZWZvcmUgdGhlIHJlZHJhd2luZyBiZWdpbnMuXG4gICAqIFRoZSBzaW11bGF0aW9uIHN0ZXAgaGFzIGNvbXBsZXRlZCBhdCB0aGlzIHBvaW50LlxuICAgKiBDYW4gYmUgdXNlZCB0byBtb3ZlIGN1c3RvbSBlbGVtZW50cyBiZWZvcmUgc3RhcnRpbmcgZHJhd2luZyB0aGUgbmV3IGZyYW1lLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGluaXRSZWRyYXc6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIGFmdGVyIHRoZSBjYW52YXMgaGFzIGJlZW4gY2xlYXJlZCwgc2NhbGVkIGFuZCB0cmFuc2xhdGVkIHRvXG4gICAqIHRoZSB2aWV3aW5nIHBvc2l0aW9uIGJ1dCBiZWZvcmUgYWxsIGVkZ2VzIGFuZCBub2RlcyBhcmUgZHJhd24uXG4gICAqIENhbiBiZSB1c2VkIHRvIGRyYXcgYmVoaW5kIHRoZSBuZXR3b3JrLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGJlZm9yZURyYXdpbmc6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIGFmdGVyIGRyYXdpbmcgb24gdGhlIGNhbnZhcyBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAqIENhbiBiZSB1c2VkIHRvIGRyYXcgb24gdG9wIG9mIHRoZSBuZXR3b3JrLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGFmdGVyRHJhd2luZzogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiBhbiBhbmltYXRpb24gaXMgZmluaXNoZWQuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgYW5pbWF0aW9uRmluaXNoZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gYSB1c2VyIGNoYW5nZXMgYW55IG9wdGlvbiBpbiB0aGUgY29uZmlndXJhdG9yLlxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGJlIHVzZWQgd2l0aCB0aGUgc2V0T3B0aW9ucyBtZXRob2Qgb3Igc3RyaW5naWZpZWQgdXNpbmcgSlNPTi5zdHJpbmdpZnkoKS5cbiAgICogWW91IGRvIG5vdCBoYXZlIHRvIG1hbnVhbGx5IHB1dCB0aGUgb3B0aW9ucyBpbnRvIHRoZSBuZXR3b3JrOiB0aGlzIGlzIGRvbmUgYXV0b21hdGljYWxseS5cbiAgICogWW91IGNhbiB1c2UgdGhlIGV2ZW50IHRvIHN0b3JlIHVzZXIgb3B0aW9ucyBpbiB0aGUgZGF0YWJhc2UuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY29uZmlnQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIHByaXZhdGUgbmV0d29ya3M6IHsgW2lkOiBzdHJpbmddOiBOZXR3b3JrIH0gPSB7fTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBuZXR3b3JrIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG5ldHdvcmsgdmlldy5cbiAgICogQHBhcmFtIHtEYXRhfSBkYXRhIFRoZSBpbml0aWFsIG5ldHdvcmsgbm9kZXMgYW5kIGVkZ2VzLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBUaGUgbmV0d29yayBvcHRpb25zLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gYSBuZXR3b3JrIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cy5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlKHZpc05ldHdvcms6IHN0cmluZywgY29udGFpbmVyOiBIVE1MRWxlbWVudCwgZGF0YTogRGF0YSwgb3B0aW9ucz86IE9wdGlvbnMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBhbHJlYWR5IGV4aXN0cy5gKTtcbiAgICB9XG5cbiAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdID0gbmV3IE5ldHdvcmsoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIG5ldHdvcmsgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmUgYWxsIEhhbW1lciBiaW5kaW5ncyBhbmQgcmVmZXJlbmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KHZpc05ldHdvcms6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmRlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgYW4gZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtOZXR3b3JrRXZlbnRzfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmVudERlZmF1bHQgU3RvcHMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIGV2ZW50IHdhcyBhY3RpdmF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIG9uKHZpc05ldHdvcms6IHN0cmluZywgZXZlbnROYW1lOiBOZXR3b3JrRXZlbnRzLCBwcmV2ZW50RGVmYXVsdD86IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgICAgIGNvbnN0IHRoYXQ6IHsgW2luZGV4OiBzdHJpbmddOiBhbnkgfSA9IHRoaXM7XG4gICAgICAvKiB0c2xpbnQ6ZW5hYmxlICovXG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLm9uKGV2ZW50TmFtZSwgKHBhcmFtczogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGF0W2V2ZW50TmFtZV0gYXMgRXZlbnRFbWl0dGVyPGFueT47XG4gICAgICAgIGlmIChlbWl0dGVyKSB7XG4gICAgICAgICAgZW1pdHRlci5lbWl0KHBhcmFtcyA/IFt2aXNOZXR3b3JrXS5jb25jYXQocGFyYW1zKSA6IHZpc05ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCAmJiBwYXJhbXMuZXZlbnQpIHtcbiAgICAgICAgICBwYXJhbXMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyBhbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge05ldHdvcmtFdmVudHN9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgb2ZmKHZpc05ldHdvcms6IHN0cmluZywgZXZlbnROYW1lOiBOZXR3b3JrRXZlbnRzKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10ub2ZmKGV2ZW50TmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBhbiBldmVudCBsaXN0ZW5lciBvbmx5IG9uY2UuXG4gICAqIEFmdGVyIGl0IGhhcyB0YWtlbiBwbGFjZSwgdGhlIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge05ldHdvcmtFdmVudHN9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBldmVudCB3YXMgYWN0aXZhdGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBvbmNlKHZpc05ldHdvcms6IHN0cmluZywgZXZlbnROYW1lOiBOZXR3b3JrRXZlbnRzKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIC8qIHRzbGludDpkaXNhYmxlICovXG4gICAgICBjb25zdCB0aGF0OiB7IFtpbmRleDogc3RyaW5nXTogYW55IH0gPSB0aGlzO1xuICAgICAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10ub24oZXZlbnROYW1lLCAocGFyYW1zOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IHRoYXRbZXZlbnROYW1lXSBhcyBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAgICAgaWYgKGVtaXR0ZXIpIHtcbiAgICAgICAgICBlbWl0dGVyLmVtaXQocGFyYW1zID8gW3Zpc05ldHdvcmtdLmNvbmNhdChwYXJhbXMpIDogdmlzTmV0d29yayk7XG4gICAgICAgICAgdGhpcy5vZmYodmlzTmV0d29yaywgZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBhbGwgdGhlIGRhdGEgaW4gdGhlIG5ldHdvcmsuXG4gICAqIElmIHN0YWJpbGl6YXRpb24gaXMgZW5hYmxlZCBpbiB0aGUgcGh5c2ljcyBtb2R1bGUsXG4gICAqIHRoZSBuZXR3b3JrIHdpbGwgc3RhYmlsaXplIGFnYWluLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhbHNvIHBlcmZvcm1lZCB3aGVuIGZpcnN0IGluaXRpYWxpemluZyB0aGUgbmV0d29yay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge0RhdGF9IGRhdGEgVGhlIG5ldHdvcmsgZGF0YS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzZXREYXRhKHZpc05ldHdvcms6IHN0cmluZywgZGF0YTogRGF0YSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLnNldERhdGEoZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFRoZSBuZXR3b3JrIG9wdGlvbnMuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd24gd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgc2V0T3B0aW9ucyh2aXNOZXR3b3JrOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgbm9kZXMgY29ycmVzcG9uZGluZyB0byB0aGUgaWQncyBpbiB0aGUgaW5wdXQgYXJyYXkuXG4gICAqIFRoaXMgbWV0aG9kIHVuc2VsZWN0cyBhbGwgb3RoZXIgb2JqZWN0cyBiZWZvcmUgc2VsZWN0aW5nIGl0cyBvd24gb2JqZWN0cy5cbiAgICogRG9lcyBub3QgZmlyZSBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtJZFR5cGVbXX0gbm9kZUlkcyBUaGUgbm9kZSBpZHMgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzXSBJZiBoaWdobGlnaHRFZGdlcyBpcyB0cnVlIG9yIHVuZGVmaW5lZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuZWlnaGJvdXJpbmcgZWRnZXMgd2lsbCBhbHNvIGJlIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHNlbGVjdE5vZGVzKHZpc05ldHdvcms6IHN0cmluZywgbm9kZUlkczogSWRUeXBlW10sIGhpZ2hsaWdodEVkZ2VzPzogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLnNlbGVjdE5vZGVzKG5vZGVJZHMsIGhpZ2hsaWdodEVkZ2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgdGhlIG5vZGVzIGFuZCBlZGdlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBpZCdzIGluIHRoZSBpbnB1dCBhcnJheXMuXG4gICAqIERvZXMgbm90IGZpcmUgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7IG5vZGVzOiBJZFR5cGVbXSwgZWRnZXM6IElkVHlwZVtdIH0gc2VsZWN0aW9uIFRoZSBub2RlIGFuZCBlZGdlIGlkcyB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZC5cbiAgICogQHBhcmFtIHsgdW5zZWxlY3RBbGw/OiBib29sZWFuLCBoaWdobGlnaHRFZGdlcz86IGJvb2xlYW4gfSBbb3B0aW9uc11cbiAgICogSWYgdW5zZWxlY3RBbGwgaXMgdHJ1ZSBvciB1bmRlZmluZWQsIHRoZSBvdGhlciBvYmplY3RzIHdpbGwgYmUgZGVzZWxlY3RlZC5cbiAgICogSWYgaGlnaGxpZ2h0RWRnZXMgaXMgdHJ1ZSBvciB1bmRlZmluZWQsIHRoZSBuZWlnaGJvdXJpbmcgZWRnZXMgd2lsbCBhbHNvIGJlIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHNldFNlbGVjdGlvbihcbiAgICB2aXNOZXR3b3JrOiBzdHJpbmcsXG4gICAgc2VsZWN0aW9uOiB7IG5vZGVzOiBJZFR5cGVbXTsgZWRnZXM6IElkVHlwZVtdIH0sXG4gICAgb3B0aW9uczogeyB1bnNlbGVjdEFsbD86IGJvb2xlYW47IGhpZ2hsaWdodEVkZ2VzPzogYm9vbGVhbiB9ID0ge31cbiAgKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uc2V0U2VsZWN0aW9uKHNlbGVjdGlvbiwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHNlbGVjdGVkIG5vZGVzIGFuZCBlZGdlcyBpZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHJldHVybnMge3sgbm9kZXM6IElkVHlwZVtdLCBlZGdlczogSWRUeXBlW10gfX1cbiAgICogVGhlIHNlbGVjdGVkIG5vZGUgYW5kIGVkZ2UgaWRzIG9yIHVuZGVmaW5lZCB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXRTZWxlY3Rpb24odmlzTmV0d29yazogc3RyaW5nKTogeyBub2RlczogSWRUeXBlW107IGVkZ2VzOiBJZFR5cGVbXSB9IHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzZWxlY3RlZCBub2RlIGlkcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcmV0dXJucyB7SWRUeXBlW119IFRoZSBzZWxlY3RlZCBub2RlIGlkcyBvciB1bmRlZmluZWQgd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0U2VsZWN0ZWROb2Rlcyh2aXNOZXR3b3JrOiBzdHJpbmcpOiBJZFR5cGVbXSB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldFNlbGVjdGVkTm9kZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNlbGVjdGVkIGVkZ2UgaWRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEByZXR1cm5zIHtJZFR5cGVbXX0gVGhlIHNlbGVjdGVkIGVkZ2UgaWRzIG9yIHVuZGVmaW5lZCB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXRTZWxlY3RlZEVkZ2VzKHZpc05ldHdvcms6IHN0cmluZyk6IElkVHlwZVtdIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0U2VsZWN0ZWRFZGdlcygpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc2VsZWN0IGFsbCBvYmplY3RzLlxuICAgKiBEb2VzIG5vdCBmaXJlIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHVuc2VsZWN0QWxsKHZpc05ldHdvcms6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLnVuc2VsZWN0QWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBab29tcyBvdXQgc28gYWxsIG5vZGVzIGZpdCBvbiB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7VmlzRml0T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgdG8gY3VzdG9taXplLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZpdCh2aXNOZXR3b3JrOiBzdHJpbmcsIG9wdGlvbnM/OiBGaXRPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZml0KG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVkcmF3IHRoZSBuZXR3b3JrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd24gd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcmVkcmF3KHZpc05ldHdvcms6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLnJlZHJhdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR28gaW50byBhZGROb2RlIG1vZGUuIEhhdmluZyBlZGl0IG1vZGUgb3IgbWFuaXB1bGF0aW9uIGVuYWJsZWQgaXMgbm90IHJlcXVpcmVkLlxuICAgKiBUbyBnZXQgb3V0IG9mIHRoaXMgbW9kZSwgY2FsbCBkaXNhYmxlRWRpdE1vZGUoKS4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyBkZWZpbmVkIGluIGhhbmRsZXJGdW5jdGlvbnMgc3RpbGwgYXBwbHkuXG4gICAqIFRvIHVzZSB0aGVzZSBtZXRob2RzIHdpdGhvdXQgaGF2aW5nIHRoZSBtYW5pcHVsYXRpb24gR1VJLCBtYWtlIHN1cmUgeW91IHNldCBlbmFibGVkIHRvIGZhbHNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd24gd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgYWRkTm9kZU1vZGUodmlzTmV0d29yazogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uYWRkTm9kZU1vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2dyYW1hdGljYWxseSBlbmFibGUgdGhlIGVkaXQgbW9kZS5cbiAgICogU2ltaWxhciBlZmZlY3QgdG8gcHJlc3NpbmcgdGhlIGVkaXQgYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd24gd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZW5hYmxlRWRpdE1vZGUodmlzTmV0d29yazogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGludG8gYWRkRWRnZSBtb2RlLlxuICAgKiBUaGUgZXhwbGFpbmF0aW9uIGZyb20gYWRkTm9kZU1vZGUgYXBwbGllcyBoZXJlIGFzIHdlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBhZGRFZGdlTW9kZSh2aXNOZXR3b3JrOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5hZGRFZGdlTW9kZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvZ3JhbWF0aWNhbGx5IGRpc2FibGUgdGhlIGVkaXQgbW9kZS5cbiAgICogU2ltaWxhciBlZmZlY3QgdG8gcHJlc3NpbmcgdGhlIGNsb3NlIGljb25cbiAgICogKHNtYWxsIGNyb3NzIGluIHRoZSBjb3JuZXIgb2YgdGhlIHRvb2xiYXIpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd24gd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZGlzYWJsZUVkaXRNb2RlKHZpc05ldHdvcms6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHNlbGVjdGVkLlxuICAgKiBIYXZpbmcgZWRpdCBtb2RlIG9yIG1hbmlwdWxhdGlvbiBlbmFibGVkIGlzIG5vdCByZXF1aXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGRlbGV0ZVNlbGVjdGVkKHZpc05ldHdvcms6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmRlbGV0ZVNlbGVjdGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtDbHVzdGVyT3B0aW9uc30gW29wdGlvbnNdIFRoZSBqb2luQ29uZGl0aW9uIGZ1bmN0aW9uIGlzIHByZXNlbnRlZCB3aXRoIGFsbCBub2Rlcy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjbHVzdGVyKHZpc05ldHdvcms6IHN0cmluZywgb3B0aW9ucz86IENsdXN0ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uY2x1c3RlcihvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGxvb2tzIGF0IHRoZSBwcm92aWRlZCBub2RlIGFuZCBtYWtlcyBhIGNsdXN0ZXIgb2YgaXQgYW5kIGFsbCBpdCdzIGNvbm5lY3RlZCBub2Rlcy5cbiAgICogVGhlIGJlaGF2aW91ciBjYW4gYmUgY3VzdG9taXplZCBieSBwcm92aW5nIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQWxsIG9wdGlvbnMgb2YgdGhpcyBvYmplY3QgYXJlIGV4cGxhaW5lZCBiZWxvdy5cbiAgICogVGhlIGpvaW5Db25kaXRpb24gaXMgb25seSBwcmVzZW50ZWQgd2l0aCB0aGUgY29ubmVjdGVkIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SWRUeXBlfSBub2RlSWQgdGhlIGlkIG9mIHRoZSBub2RlXG4gICAqIEBwYXJhbSB7Q2x1c3Rlck9wdGlvbnN9IFtvcHRpb25zXSB0aGUgY2x1c3RlciBvcHRpb25zXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNsdXN0ZXJCeUNvbm5lY3Rpb24odmlzTmV0d29yazogc3RyaW5nLCBub2RlSWQ6IElkVHlwZSwgb3B0aW9ucz86IENsdXN0ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uY2x1c3RlckJ5Q29ubmVjdGlvbihub2RlSWQgYXMgYW55LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNoZWNrcyBhbGwgbm9kZXMgaW4gdGhlIG5ldHdvcmsgYW5kIHRob3NlIHdpdGggYSBlcXVhbCBvciBoaWdoZXJcbiAgICogYW1vdW50IG9mIGVkZ2VzIHRoYW4gc3BlY2lmaWVkIHdpdGggdGhlIGh1YnNpemUgcXVhbGlmeS5cbiAgICogSWYgYSBodWJzaXplIGlzIG5vdCBkZWZpbmVkLCB0aGUgaHVic2l6ZSB3aWxsIGJlIGRldGVybWluZWQgYXMgdGhlIGF2ZXJhZ2VcbiAgICogdmFsdWUgcGx1cyB0d28gc3RhbmRhcmQgZGV2aWF0aW9ucy5cbiAgICogRm9yIGFsbCBxdWFsaWZ5aW5nIG5vZGVzLCBjbHVzdGVyQnlDb25uZWN0aW9uIGlzIHBlcmZvcm1lZCBvbiBlYWNoIG9mIHRoZW0uXG4gICAqIFRoZSBvcHRpb25zIG9iamVjdCBpcyBkZXNjcmliZWQgZm9yIGNsdXN0ZXJCeUNvbm5lY3Rpb24gYW5kIGRvZXMgdGhlIHNhbWUgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2h1YnNpemVdIG9wdGlvbmFsIGh1YnNpemVcbiAgICogQHBhcmFtIHtDbHVzdGVyT3B0aW9uc30gW29wdGlvbnNdIG9wdGlvbmFsIGNsdXN0ZXIgb3B0aW9uc1xuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjbHVzdGVyQnlIdWJzaXplKHZpc05ldHdvcms6IHN0cmluZywgaHVic2l6ZT86IG51bWJlciwgb3B0aW9ucz86IENsdXN0ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uY2x1c3RlckJ5SHVic2l6ZShodWJzaXplLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgY2x1c3RlciBhbGwgbm9kZXMgd2l0aCAxIGVkZ2Ugd2l0aCB0aGVpciByZXNwZWN0aXZlIGNvbm5lY3RlZCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7Q2x1c3Rlck9wdGlvbnN9IFtvcHRpb25zXSBvcHRpb25hbCBjbHVzdGVyIG9wdGlvbnNcbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2x1c3Rlck91dGxpZXJzKHZpc05ldHdvcms6IHN0cmluZywgb3B0aW9ucz86IENsdXN0ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uY2x1c3Rlck91dGxpZXJzKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm9kZXMgY2FuIGJlIGluIGNsdXN0ZXJzLlxuICAgKiBDbHVzdGVycyBjYW4gYWxzbyBiZSBpbiBjbHVzdGVycy5cbiAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGFycmF5IG9mIG5vZGVJZHMgc2hvd2luZyB3aGVyZSB0aGUgbm9kZSBpcy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogY2x1c3RlciAnQScgY29udGFpbnMgY2x1c3RlciAnQicsIGNsdXN0ZXIgJ0InIGNvbnRhaW5zIGNsdXN0ZXIgJ0MnLFxuICAgKiBjbHVzdGVyICdDJyBjb250YWlucyBub2RlICdmcmVkJy5cbiAgICpcbiAgICogbmV0d29yay5jbHVzdGVyaW5nLmZpbmROb2RlKCdmcmVkJykgd2lsbCByZXR1cm4gWydBJywnQicsJ0MnLCdmcmVkJ10uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtJZFR5cGV9IG5vZGVJZCB0aGUgbm9kZSBpZC5cbiAgICogQHJldHVybnMge0lkVHlwZVtdfSBhbiBhcnJheSBvZiBub2RlSWRzIHNob3dpbmcgd2hlcmUgdGhlIG5vZGUgaXNcbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZmluZE5vZGUodmlzTmV0d29yazogc3RyaW5nLCBub2RlSWQ6IElkVHlwZSk6IElkVHlwZVtdIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZmluZE5vZGUobm9kZUlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8gZmluZE5vZGUgaW4gdGhhdCBpdCByZXR1cm5zIGFsbCB0aGUgZWRnZSBpZHMgdGhhdCB3ZXJlXG4gICAqIGNyZWF0ZWQgZnJvbSB0aGUgcHJvdmlkZWQgZWRnZSBkdXJpbmcgY2x1c3RlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge0lkVHlwZX0gYmFzZUVkZ2VJZCB0aGUgYmFzZSBlZGdlIGlkXG4gICAqIEByZXR1cm5zIHtJZFR5cGVbXX0gYW4gYXJyYXkgb2YgZWRnZUlkc1xuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXRDbHVzdGVyZWRFZGdlcyh2aXNOZXR3b3JrOiBzdHJpbmcsIGJhc2VFZGdlSWQ6IElkVHlwZSk6IElkVHlwZVtdIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0Q2x1c3RlcmVkRWRnZXMoYmFzZUVkZ2VJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgY2x1c3RlcmVkRWRnZUlkIGlzIGF2YWlsYWJsZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAqIGJhc2VFZGdlSWQgcHJvdmlkZWQgaW4gZGF0YS5lZGdlcyBpZS5cbiAgICogQWZ0ZXIgY2x1c3RlcmluZyB0aGUgJ1NlbGVjdEVkZ2UnIGV2ZW50IGlzIGZpcmVkIGJ1dCBwcm92aWRlcyBvbmx5IHRoZSBjbHVzdGVyZWQgZWRnZS5cbiAgICogVGhpcyBtZXRob2QgY2FuIHRoZW4gYmUgdXNlZCB0byByZXR1cm4gdGhlIGJhc2VFZGdlSWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtJZFR5cGV9IGNsdXN0ZXJlZEVkZ2VJZFxuICAgKiBAcmV0dXJucyB7SWRUeXBlfVxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXRCYXNlRWRnZSh2aXNOZXR3b3JrOiBzdHJpbmcsIGNsdXN0ZXJlZEVkZ2VJZDogSWRUeXBlKTogSWRUeXBlIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0QmFzZUVkZ2UoY2x1c3RlcmVkRWRnZUlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZpc2libGUgZWRnZXMgYmV0d2VlbiBjbHVzdGVyZWQgbm9kZXMgYXJlIG5vdCB0aGUgc2FtZSBlZGdlIGFzIHRoZSBvbmVzIHByb3ZpZGVkXG4gICAqIGluIGRhdGEuZWRnZXMgcGFzc2VkIG9uIG5ldHdvcmsgY3JlYXRpb24uIFdpdGggZWFjaCBsYXllciBvZiBjbHVzdGVyaW5nLCBjb3BpZXMgb2ZcbiAgICogdGhlIGVkZ2VzIGJldHdlZW4gY2x1c3RlcnMgYXJlIGNyZWF0ZWQgYW5kIHRoZSBwcmV2aW91cyBlZGdlcyBhcmUgaGlkZGVuLFxuICAgKiB1bnRpbCB0aGUgY2x1c3RlciBpcyBvcGVuZWQuIFRoaXMgbWV0aG9kIHRha2VzIGFuIGVkZ2VJZCAoaWUuIGEgYmFzZSBlZGdlSWQgZnJvbSBkYXRhLmVkZ2VzKVxuICAgKiBhbmQgYXBwbHlzIHRoZSBvcHRpb25zIHRvIGl0IGFuZCBhbnkgZWRnZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBpdCB3aGlsZSBjbHVzdGVyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SWRUeXBlfSBzdGFydEVkZ2VJZFxuICAgKiBAcGFyYW0ge1Zpc0VkZ2VPcHRpb25zfSBbb3B0aW9uc11cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlRWRnZSh2aXNOZXR3b3JrOiBzdHJpbmcsIHN0YXJ0RWRnZUlkOiBJZFR5cGUsIG9wdGlvbnM/OiBFZGdlT3B0aW9ucyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLnVwZGF0ZUVkZ2Uoc3RhcnRFZGdlSWQsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2x1c3RlcmVkIE5vZGVzIHdoZW4gY3JlYXRlZCBhcmUgbm90IGNvbnRhaW5lZCBpbiB0aGUgb3JpZ2luYWwgZGF0YS5ub2Rlc1xuICAgKiBwYXNzZWQgb24gbmV0d29yayBjcmVhdGlvbi4gVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY2x1c3RlciBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SWRUeXBlfSBjbHVzdGVyZWROb2RlSWRcbiAgICogQHBhcmFtIHtOb2RlT3B0aW9uc30gb3B0aW9uc1xuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVDbHVzdGVyZWROb2RlKHZpc05ldHdvcms6IHN0cmluZywgY2x1c3RlcmVkTm9kZUlkOiBJZFR5cGUsIG9wdGlvbnM/OiBOb2RlT3B0aW9ucyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLnVwZGF0ZUNsdXN0ZXJlZE5vZGUoY2x1c3RlcmVkTm9kZUlkLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIG5vZGVJZHMgb2YgdGhlIG5vZGVzIHRoYXRcbiAgICogd291bGQgYmUgcmVsZWFzZWQgaWYgeW91IG9wZW4gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtJZFR5cGV9IGNsdXN0ZXJOb2RlSWQgdGhlIGlkIG9mIHRoZSBjbHVzdGVyIG5vZGVcbiAgICogQHJldHVybnMge0lkVHlwZVtdfVxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXROb2Rlc0luQ2x1c3Rlcih2aXNOZXR3b3JrOiBzdHJpbmcsIGNsdXN0ZXJOb2RlSWQ6IElkVHlwZSk6IElkVHlwZVtdIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0Tm9kZXNJbkNsdXN0ZXIoY2x1c3Rlck5vZGVJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgY2x1c3RlciwgcmVsZWFzZXMgdGhlIGNvbnRhaW5lZCBub2RlcyBhbmQgZWRnZXMsXG4gICAqIHJlbW92aW5nIHRoZSBjbHVzdGVyIG5vZGUgYW5kIGNsdXN0ZXIgZWRnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtJZFR5cGV9IG5vZGVJZCBUaGUgbm9kZSBpZCB0aGF0IHJlcHJlc2VudHMgdGhlIGNsdXN0ZXIuXG4gICAqIEBwYXJhbSB7T3BlbkNsdXN0ZXJPcHRpb25zfSBbb3B0aW9uc10gQ2x1c3RlciBvcHRpb25zLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIG9wZW5DbHVzdGVyKHZpc05ldHdvcms6IHN0cmluZywgbm9kZUlkOiBJZFR5cGUsIG9wdGlvbnM/OiBPcGVuQ2x1c3Rlck9wdGlvbnMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5vcGVuQ2x1c3Rlcihub2RlSWQsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIHdob3NlIElEIGhhcyBiZWVuIHN1cHBsaWVkIGlzIGEgY2x1c3Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge0lkVHlwZX0gbm9kZUlkIFRoZSBhc3NvY2lhdGVkIG5vZGUgaWQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBub2RlIHdob3NlIElEIGhhcyBiZWVuIHN1cHBsaWVkIGlzIGEgY2x1c3Rlci5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgaXNDbHVzdGVyKHZpc05ldHdvcms6IHN0cmluZywgbm9kZUlkOiBJZFR5cGUpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uaXNDbHVzdGVyKG5vZGVJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHlvdSBsaWtlIHRoZSBsYXlvdXQgb2YgeW91ciBuZXR3b3JrIGFuZCB3b3VsZCBsaWtlIGl0IHRvIHN0YXJ0IGluIHRoZSBzYW1lIHdheSBuZXh0IHRpbWUsXG4gICAqIGFzayBmb3IgdGhlIHNlZWQgdXNpbmcgdGhpcyBtZXRob2QgYW5kIHB1dCBpdCBpbiB0aGUgbGF5b3V0LnJhbmRvbVNlZWQgb3B0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzZWVkIG9mIHRoZSBjdXJyZW50IG5ldHdvcmsgb3IgLTEgd2hlbiB0aGUgbmV0d29yayBpcyBub3QgZGVmaW5lZC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0U2VlZCh2aXNOZXR3b3JrOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5nZXRTZWVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gY29udmVydHMgY2FudmFzIGNvb3JkaW5hdGVzIHRvIGNvb3JkaW5hdGVzIG9uIHRoZSBET00uXG4gICAqIElucHV0IGFuZCBvdXRwdXQgYXJlIGluIHRoZSBmb3JtIG9mIHt4Ok51bWJlcix5Ok51bWJlcn0uXG4gICAqIFRoZSBET00gdmFsdWVzIGFyZSByZWxhdGl2ZSB0byB0aGUgbmV0d29yayBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb24gVGhlIGNhbnZhcyBwb3NpdGlvbi5cbiAgICogQHJldHVybnMge1Bvc2l0aW9ufSBUaGUgRE9NIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjYW52YXNUb0RPTSh2aXNOZXR3b3JrOiBzdHJpbmcsIHBvc2l0aW9uOiBQb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmNhbnZhc1RvRE9NKHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIERPTSBjb29yZGluYXRlcyB0byBjb29yZGluYXRlcyBvbiB0aGUgY2FudmFzLlxuICAgKiBJbnB1dCBhbmQgb3V0cHV0IGFyZSBpbiB0aGUgZm9ybSBvZiB7eDpOdW1iZXIseTpOdW1iZXJ9LlxuICAgKiBUaGUgRE9NIHZhbHVlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIG5ldHdvcmsgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7UG9zaXRpb259IHBvc2l0aW9uIFRoZSBET00gcG9zaXRpb24uXG4gICAqIEByZXR1cm5zIHtQb3NpdGlvbn0gVGhlIGNhbnZhcyBwb3NpdGlvbi5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgRE9NdG9DYW52YXModmlzTmV0d29yazogc3RyaW5nLCBwb3NpdGlvbjogUG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5ET010b0NhbnZhcyhwb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBsb29rcyB1cCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gRE9NIGNvb3JkaW5hdGVzIG9uIHRoZSBjYW52YXMuXG4gICAqIElucHV0IGFuZCBvdXRwdXQgYXJlIGluIHRoZSBmb3JtIG9mIHt4Ok51bWJlcix5Ok51bWJlcn0uXG4gICAqIFRoZSBET00gdmFsdWVzIGFyZSByZWxhdGl2ZSB0byB0aGUgbmV0d29yayBjb250YWluZXIgLT4gRE9NIG5vdCBDYW52YXMgY29vcmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7UG9zaXRpb259IHBvc2l0aW9uIFRoZSBET00gcG9zaXRpb24uXG4gICAqIEByZXR1cm5zIHtJZFR5cGV9IG5vZGVJZCBUaGUgYXNzb2NpYXRlZCBub2RlIGlkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXROb2RlQXQodmlzTmV0d29yazogc3RyaW5nLCBwb3NpdGlvbjogUG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5nZXROb2RlQXQocG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gbG9va3MgdXAgdGhlIGVkZ2UgYXQgdGhlIGdpdmVuIERPTSBjb29yZGluYXRlcyBvbiB0aGUgY2FudmFzLlxuICAgKiBJbnB1dCBhbmQgb3V0cHV0IGFyZSBpbiB0aGUgZm9ybSBvZiB7eDpOdW1iZXIseTpOdW1iZXJ9LlxuICAgKiBUaGUgRE9NIHZhbHVlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIG5ldHdvcmsgY29udGFpbmVyIC0+IERPTSBub3QgQ2FudmFzIGNvb3Jkcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge1Bvc2l0aW9ufSBwb3NpdGlvbiBUaGUgRE9NIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJucyB7SWRUeXBlfSBlZGdlSWQgVGhlIGFzc29jaWF0ZWQgZWRnZSBpZC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0RWRnZUF0KHZpc05ldHdvcms6IHN0cmluZywgcG9zaXRpb246IFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0RWRnZUF0KHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGxvb2tzIHVwIHRoZSBlZGdlcyBmb3IgYSBnaXZlbiBub2RlSWQuXG4gICAqIFRoZSBET00gdmFsdWVzIGFyZSByZWxhdGl2ZSB0byB0aGUgbmV0d29yayBjb250YWluZXIgLT4gRE9NIG5vdCBDYW52YXMgY29vcmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SWRUeXBlfSBub2RlSWQgVGhlIGFzc29jaWF0ZWQgbm9kZSBpZC5cbiAgICogQHJldHVybnMge0lkVHlwZVtdfSBSZXR1cm4gYXJyYXkgb2YgZWRnZSBpZHNcbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0Q29ubmVjdGVkRWRnZXModmlzTmV0d29yazogc3RyaW5nLCBub2RlSWQ6IElkVHlwZSkge1xuICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldENvbm5lY3RlZEVkZ2VzKG5vZGVJZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBub2RlSWRzIG9mIHRoZSBhbGwgdGhlIG5vZGVzIHRoYXQgYXJlIGRpcmVjdGx5IGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAqIElmIHlvdSBzdXBwbHkgYW4gZWRnZUlkLCB2aXMgd2lsbCBmaXJzdCBtYXRjaCB0aGUgaWQgdG8gbm9kZXMuXG4gICAqIElmIG5vIG1hdGNoIGlzIGZvdW5kLCBpdCB3aWxsIHNlYXJjaCBpbiB0aGUgZWRnZWxpc3QgYW5kIHJldHVybiBhbiBhcnJheTogW2Zyb21JZCwgdG9JZF0uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIG5vZGVPckVkZ2VJZCBhIG5vZGUgb3IgZWRnZSBpZFxuICAgKiBAcmV0dXJucyB7SWRUeXBlW119IFJldHVybiBhcnJheSBvZiBub2RlIGlkc1xuICAgKi9cbiAgcHVibGljIGdldENvbm5lY3RlZE5vZGVzKHZpc05ldHdvcms6IHN0cmluZywgbm9kZU9yRWRnZUlkOiBJZFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5nZXRDb25uZWN0ZWROb2Rlcyhub2RlT3JFZGdlSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtBcnJheS48Tm9kZS5pZD58U3RyaW5nfSBbaWRzXSAgLS0+IG9wdGlvbmFsLCBjYW4gYmUgYXJyYXkgb2Ygbm9kZUlkcywgY2FuIGJlIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7e319XG4gICAqL1xuICBwdWJsaWMgZ2V0UG9zaXRpb25zKHZpc05ldHdvcms6IHN0cmluZywgbm9kZUlkczogSWRUeXBlW10pIHtcbiAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5nZXRQb3NpdGlvbnMobm9kZUlkcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2Rlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKi9cbiAgcHVibGljIGdldEJvdW5kaW5nQm94KHZpc05ldHdvcms6IHN0cmluZywgbm9kZUlkOiBJZFR5cGUpOiBCb3VuZGluZ0JveCB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0Qm91bmRpbmdCb3gobm9kZUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqL1xuICBwdWJsaWMgc3RvcmVQb3NpdGlvbnModmlzTmV0d29yazogc3RyaW5nKTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uc3RvcmVQb3NpdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBZb3UgY2FuIGFuaW1hdGUgb3IgbW92ZSB0aGUgY2FtZXJhIHVzaW5nIHRoZSBtb3ZlVG8gbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7TW92ZVRvT3B0aW9uc30gb3B0aW9ucyBPcHRpb25zIGZvciBtb3ZlVG8gZnVuY3Rpb24uXG4gICAqL1xuICBwdWJsaWMgbW92ZVRvKHZpc05ldHdvcms6IHN0cmluZywgbW92ZVRvT3B0aW9uczogTW92ZVRvT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLm1vdmVUbyhtb3ZlVG9PcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLlxuICAgKiBUaGlzIGlzIG5vcm1hbGx5IGRvbmUgd2hlbmV2ZXIgbmVlZGVkIGFuZCBpcyBvbmx5IHJlYWxseSB1c2VmdWxcbiAgICogaWYgeW91IHN0b3AgdGhlIHNpbXVsYXRpb24geW91cnNlbGYgYW5kIHdpc2ggdG8gY29udGludWUgaXQgYWZ0ZXJ3YXJkcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKi9cbiAgcHVibGljIHN0YXJ0U2ltdWxhdGlvbih2aXNOZXR3b3JrOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5zdGFydFNpbXVsYXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHN0b3BzIHRoZSBwaHlzaWNzIHNpbXVsYXRpb24gYW5kIHRyaWdnZXJzIGEgc3RhYmlsaXplZCBldmVudC5cbiAgICogVHQgY2FuIGJlIHJlc3RhcnRlZCBieSBkcmFnZ2luZyBhIG5vZGUsXG4gICAqIGFsdGVyaW5nIHRoZSBkYXRhc2V0IG9yIGNhbGxpbmcgc3RhcnRTaW11bGF0aW9uKCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICovXG4gIHB1YmxpYyBzdG9wU2ltdWxhdGlvbih2aXNOZXR3b3JrOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5zdG9wU2ltdWxhdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2NhbGUgb2YgdGhlIG5ldHdvcmsuIDEuMCBpcyBjb21wYXJpYmxlIHRvIDEwMCUsIDAgaXMgem9vbWVkIG91dCBpbmZpbml0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd24gd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0U2NhbGUodmlzTmV0d29yazogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0U2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG59XG4iXX0=