import * as tslib_1 from "tslib";
import { EventEmitter, Injectable } from '@angular/core';
import { Network } from 'vis-network';
/**
 * A service to create, manage and control Network instances.
 *
 * @export
 * @class NetworkService
 */
var VisNetworkService = /** @class */ (function () {
    function VisNetworkService() {
        /**
         * Fired when the user clicks the mouse or taps on a touchscreen device.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.click = new EventEmitter();
        /**
         * Fired when the user double clicks the mouse or double taps on a touchscreen device.
         * Since a double click is in fact 2 clicks, 2 click events are fired, followed by a double click event.
         * If you do not want to use the click events if a double click event is fired,
         * just check the time between click events before processing them.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.doubleClick = new EventEmitter();
        /**
         * Fired when the user click on the canvas with the right mouse button.
         * The right mouse button does not select by default.
         * You can use the method getNodeAt to select the node if you want.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.oncontext = new EventEmitter();
        /**
         * Fired when the user clicks and holds the mouse or taps and holds on a touchscreen device.
         * A click event is also fired in this case.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hold = new EventEmitter();
        /**
         * Fired after drawing on the canvas has been completed.
         * Can be used to draw on top of the network.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.release = new EventEmitter();
        /**
         * Fired when the selection has changed by user action.
         * This means a node or edge has been selected, added to the selection or deselected.
         * All select events are only triggered on click and hold.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.select = new EventEmitter();
        /**
         * Fired when a node has been selected by the user.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.selectNode = new EventEmitter();
        /**
         * Fired when a edge has been selected by the user.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.selectEdge = new EventEmitter();
        /**
         * Fired when a node (or nodes) has (or have) been deselected by the user.
         * The previous selection is the list of nodes and edges that were selected before the last user event.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.deselectNode = new EventEmitter();
        /**
         * Fired when a edge (or edges) has (or have) been deselected by the user.
         * The previous selection is the list of nodes and edges that were selected before the last user event.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.deselectEdge = new EventEmitter();
        /**
         * Fired when starting a drag.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.dragStart = new EventEmitter();
        /**
         * Fired when dragging node(s) or the view.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.dragging = new EventEmitter();
        /**
         * Fired when the drag has finished.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.dragEnd = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over a node.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hoverNode = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and
         * the mouse moved away from a node it was hovering over before.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.blurNode = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and the mouse hovers over an edge.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hoverEdge = new EventEmitter();
        /**
         * Fired if the option interaction:{hover:true} is enabled and
         * the mouse moved away from an edge it was hovering over before.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.blurEdge = new EventEmitter();
        /**
         * Fired when the user zooms in or out.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.zoom = new EventEmitter();
        /**
         * Fired when the popup (tooltip) is shown.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.showPopup = new EventEmitter();
        /**
         * Fired when the popup (tooltip) is hidden.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.hidePopup = new EventEmitter();
        /**
         * Fired when stabilization starts.
         * This is also the case when you drag a node and the physics
         * simulation restarts to stabilize again.
         * Stabilization does not neccesarily imply 'without showing'.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.startStabilizing = new EventEmitter();
        /**
         * Fired when a multiple of the updateInterval number of iterations is reached.
         * This only occurs in the 'hidden' stabilization.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.stabilizationProgress = new EventEmitter();
        /**
         * Fired when the 'hidden' stabilization finishes.
         * This does not necessarily mean the network is stabilized;
         * it could also mean that the amount of iterations defined in the options has been reached.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.stabilizationIterationsDone = new EventEmitter();
        /**
         * Fired when the 'hidden' stabilization finishes.
         * This does not necessarily mean the network is stabilized;
         * it could also mean that the amount of iterations defined in the options has been reached.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.stabilized = new EventEmitter();
        /**
         * Fired when the size of the canvas has been resized,
         * either by a redraw call when the container div has changed in size,
         * a setSize() call with new values or a setOptions() with new width and/or height values.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.resize = new EventEmitter();
        /**
         * Fired before the redrawing begins.
         * The simulation step has completed at this point.
         * Can be used to move custom elements before starting drawing the new frame.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.initRedraw = new EventEmitter();
        /**
         * Fired after the canvas has been cleared, scaled and translated to
         * the viewing position but before all edges and nodes are drawn.
         * Can be used to draw behind the network.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.beforeDrawing = new EventEmitter();
        /**
         * Fired after drawing on the canvas has been completed.
         * Can be used to draw on top of the network.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.afterDrawing = new EventEmitter();
        /**
         * Fired when an animation is finished.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.animationFinished = new EventEmitter();
        /**
         * Fired when a user changes any option in the configurator.
         * The options object can be used with the setOptions method or stringified using JSON.stringify().
         * You do not have to manually put the options into the network: this is done automatically.
         * You can use the event to store user options in the database.
         *
         * @type {EventEmitter<any>}
         * @memberOf NetworkService
         */
        this.configChange = new EventEmitter();
        this.networks = {};
    }
    /**
     * Creates a new network instance.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {HTMLElement} container The HTML element that contains the network view.
     * @param {Data} data The initial network nodes and edges.
     * @param {Options} [options] The network options.
     *
     * @throws {Error} Thrown when a network with the same name already exists.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.create = function (visNetwork, container, data, options) {
        if (this.networks[visNetwork]) {
            throw new Error("Network with id " + visNetwork + " already exists.");
        }
        this.networks[visNetwork] = new Network(container, data, options);
    };
    /**
     * Remove the network from the DOM and remove all Hammer bindings and references.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.destroy = function (visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].destroy();
            delete this.networks[visNetwork];
        }
    };
    /**
     * Activates an event.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {NetworkEvents} eventName The event name.
     * @param {boolean} preventDefault Stops the default behavior of the event.
     * @returns {boolean} Returns true when the event was activated.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.on = function (visNetwork, eventName, preventDefault) {
        if (this.networks[visNetwork]) {
            /* tslint:disable */
            var that_1 = this;
            /* tslint:enable */
            this.networks[visNetwork].on(eventName, function (params) {
                var emitter = that_1[eventName];
                if (emitter) {
                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);
                }
                if (preventDefault && params.event) {
                    params.event.preventDefault();
                }
            });
            return true;
        }
        return false;
    };
    /**
     * Deactivates an event.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {NetworkEvents} eventName The event name.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.off = function (visNetwork, eventName) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].off(eventName);
        }
    };
    /**
     * Activates an event listener only once.
     * After it has taken place, the event listener will be removed.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {NetworkEvents} eventName The event name.
     * @returns {boolean} Returns true when the event was activated.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.once = function (visNetwork, eventName) {
        var _this = this;
        if (this.networks[visNetwork]) {
            /* tslint:disable */
            var that_2 = this;
            /* tslint:disable */
            this.networks[visNetwork].on(eventName, function (params) {
                var emitter = that_2[eventName];
                if (emitter) {
                    emitter.emit(params ? [visNetwork].concat(params) : visNetwork);
                    _this.off(visNetwork, eventName);
                }
            });
            return true;
        }
        return false;
    };
    /**
     * Override all the data in the network.
     * If stabilization is enabled in the physics module,
     * the network will stabilize again.
     * This method is also performed when first initializing the network.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Data} data The network data.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.setData = function (visNetwork, data) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].setData(data);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Set the options.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Options} options The network options.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.setOptions = function (visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].setOptions(options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Selects the nodes corresponding to the id's in the input array.
     * This method unselects all other objects before selecting its own objects.
     * Does not fire events.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType[]} nodeIds The node ids that should be selected.
     * @param {boolean} [highlightEdges] If highlightEdges is true or undefined,
     *                                   the neighbouring edges will also be selected.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.selectNodes = function (visNetwork, nodeIds, highlightEdges) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].selectNodes(nodeIds, highlightEdges);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Selects the nodes and edges corresponding to the id's in the input arrays.
     * Does not fire events.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param { nodes: IdType[], edges: IdType[] } selection The node and edge ids that should be selected.
     * @param { unselectAll?: boolean, highlightEdges?: boolean } [options]
     * If unselectAll is true or undefined, the other objects will be deselected.
     * If highlightEdges is true or undefined, the neighbouring edges will also be selected.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.setSelection = function (visNetwork, selection, options) {
        if (options === void 0) { options = {}; }
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].setSelection(selection, options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Returns an object with selected nodes and edges ids.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {{ nodes: IdType[], edges: IdType[] }}
     * The selected node and edge ids or undefined when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getSelection = function (visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSelection();
        }
        return undefined;
    };
    /**
     * Returns an array of selected node ids.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {IdType[]} The selected node ids or undefined when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getSelectedNodes = function (visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSelectedNodes();
        }
        return undefined;
    };
    /**
     * Returns an array of selected edge ids.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {IdType[]} The selected edge ids or undefined when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getSelectedEdges = function (visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSelectedEdges();
        }
        return undefined;
    };
    /**
     * Unselect all objects.
     * Does not fire events.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.unselectAll = function (visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].unselectAll();
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Zooms out so all nodes fit on the canvas.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {VisFitOptions} [options] Options to customize.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.fit = function (visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].fit(options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Redraw the network.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.redraw = function (visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].redraw();
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Go into addNode mode. Having edit mode or manipulation enabled is not required.
     * To get out of this mode, call disableEditMode(). The callback functions defined in handlerFunctions still apply.
     * To use these methods without having the manipulation GUI, make sure you set enabled to false.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.addNodeMode = function (visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].addNodeMode();
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Programatically enable the edit mode.
     * Similar effect to pressing the edit button.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.enableEditMode = function (visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].enableEditMode();
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Go into addEdge mode.
     * The explaination from addNodeMode applies here as well.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.addEdgeMode = function (visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].addEdgeMode();
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Programatically disable the edit mode.
     * Similar effect to pressing the close icon
     * (small cross in the corner of the toolbar).
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.disableEditMode = function (visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].disableEditMode();
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Delete selected.
     * Having edit mode or manipulation enabled is not required.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.deleteSelected = function (visNetwork) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].deleteSelected();
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Makes a cluster.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {ClusterOptions} [options] The joinCondition function is presented with all nodes.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.cluster = function (visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].cluster(options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * This method looks at the provided node and makes a cluster of it and all it's connected nodes.
     * The behaviour can be customized by proving the options object.
     * All options of this object are explained below.
     * The joinCondition is only presented with the connected nodes.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId the id of the node
     * @param {ClusterOptions} [options] the cluster options
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.clusterByConnection = function (visNetwork, nodeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].clusterByConnection(nodeId, options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * This method checks all nodes in the network and those with a equal or higher
     * amount of edges than specified with the hubsize qualify.
     * If a hubsize is not defined, the hubsize will be determined as the average
     * value plus two standard deviations.
     * For all qualifying nodes, clusterByConnection is performed on each of them.
     * The options object is described for clusterByConnection and does the same here.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {number} [hubsize] optional hubsize
     * @param {ClusterOptions} [options] optional cluster options
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.clusterByHubsize = function (visNetwork, hubsize, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].clusterByHubsize(hubsize, options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * This method will cluster all nodes with 1 edge with their respective connected node.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {ClusterOptions} [options] optional cluster options
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.clusterOutliers = function (visNetwork, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].clusterOutliers(options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Nodes can be in clusters.
     * Clusters can also be in clusters.
     * This function returns an array of nodeIds showing where the node is.
     *
     * Example:
     * cluster 'A' contains cluster 'B', cluster 'B' contains cluster 'C',
     * cluster 'C' contains node 'fred'.
     *
     * network.clustering.findNode('fred') will return ['A','B','C','fred'].
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId the node id.
     * @returns {IdType[]} an array of nodeIds showing where the node is
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.findNode = function (visNetwork, nodeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].findNode(nodeId);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Similar to findNode in that it returns all the edge ids that were
     * created from the provided edge during clustering.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} baseEdgeId the base edge id
     * @returns {IdType[]} an array of edgeIds
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getClusteredEdges = function (visNetwork, baseEdgeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getClusteredEdges(baseEdgeId);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * When a clusteredEdgeId is available, this method will return the original
     * baseEdgeId provided in data.edges ie.
     * After clustering the 'SelectEdge' event is fired but provides only the clustered edge.
     * This method can then be used to return the baseEdgeId.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} clusteredEdgeId
     * @returns {IdType}
     *
     * @memberOf NetworkService
     *
     */
    VisNetworkService.prototype.getBaseEdge = function (visNetwork, clusteredEdgeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getBaseEdge(clusteredEdgeId);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Visible edges between clustered nodes are not the same edge as the ones provided
     * in data.edges passed on network creation. With each layer of clustering, copies of
     * the edges between clusters are created and the previous edges are hidden,
     * until the cluster is opened. This method takes an edgeId (ie. a base edgeId from data.edges)
     * and applys the options to it and any edges that were created from it while clustering.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} startEdgeId
     * @param {VisEdgeOptions} [options]
     *
     * @memberOf NetworkService
     *
     */
    VisNetworkService.prototype.updateEdge = function (visNetwork, startEdgeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].updateEdge(startEdgeId, options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Clustered Nodes when created are not contained in the original data.nodes
     * passed on network creation. This method updates the cluster node.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} clusteredNodeId
     * @param {NodeOptions} options
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.updateClusteredNode = function (visNetwork, clusteredNodeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].updateClusteredNode(clusteredNodeId, options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Returns an array of all nodeIds of the nodes that
     * would be released if you open the cluster.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} clusterNodeId the id of the cluster node
     * @returns {IdType[]}
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getNodesInCluster = function (visNetwork, clusterNodeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getNodesInCluster(clusterNodeId);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Opens the cluster, releases the contained nodes and edges,
     * removing the cluster node and cluster edges.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId The node id that represents the cluster.
     * @param {OpenClusterOptions} [options] Cluster options.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.openCluster = function (visNetwork, nodeId, options) {
        if (this.networks[visNetwork]) {
            this.networks[visNetwork].openCluster(nodeId, options);
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    /**
     * Returns true if the node whose ID has been supplied is a cluster.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId The associated node id.
     * @returns {boolean} True if the node whose ID has been supplied is a cluster.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.isCluster = function (visNetwork, nodeId) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].isCluster(nodeId);
        }
        return false;
    };
    /**
     * If you like the layout of your network and would like it to start in the same way next time,
     * ask for the seed using this method and put it in the layout.randomSeed option.
     *
     * @param {string} visNetwork The network name/identifier.
     * @returns {number} The seed of the current network or -1 when the network is not defined.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getSeed = function (visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getSeed();
        }
        return -1;
    };
    /**
     * This function converts canvas coordinates to coordinates on the DOM.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The canvas position.
     * @returns {Position} The DOM position.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.canvasToDOM = function (visNetwork, position) {
        return this.networks[visNetwork].canvasToDOM(position);
    };
    /**
     * This function converts DOM coordinates to coordinates on the canvas.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The DOM position.
     * @returns {Position} The canvas position.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.DOMtoCanvas = function (visNetwork, position) {
        return this.networks[visNetwork].DOMtoCanvas(position);
    };
    /**
     * This function looks up the node at the given DOM coordinates on the canvas.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container -> DOM not Canvas coords.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The DOM position.
     * @returns {IdType} nodeId The associated node id.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getNodeAt = function (visNetwork, position) {
        return this.networks[visNetwork].getNodeAt(position);
    };
    /**
     * This function looks up the edge at the given DOM coordinates on the canvas.
     * Input and output are in the form of {x:Number,y:Number}.
     * The DOM values are relative to the network container -> DOM not Canvas coords.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {Position} position The DOM position.
     * @returns {IdType} edgeId The associated edge id.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getEdgeAt = function (visNetwork, position) {
        return this.networks[visNetwork].getEdgeAt(position);
    };
    /**
     * This function looks up the edges for a given nodeId.
     * The DOM values are relative to the network container -> DOM not Canvas coords.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {IdType} nodeId The associated node id.
     * @returns {IdType[]} Return array of edge ids
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getConnectedEdges = function (visNetwork, nodeId) {
        return this.networks[visNetwork].getConnectedEdges(nodeId);
    };
    /**
     * Returns an array of nodeIds of the all the nodes that are directly connected to this node.
     * If you supply an edgeId, vis will first match the id to nodes.
     * If no match is found, it will search in the edgelist and return an array: [fromId, toId].
     *
     * @param {string} visNetwork The network name/identifier.
     * @param nodeOrEdgeId a node or edge id
     * @returns {IdType[]} Return array of node ids
     */
    VisNetworkService.prototype.getConnectedNodes = function (visNetwork, nodeOrEdgeId) {
        return this.networks[visNetwork].getConnectedNodes(nodeOrEdgeId);
    };
    /**
     * Returns the positions of the nodes.
     * @param {string} visNetwork The network name/identifier.
     * @param {Array.<Node.id>|String} [ids]  --> optional, can be array of nodeIds, can be string
     * @returns {{}}
     */
    VisNetworkService.prototype.getPositions = function (visNetwork, nodeIds) {
        return this.networks[visNetwork].getPositions(nodeIds);
    };
    /**
     * Returns the positions of the nodes.
     * @param {string} visNetwork The network name/identifier.
     */
    VisNetworkService.prototype.getBoundingBox = function (visNetwork, nodeId) {
        return this.networks[visNetwork].getBoundingBox(nodeId);
    };
    /**
     * Returns the positions of the nodes.
     * @param {string} visNetwork The network name/identifier.
     */
    VisNetworkService.prototype.storePositions = function (visNetwork) {
        return this.networks[visNetwork].storePositions();
    };
    /**
     * You can animate or move the camera using the moveTo method.
     *
     * @param {string} visNetwork The network name/identifier.
     * @param {MoveToOptions} options Options for moveTo function.
     */
    VisNetworkService.prototype.moveTo = function (visNetwork, moveToOptions) {
        return this.networks[visNetwork].moveTo(moveToOptions);
    };
    /**
     * Start the physics simulation.
     * This is normally done whenever needed and is only really useful
     * if you stop the simulation yourself and wish to continue it afterwards.
     * @param {string} visNetwork The network name/identifier.
     */
    VisNetworkService.prototype.startSimulation = function (visNetwork) {
        return this.networks[visNetwork].startSimulation();
    };
    /**
     * This stops the physics simulation and triggers a stabilized event.
     * Tt can be restarted by dragging a node,
     * altering the dataset or calling startSimulation().
     * @param {string} visNetwork The network name/identifier.
     */
    VisNetworkService.prototype.stopSimulation = function (visNetwork) {
        return this.networks[visNetwork].stopSimulation();
    };
    /**
     * Returns the current scale of the network. 1.0 is comparible to 100%, 0 is zoomed out infinitely.
     *
     * @param {string} visNetwork The network name/identifier.
     *
     * @throws {Error} Thrown when the network does not exist.
     *
     * @memberOf NetworkService
     */
    VisNetworkService.prototype.getScale = function (visNetwork) {
        if (this.networks[visNetwork]) {
            return this.networks[visNetwork].getScale();
        }
        else {
            throw new Error("Network with id " + visNetwork + " not found.");
        }
    };
    VisNetworkService = tslib_1.__decorate([
        Injectable()
    ], VisNetworkService);
    return VisNetworkService;
}());
export { VisNetworkService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlzLW5ldHdvcmsuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC12aXMvIiwic291cmNlcyI6WyJjb21wb25lbnRzL25ldHdvcmsvdmlzLW5ldHdvcmsuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDekQsT0FBTyxFQVFMLE9BQU8sRUFNUixNQUFNLGFBQWEsQ0FBQztBQUVyQjs7Ozs7R0FLRztBQUVIO0lBREE7UUFFRTs7Ozs7V0FLRztRQUNJLFVBQUssR0FBc0IsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUUxRDs7Ozs7Ozs7V0FRRztRQUNJLGdCQUFXLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFaEU7Ozs7Ozs7V0FPRztRQUNJLGNBQVMsR0FBc0IsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUU5RDs7Ozs7O1dBTUc7UUFDSSxTQUFJLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFekQ7Ozs7OztXQU1HO1FBQ0ksWUFBTyxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBRTVEOzs7Ozs7O1dBT0c7UUFDSSxXQUFNLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFM0Q7Ozs7O1dBS0c7UUFDSSxlQUFVLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFL0Q7Ozs7O1dBS0c7UUFDSSxlQUFVLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFFL0Q7Ozs7OztXQU1HO1FBQ0ksaUJBQVksR0FBc0IsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUVqRTs7Ozs7O1dBTUc7UUFDSSxpQkFBWSxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBRWpFOzs7OztXQUtHO1FBQ0ksY0FBUyxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBRTlEOzs7OztXQUtHO1FBQ0ksYUFBUSxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBRTdE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QUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDcEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksa0NBQU0sR0FBYixVQUFjLFVBQWtCLEVBQUUsYUFBNEI7UUFDNUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSwyQ0FBZSxHQUF0QixVQUF1QixVQUFrQjtRQUN2QyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDckQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksMENBQWMsR0FBckIsVUFBc0IsVUFBa0I7UUFDdEMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ3BELENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLG9DQUFRLEdBQWYsVUFBZ0IsVUFBa0I7UUFDaEMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzdCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUM3QzthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBbUIsVUFBVSxnQkFBYSxDQUFDLENBQUM7U0FDN0Q7SUFDSCxDQUFDO0lBOWlDVSxpQkFBaUI7UUFEN0IsVUFBVSxFQUFFO09BQ0EsaUJBQWlCLENBK2lDN0I7SUFBRCx3QkFBQztDQUFBLEFBL2lDRCxJQStpQ0M7U0EvaUNZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQm91bmRpbmdCb3gsXG4gIENsdXN0ZXJPcHRpb25zLFxuICBEYXRhLFxuICBFZGdlT3B0aW9ucyxcbiAgRml0T3B0aW9ucyxcbiAgSWRUeXBlLFxuICBNb3ZlVG9PcHRpb25zLFxuICBOZXR3b3JrLFxuICBOZXR3b3JrRXZlbnRzLFxuICBOb2RlT3B0aW9ucyxcbiAgT3BlbkNsdXN0ZXJPcHRpb25zLFxuICBPcHRpb25zLFxuICBQb3NpdGlvblxufSBmcm9tICd2aXMtbmV0d29yayc7XG5cbi8qKlxuICogQSBzZXJ2aWNlIHRvIGNyZWF0ZSwgbWFuYWdlIGFuZCBjb250cm9sIE5ldHdvcmsgaW5zdGFuY2VzLlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBOZXR3b3JrU2VydmljZVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVmlzTmV0d29ya1NlcnZpY2Uge1xuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIG1vdXNlIG9yIHRhcHMgb24gYSB0b3VjaHNjcmVlbiBkZXZpY2UuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2xpY2s6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlIGNsaWNrcyB0aGUgbW91c2Ugb3IgZG91YmxlIHRhcHMgb24gYSB0b3VjaHNjcmVlbiBkZXZpY2UuXG4gICAqIFNpbmNlIGEgZG91YmxlIGNsaWNrIGlzIGluIGZhY3QgMiBjbGlja3MsIDIgY2xpY2sgZXZlbnRzIGFyZSBmaXJlZCwgZm9sbG93ZWQgYnkgYSBkb3VibGUgY2xpY2sgZXZlbnQuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0byB1c2UgdGhlIGNsaWNrIGV2ZW50cyBpZiBhIGRvdWJsZSBjbGljayBldmVudCBpcyBmaXJlZCxcbiAgICoganVzdCBjaGVjayB0aGUgdGltZSBiZXR3ZWVuIGNsaWNrIGV2ZW50cyBiZWZvcmUgcHJvY2Vzc2luZyB0aGVtLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGRvdWJsZUNsaWNrOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrIG9uIHRoZSBjYW52YXMgd2l0aCB0aGUgcmlnaHQgbW91c2UgYnV0dG9uLlxuICAgKiBUaGUgcmlnaHQgbW91c2UgYnV0dG9uIGRvZXMgbm90IHNlbGVjdCBieSBkZWZhdWx0LlxuICAgKiBZb3UgY2FuIHVzZSB0aGUgbWV0aG9kIGdldE5vZGVBdCB0byBzZWxlY3QgdGhlIG5vZGUgaWYgeW91IHdhbnQuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgb25jb250ZXh0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhbmQgaG9sZHMgdGhlIG1vdXNlIG9yIHRhcHMgYW5kIGhvbGRzIG9uIGEgdG91Y2hzY3JlZW4gZGV2aWNlLlxuICAgKiBBIGNsaWNrIGV2ZW50IGlzIGFsc28gZmlyZWQgaW4gdGhpcyBjYXNlLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGhvbGQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIGFmdGVyIGRyYXdpbmcgb24gdGhlIGNhbnZhcyBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAqIENhbiBiZSB1c2VkIHRvIGRyYXcgb24gdG9wIG9mIHRoZSBuZXR3b3JrLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHJlbGVhc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZCBieSB1c2VyIGFjdGlvbi5cbiAgICogVGhpcyBtZWFucyBhIG5vZGUgb3IgZWRnZSBoYXMgYmVlbiBzZWxlY3RlZCwgYWRkZWQgdG8gdGhlIHNlbGVjdGlvbiBvciBkZXNlbGVjdGVkLlxuICAgKiBBbGwgc2VsZWN0IGV2ZW50cyBhcmUgb25seSB0cmlnZ2VyZWQgb24gY2xpY2sgYW5kIGhvbGQuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgc2VsZWN0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIGEgbm9kZSBoYXMgYmVlbiBzZWxlY3RlZCBieSB0aGUgdXNlci5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzZWxlY3ROb2RlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIGEgZWRnZSBoYXMgYmVlbiBzZWxlY3RlZCBieSB0aGUgdXNlci5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzZWxlY3RFZGdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIGEgbm9kZSAob3Igbm9kZXMpIGhhcyAob3IgaGF2ZSkgYmVlbiBkZXNlbGVjdGVkIGJ5IHRoZSB1c2VyLlxuICAgKiBUaGUgcHJldmlvdXMgc2VsZWN0aW9uIGlzIHRoZSBsaXN0IG9mIG5vZGVzIGFuZCBlZGdlcyB0aGF0IHdlcmUgc2VsZWN0ZWQgYmVmb3JlIHRoZSBsYXN0IHVzZXIgZXZlbnQuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZGVzZWxlY3ROb2RlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIGEgZWRnZSAob3IgZWRnZXMpIGhhcyAob3IgaGF2ZSkgYmVlbiBkZXNlbGVjdGVkIGJ5IHRoZSB1c2VyLlxuICAgKiBUaGUgcHJldmlvdXMgc2VsZWN0aW9uIGlzIHRoZSBsaXN0IG9mIG5vZGVzIGFuZCBlZGdlcyB0aGF0IHdlcmUgc2VsZWN0ZWQgYmVmb3JlIHRoZSBsYXN0IHVzZXIgZXZlbnQuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZGVzZWxlY3RFZGdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHN0YXJ0aW5nIGEgZHJhZy5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkcmFnU3RhcnQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gZHJhZ2dpbmcgbm9kZShzKSBvciB0aGUgdmlldy5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkcmFnZ2luZzogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZHJhZyBoYXMgZmluaXNoZWQuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZHJhZ0VuZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgaWYgdGhlIG9wdGlvbiBpbnRlcmFjdGlvbjp7aG92ZXI6dHJ1ZX0gaXMgZW5hYmxlZCBhbmQgdGhlIG1vdXNlIGhvdmVycyBvdmVyIGEgbm9kZS5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBob3Zlck5vZGU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIGlmIHRoZSBvcHRpb24gaW50ZXJhY3Rpb246e2hvdmVyOnRydWV9IGlzIGVuYWJsZWQgYW5kXG4gICAqIHRoZSBtb3VzZSBtb3ZlZCBhd2F5IGZyb20gYSBub2RlIGl0IHdhcyBob3ZlcmluZyBvdmVyIGJlZm9yZS5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBibHVyTm9kZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgaWYgdGhlIG9wdGlvbiBpbnRlcmFjdGlvbjp7aG92ZXI6dHJ1ZX0gaXMgZW5hYmxlZCBhbmQgdGhlIG1vdXNlIGhvdmVycyBvdmVyIGFuIGVkZ2UuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgaG92ZXJFZGdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCBpZiB0aGUgb3B0aW9uIGludGVyYWN0aW9uOntob3Zlcjp0cnVlfSBpcyBlbmFibGVkIGFuZFxuICAgKiB0aGUgbW91c2UgbW92ZWQgYXdheSBmcm9tIGFuIGVkZ2UgaXQgd2FzIGhvdmVyaW5nIG92ZXIgYmVmb3JlLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGJsdXJFZGdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIHpvb21zIGluIG9yIG91dC5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB6b29tOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBwb3B1cCAodG9vbHRpcCkgaXMgc2hvd24uXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgc2hvd1BvcHVwOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBwb3B1cCAodG9vbHRpcCkgaXMgaGlkZGVuLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGhpZGVQb3B1cDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiBzdGFiaWxpemF0aW9uIHN0YXJ0cy5cbiAgICogVGhpcyBpcyBhbHNvIHRoZSBjYXNlIHdoZW4geW91IGRyYWcgYSBub2RlIGFuZCB0aGUgcGh5c2ljc1xuICAgKiBzaW11bGF0aW9uIHJlc3RhcnRzIHRvIHN0YWJpbGl6ZSBhZ2Fpbi5cbiAgICogU3RhYmlsaXphdGlvbiBkb2VzIG5vdCBuZWNjZXNhcmlseSBpbXBseSAnd2l0aG91dCBzaG93aW5nJy5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzdGFydFN0YWJpbGl6aW5nOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIGEgbXVsdGlwbGUgb2YgdGhlIHVwZGF0ZUludGVydmFsIG51bWJlciBvZiBpdGVyYXRpb25zIGlzIHJlYWNoZWQuXG4gICAqIFRoaXMgb25seSBvY2N1cnMgaW4gdGhlICdoaWRkZW4nIHN0YWJpbGl6YXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgc3RhYmlsaXphdGlvblByb2dyZXNzOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSAnaGlkZGVuJyBzdGFiaWxpemF0aW9uIGZpbmlzaGVzLlxuICAgKiBUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhlIG5ldHdvcmsgaXMgc3RhYmlsaXplZDtcbiAgICogaXQgY291bGQgYWxzbyBtZWFuIHRoYXQgdGhlIGFtb3VudCBvZiBpdGVyYXRpb25zIGRlZmluZWQgaW4gdGhlIG9wdGlvbnMgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzdGFiaWxpemF0aW9uSXRlcmF0aW9uc0RvbmU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlICdoaWRkZW4nIHN0YWJpbGl6YXRpb24gZmluaXNoZXMuXG4gICAqIFRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbiB0aGUgbmV0d29yayBpcyBzdGFiaWxpemVkO1xuICAgKiBpdCBjb3VsZCBhbHNvIG1lYW4gdGhhdCB0aGUgYW1vdW50IG9mIGl0ZXJhdGlvbnMgZGVmaW5lZCBpbiB0aGUgb3B0aW9ucyBoYXMgYmVlbiByZWFjaGVkLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHN0YWJpbGl6ZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBoYXMgYmVlbiByZXNpemVkLFxuICAgKiBlaXRoZXIgYnkgYSByZWRyYXcgY2FsbCB3aGVuIHRoZSBjb250YWluZXIgZGl2IGhhcyBjaGFuZ2VkIGluIHNpemUsXG4gICAqIGEgc2V0U2l6ZSgpIGNhbGwgd2l0aCBuZXcgdmFsdWVzIG9yIGEgc2V0T3B0aW9ucygpIHdpdGggbmV3IHdpZHRoIGFuZC9vciBoZWlnaHQgdmFsdWVzLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHJlc2l6ZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAvKipcbiAgICogRmlyZWQgYmVmb3JlIHRoZSByZWRyYXdpbmcgYmVnaW5zLlxuICAgKiBUaGUgc2ltdWxhdGlvbiBzdGVwIGhhcyBjb21wbGV0ZWQgYXQgdGhpcyBwb2ludC5cbiAgICogQ2FuIGJlIHVzZWQgdG8gbW92ZSBjdXN0b20gZWxlbWVudHMgYmVmb3JlIHN0YXJ0aW5nIGRyYXdpbmcgdGhlIG5ldyBmcmFtZS5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBpbml0UmVkcmF3OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCBhZnRlciB0aGUgY2FudmFzIGhhcyBiZWVuIGNsZWFyZWQsIHNjYWxlZCBhbmQgdHJhbnNsYXRlZCB0b1xuICAgKiB0aGUgdmlld2luZyBwb3NpdGlvbiBidXQgYmVmb3JlIGFsbCBlZGdlcyBhbmQgbm9kZXMgYXJlIGRyYXduLlxuICAgKiBDYW4gYmUgdXNlZCB0byBkcmF3IGJlaGluZCB0aGUgbmV0d29yay5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBiZWZvcmVEcmF3aW5nOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCBhZnRlciBkcmF3aW5nIG9uIHRoZSBjYW52YXMgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgKiBDYW4gYmUgdXNlZCB0byBkcmF3IG9uIHRvcCBvZiB0aGUgbmV0d29yay5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxhbnk+fVxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBhZnRlckRyYXdpbmc6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gYW4gYW5pbWF0aW9uIGlzIGZpbmlzaGVkLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGFuaW1hdGlvbkZpbmlzaGVkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIGEgdXNlciBjaGFuZ2VzIGFueSBvcHRpb24gaW4gdGhlIGNvbmZpZ3VyYXRvci5cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBiZSB1c2VkIHdpdGggdGhlIHNldE9wdGlvbnMgbWV0aG9kIG9yIHN0cmluZ2lmaWVkIHVzaW5nIEpTT04uc3RyaW5naWZ5KCkuXG4gICAqIFlvdSBkbyBub3QgaGF2ZSB0byBtYW51YWxseSBwdXQgdGhlIG9wdGlvbnMgaW50byB0aGUgbmV0d29yazogdGhpcyBpcyBkb25lIGF1dG9tYXRpY2FsbHkuXG4gICAqIFlvdSBjYW4gdXNlIHRoZSBldmVudCB0byBzdG9yZSB1c2VyIG9wdGlvbnMgaW4gdGhlIGRhdGFiYXNlLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNvbmZpZ0NoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICBwcml2YXRlIG5ldHdvcmtzOiB7IFtpZDogc3RyaW5nXTogTmV0d29yayB9ID0ge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbmV0d29yayBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgVGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBuZXR3b3JrIHZpZXcuXG4gICAqIEBwYXJhbSB7RGF0YX0gZGF0YSBUaGUgaW5pdGlhbCBuZXR3b3JrIG5vZGVzIGFuZCBlZGdlcy5cbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gVGhlIG5ldHdvcmsgb3B0aW9ucy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIGEgbmV0d29yayB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNyZWF0ZSh2aXNOZXR3b3JrOiBzdHJpbmcsIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIGRhdGE6IERhdGEsIG9wdGlvbnM/OiBPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgfVxuXG4gICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSA9IG5ldyBOZXR3b3JrKGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBuZXR3b3JrIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlIGFsbCBIYW1tZXIgYmluZGluZ3MgYW5kIHJlZmVyZW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSh2aXNOZXR3b3JrOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5kZXN0cm95KCk7XG4gICAgICBkZWxldGUgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIGFuIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7TmV0d29ya0V2ZW50c30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXZlbnREZWZhdWx0IFN0b3BzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBldmVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBldmVudCB3YXMgYWN0aXZhdGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBvbih2aXNOZXR3b3JrOiBzdHJpbmcsIGV2ZW50TmFtZTogTmV0d29ya0V2ZW50cywgcHJldmVudERlZmF1bHQ/OiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIC8qIHRzbGludDpkaXNhYmxlICovXG4gICAgICBjb25zdCB0aGF0OiB7IFtpbmRleDogc3RyaW5nXTogYW55IH0gPSB0aGlzO1xuICAgICAgLyogdHNsaW50OmVuYWJsZSAqL1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5vbihldmVudE5hbWUsIChwYXJhbXM6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBlbWl0dGVyID0gdGhhdFtldmVudE5hbWVdIGFzIEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgIGVtaXR0ZXIuZW1pdChwYXJhbXMgPyBbdmlzTmV0d29ya10uY29uY2F0KHBhcmFtcykgOiB2aXNOZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmVudERlZmF1bHQgJiYgcGFyYW1zLmV2ZW50KSB7XG4gICAgICAgICAgcGFyYW1zLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgYW4gZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtOZXR3b3JrRXZlbnRzfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIG9mZih2aXNOZXR3b3JrOiBzdHJpbmcsIGV2ZW50TmFtZTogTmV0d29ya0V2ZW50cyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLm9mZihldmVudE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb25seSBvbmNlLlxuICAgKiBBZnRlciBpdCBoYXMgdGFrZW4gcGxhY2UsIHRoZSBldmVudCBsaXN0ZW5lciB3aWxsIGJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtOZXR3b3JrRXZlbnRzfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZXZlbnQgd2FzIGFjdGl2YXRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgb25jZSh2aXNOZXR3b3JrOiBzdHJpbmcsIGV2ZW50TmFtZTogTmV0d29ya0V2ZW50cyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuICAgICAgY29uc3QgdGhhdDogeyBbaW5kZXg6IHN0cmluZ106IGFueSB9ID0gdGhpcztcbiAgICAgIC8qIHRzbGludDpkaXNhYmxlICovXG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLm9uKGV2ZW50TmFtZSwgKHBhcmFtczogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGF0W2V2ZW50TmFtZV0gYXMgRXZlbnRFbWl0dGVyPGFueT47XG4gICAgICAgIGlmIChlbWl0dGVyKSB7XG4gICAgICAgICAgZW1pdHRlci5lbWl0KHBhcmFtcyA/IFt2aXNOZXR3b3JrXS5jb25jYXQocGFyYW1zKSA6IHZpc05ldHdvcmspO1xuICAgICAgICAgIHRoaXMub2ZmKHZpc05ldHdvcmssIGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgYWxsIHRoZSBkYXRhIGluIHRoZSBuZXR3b3JrLlxuICAgKiBJZiBzdGFiaWxpemF0aW9uIGlzIGVuYWJsZWQgaW4gdGhlIHBoeXNpY3MgbW9kdWxlLFxuICAgKiB0aGUgbmV0d29yayB3aWxsIHN0YWJpbGl6ZSBhZ2Fpbi5cbiAgICogVGhpcyBtZXRob2QgaXMgYWxzbyBwZXJmb3JtZWQgd2hlbiBmaXJzdCBpbml0aWFsaXppbmcgdGhlIG5ldHdvcmsuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtEYXRhfSBkYXRhIFRoZSBuZXR3b3JrIGRhdGEuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd24gd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgc2V0RGF0YSh2aXNOZXR3b3JrOiBzdHJpbmcsIGRhdGE6IERhdGEpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5zZXREYXRhKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBUaGUgbmV0d29yayBvcHRpb25zLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHNldE9wdGlvbnModmlzTmV0d29yazogc3RyaW5nLCBvcHRpb25zOiBPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgdGhlIG5vZGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGlkJ3MgaW4gdGhlIGlucHV0IGFycmF5LlxuICAgKiBUaGlzIG1ldGhvZCB1bnNlbGVjdHMgYWxsIG90aGVyIG9iamVjdHMgYmVmb3JlIHNlbGVjdGluZyBpdHMgb3duIG9iamVjdHMuXG4gICAqIERvZXMgbm90IGZpcmUgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SWRUeXBlW119IG5vZGVJZHMgVGhlIG5vZGUgaWRzIHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWdobGlnaHRFZGdlc10gSWYgaGlnaGxpZ2h0RWRnZXMgaXMgdHJ1ZSBvciB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmVpZ2hib3VyaW5nIGVkZ2VzIHdpbGwgYWxzbyBiZSBzZWxlY3RlZC5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzZWxlY3ROb2Rlcyh2aXNOZXR3b3JrOiBzdHJpbmcsIG5vZGVJZHM6IElkVHlwZVtdLCBoaWdobGlnaHRFZGdlcz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5zZWxlY3ROb2Rlcyhub2RlSWRzLCBoaWdobGlnaHRFZGdlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSBub2RlcyBhbmQgZWRnZXMgY29ycmVzcG9uZGluZyB0byB0aGUgaWQncyBpbiB0aGUgaW5wdXQgYXJyYXlzLlxuICAgKiBEb2VzIG5vdCBmaXJlIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0geyBub2RlczogSWRUeXBlW10sIGVkZ2VzOiBJZFR5cGVbXSB9IHNlbGVjdGlvbiBUaGUgbm9kZSBhbmQgZWRnZSBpZHMgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB7IHVuc2VsZWN0QWxsPzogYm9vbGVhbiwgaGlnaGxpZ2h0RWRnZXM/OiBib29sZWFuIH0gW29wdGlvbnNdXG4gICAqIElmIHVuc2VsZWN0QWxsIGlzIHRydWUgb3IgdW5kZWZpbmVkLCB0aGUgb3RoZXIgb2JqZWN0cyB3aWxsIGJlIGRlc2VsZWN0ZWQuXG4gICAqIElmIGhpZ2hsaWdodEVkZ2VzIGlzIHRydWUgb3IgdW5kZWZpbmVkLCB0aGUgbmVpZ2hib3VyaW5nIGVkZ2VzIHdpbGwgYWxzbyBiZSBzZWxlY3RlZC5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzZXRTZWxlY3Rpb24oXG4gICAgdmlzTmV0d29yazogc3RyaW5nLFxuICAgIHNlbGVjdGlvbjogeyBub2RlczogSWRUeXBlW107IGVkZ2VzOiBJZFR5cGVbXSB9LFxuICAgIG9wdGlvbnM6IHsgdW5zZWxlY3RBbGw/OiBib29sZWFuOyBoaWdobGlnaHRFZGdlcz86IGJvb2xlYW4gfSA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLnNldFNlbGVjdGlvbihzZWxlY3Rpb24sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzZWxlY3RlZCBub2RlcyBhbmQgZWRnZXMgaWRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEByZXR1cm5zIHt7IG5vZGVzOiBJZFR5cGVbXSwgZWRnZXM6IElkVHlwZVtdIH19XG4gICAqIFRoZSBzZWxlY3RlZCBub2RlIGFuZCBlZGdlIGlkcyBvciB1bmRlZmluZWQgd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0U2VsZWN0aW9uKHZpc05ldHdvcms6IHN0cmluZyk6IHsgbm9kZXM6IElkVHlwZVtdOyBlZGdlczogSWRUeXBlW10gfSB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc2VsZWN0ZWQgbm9kZSBpZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHJldHVybnMge0lkVHlwZVtdfSBUaGUgc2VsZWN0ZWQgbm9kZSBpZHMgb3IgdW5kZWZpbmVkIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFNlbGVjdGVkTm9kZXModmlzTmV0d29yazogc3RyaW5nKTogSWRUeXBlW10ge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5nZXRTZWxlY3RlZE5vZGVzKCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzZWxlY3RlZCBlZGdlIGlkcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcmV0dXJucyB7SWRUeXBlW119IFRoZSBzZWxlY3RlZCBlZGdlIGlkcyBvciB1bmRlZmluZWQgd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0U2VsZWN0ZWRFZGdlcyh2aXNOZXR3b3JrOiBzdHJpbmcpOiBJZFR5cGVbXSB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldFNlbGVjdGVkRWRnZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNlbGVjdCBhbGwgb2JqZWN0cy5cbiAgICogRG9lcyBub3QgZmlyZSBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB1bnNlbGVjdEFsbCh2aXNOZXR3b3JrOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS51bnNlbGVjdEFsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogWm9vbXMgb3V0IHNvIGFsbCBub2RlcyBmaXQgb24gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge1Zpc0ZpdE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIHRvIGN1c3RvbWl6ZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBmaXQodmlzTmV0d29yazogc3RyaW5nLCBvcHRpb25zPzogRml0T3B0aW9ucyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmZpdChvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgbmV0d29yay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIHJlZHJhdyh2aXNOZXR3b3JrOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5yZWRyYXcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGludG8gYWRkTm9kZSBtb2RlLiBIYXZpbmcgZWRpdCBtb2RlIG9yIG1hbmlwdWxhdGlvbiBlbmFibGVkIGlzIG5vdCByZXF1aXJlZC5cbiAgICogVG8gZ2V0IG91dCBvZiB0aGlzIG1vZGUsIGNhbGwgZGlzYWJsZUVkaXRNb2RlKCkuIFRoZSBjYWxsYmFjayBmdW5jdGlvbnMgZGVmaW5lZCBpbiBoYW5kbGVyRnVuY3Rpb25zIHN0aWxsIGFwcGx5LlxuICAgKiBUbyB1c2UgdGhlc2UgbWV0aG9kcyB3aXRob3V0IGhhdmluZyB0aGUgbWFuaXB1bGF0aW9uIEdVSSwgbWFrZSBzdXJlIHlvdSBzZXQgZW5hYmxlZCB0byBmYWxzZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGFkZE5vZGVNb2RlKHZpc05ldHdvcms6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmFkZE5vZGVNb2RlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9ncmFtYXRpY2FsbHkgZW5hYmxlIHRoZSBlZGl0IG1vZGUuXG4gICAqIFNpbWlsYXIgZWZmZWN0IHRvIHByZXNzaW5nIHRoZSBlZGl0IGJ1dHRvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGVuYWJsZUVkaXRNb2RlKHZpc05ldHdvcms6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBpbnRvIGFkZEVkZ2UgbW9kZS5cbiAgICogVGhlIGV4cGxhaW5hdGlvbiBmcm9tIGFkZE5vZGVNb2RlIGFwcGxpZXMgaGVyZSBhcyB3ZWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd24gd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgYWRkRWRnZU1vZGUodmlzTmV0d29yazogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uYWRkRWRnZU1vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2dyYW1hdGljYWxseSBkaXNhYmxlIHRoZSBlZGl0IG1vZGUuXG4gICAqIFNpbWlsYXIgZWZmZWN0IHRvIHByZXNzaW5nIHRoZSBjbG9zZSBpY29uXG4gICAqIChzbWFsbCBjcm9zcyBpbiB0aGUgY29ybmVyIG9mIHRoZSB0b29sYmFyKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGRpc2FibGVFZGl0TW9kZSh2aXNOZXR3b3JrOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBzZWxlY3RlZC5cbiAgICogSGF2aW5nIGVkaXQgbW9kZSBvciBtYW5pcHVsYXRpb24gZW5hYmxlZCBpcyBub3QgcmVxdWlyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkZWxldGVTZWxlY3RlZCh2aXNOZXR3b3JrOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5kZWxldGVTZWxlY3RlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjbHVzdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7Q2x1c3Rlck9wdGlvbnN9IFtvcHRpb25zXSBUaGUgam9pbkNvbmRpdGlvbiBmdW5jdGlvbiBpcyBwcmVzZW50ZWQgd2l0aCBhbGwgbm9kZXMuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd24gd2hlbiB0aGUgbmV0d29yayBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2x1c3Rlcih2aXNOZXR3b3JrOiBzdHJpbmcsIG9wdGlvbnM/OiBDbHVzdGVyT3B0aW9ucyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmNsdXN0ZXIob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBsb29rcyBhdCB0aGUgcHJvdmlkZWQgbm9kZSBhbmQgbWFrZXMgYSBjbHVzdGVyIG9mIGl0IGFuZCBhbGwgaXQncyBjb25uZWN0ZWQgbm9kZXMuXG4gICAqIFRoZSBiZWhhdmlvdXIgY2FuIGJlIGN1c3RvbWl6ZWQgYnkgcHJvdmluZyB0aGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEFsbCBvcHRpb25zIG9mIHRoaXMgb2JqZWN0IGFyZSBleHBsYWluZWQgYmVsb3cuXG4gICAqIFRoZSBqb2luQ29uZGl0aW9uIGlzIG9ubHkgcHJlc2VudGVkIHdpdGggdGhlIGNvbm5lY3RlZCBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge0lkVHlwZX0gbm9kZUlkIHRoZSBpZCBvZiB0aGUgbm9kZVxuICAgKiBAcGFyYW0ge0NsdXN0ZXJPcHRpb25zfSBbb3B0aW9uc10gdGhlIGNsdXN0ZXIgb3B0aW9uc1xuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjbHVzdGVyQnlDb25uZWN0aW9uKHZpc05ldHdvcms6IHN0cmluZywgbm9kZUlkOiBJZFR5cGUsIG9wdGlvbnM/OiBDbHVzdGVyT3B0aW9ucyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmNsdXN0ZXJCeUNvbm5lY3Rpb24obm9kZUlkIGFzIGFueSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjaGVja3MgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIGFuZCB0aG9zZSB3aXRoIGEgZXF1YWwgb3IgaGlnaGVyXG4gICAqIGFtb3VudCBvZiBlZGdlcyB0aGFuIHNwZWNpZmllZCB3aXRoIHRoZSBodWJzaXplIHF1YWxpZnkuXG4gICAqIElmIGEgaHVic2l6ZSBpcyBub3QgZGVmaW5lZCwgdGhlIGh1YnNpemUgd2lsbCBiZSBkZXRlcm1pbmVkIGFzIHRoZSBhdmVyYWdlXG4gICAqIHZhbHVlIHBsdXMgdHdvIHN0YW5kYXJkIGRldmlhdGlvbnMuXG4gICAqIEZvciBhbGwgcXVhbGlmeWluZyBub2RlcywgY2x1c3RlckJ5Q29ubmVjdGlvbiBpcyBwZXJmb3JtZWQgb24gZWFjaCBvZiB0aGVtLlxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3QgaXMgZGVzY3JpYmVkIGZvciBjbHVzdGVyQnlDb25uZWN0aW9uIGFuZCBkb2VzIHRoZSBzYW1lIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtodWJzaXplXSBvcHRpb25hbCBodWJzaXplXG4gICAqIEBwYXJhbSB7Q2x1c3Rlck9wdGlvbnN9IFtvcHRpb25zXSBvcHRpb25hbCBjbHVzdGVyIG9wdGlvbnNcbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2x1c3RlckJ5SHVic2l6ZSh2aXNOZXR3b3JrOiBzdHJpbmcsIGh1YnNpemU/OiBudW1iZXIsIG9wdGlvbnM/OiBDbHVzdGVyT3B0aW9ucyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmNsdXN0ZXJCeUh1YnNpemUoaHVic2l6ZSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNsdXN0ZXIgYWxsIG5vZGVzIHdpdGggMSBlZGdlIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBjb25uZWN0ZWQgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge0NsdXN0ZXJPcHRpb25zfSBbb3B0aW9uc10gb3B0aW9uYWwgY2x1c3RlciBvcHRpb25zXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNsdXN0ZXJPdXRsaWVycyh2aXNOZXR3b3JrOiBzdHJpbmcsIG9wdGlvbnM/OiBDbHVzdGVyT3B0aW9ucyk6IHZvaWQge1xuICAgIGlmICh0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdKSB7XG4gICAgICB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmNsdXN0ZXJPdXRsaWVycyhvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vZGVzIGNhbiBiZSBpbiBjbHVzdGVycy5cbiAgICogQ2x1c3RlcnMgY2FuIGFsc28gYmUgaW4gY2x1c3RlcnMuXG4gICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBhcnJheSBvZiBub2RlSWRzIHNob3dpbmcgd2hlcmUgdGhlIG5vZGUgaXMuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGNsdXN0ZXIgJ0EnIGNvbnRhaW5zIGNsdXN0ZXIgJ0InLCBjbHVzdGVyICdCJyBjb250YWlucyBjbHVzdGVyICdDJyxcbiAgICogY2x1c3RlciAnQycgY29udGFpbnMgbm9kZSAnZnJlZCcuXG4gICAqXG4gICAqIG5ldHdvcmsuY2x1c3RlcmluZy5maW5kTm9kZSgnZnJlZCcpIHdpbGwgcmV0dXJuIFsnQScsJ0InLCdDJywnZnJlZCddLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SWRUeXBlfSBub2RlSWQgdGhlIG5vZGUgaWQuXG4gICAqIEByZXR1cm5zIHtJZFR5cGVbXX0gYW4gYXJyYXkgb2Ygbm9kZUlkcyBzaG93aW5nIHdoZXJlIHRoZSBub2RlIGlzXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZpbmROb2RlKHZpc05ldHdvcms6IHN0cmluZywgbm9kZUlkOiBJZFR5cGUpOiBJZFR5cGVbXSB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmZpbmROb2RlKG5vZGVJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaW1pbGFyIHRvIGZpbmROb2RlIGluIHRoYXQgaXQgcmV0dXJucyBhbGwgdGhlIGVkZ2UgaWRzIHRoYXQgd2VyZVxuICAgKiBjcmVhdGVkIGZyb20gdGhlIHByb3ZpZGVkIGVkZ2UgZHVyaW5nIGNsdXN0ZXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtJZFR5cGV9IGJhc2VFZGdlSWQgdGhlIGJhc2UgZWRnZSBpZFxuICAgKiBAcmV0dXJucyB7SWRUeXBlW119IGFuIGFycmF5IG9mIGVkZ2VJZHNcbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0Q2x1c3RlcmVkRWRnZXModmlzTmV0d29yazogc3RyaW5nLCBiYXNlRWRnZUlkOiBJZFR5cGUpOiBJZFR5cGVbXSB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldENsdXN0ZXJlZEVkZ2VzKGJhc2VFZGdlSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIGNsdXN0ZXJlZEVkZ2VJZCBpcyBhdmFpbGFibGUsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAgKiBiYXNlRWRnZUlkIHByb3ZpZGVkIGluIGRhdGEuZWRnZXMgaWUuXG4gICAqIEFmdGVyIGNsdXN0ZXJpbmcgdGhlICdTZWxlY3RFZGdlJyBldmVudCBpcyBmaXJlZCBidXQgcHJvdmlkZXMgb25seSB0aGUgY2x1c3RlcmVkIGVkZ2UuXG4gICAqIFRoaXMgbWV0aG9kIGNhbiB0aGVuIGJlIHVzZWQgdG8gcmV0dXJuIHRoZSBiYXNlRWRnZUlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SWRUeXBlfSBjbHVzdGVyZWRFZGdlSWRcbiAgICogQHJldHVybnMge0lkVHlwZX1cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0QmFzZUVkZ2UodmlzTmV0d29yazogc3RyaW5nLCBjbHVzdGVyZWRFZGdlSWQ6IElkVHlwZSk6IElkVHlwZSB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldEJhc2VFZGdlKGNsdXN0ZXJlZEVkZ2VJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWaXNpYmxlIGVkZ2VzIGJldHdlZW4gY2x1c3RlcmVkIG5vZGVzIGFyZSBub3QgdGhlIHNhbWUgZWRnZSBhcyB0aGUgb25lcyBwcm92aWRlZFxuICAgKiBpbiBkYXRhLmVkZ2VzIHBhc3NlZCBvbiBuZXR3b3JrIGNyZWF0aW9uLiBXaXRoIGVhY2ggbGF5ZXIgb2YgY2x1c3RlcmluZywgY29waWVzIG9mXG4gICAqIHRoZSBlZGdlcyBiZXR3ZWVuIGNsdXN0ZXJzIGFyZSBjcmVhdGVkIGFuZCB0aGUgcHJldmlvdXMgZWRnZXMgYXJlIGhpZGRlbixcbiAgICogdW50aWwgdGhlIGNsdXN0ZXIgaXMgb3BlbmVkLiBUaGlzIG1ldGhvZCB0YWtlcyBhbiBlZGdlSWQgKGllLiBhIGJhc2UgZWRnZUlkIGZyb20gZGF0YS5lZGdlcylcbiAgICogYW5kIGFwcGx5cyB0aGUgb3B0aW9ucyB0byBpdCBhbmQgYW55IGVkZ2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gaXQgd2hpbGUgY2x1c3RlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge0lkVHlwZX0gc3RhcnRFZGdlSWRcbiAgICogQHBhcmFtIHtWaXNFZGdlT3B0aW9uc30gW29wdGlvbnNdXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUVkZ2UodmlzTmV0d29yazogc3RyaW5nLCBzdGFydEVkZ2VJZDogSWRUeXBlLCBvcHRpb25zPzogRWRnZU9wdGlvbnMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS51cGRhdGVFZGdlKHN0YXJ0RWRnZUlkLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsdXN0ZXJlZCBOb2RlcyB3aGVuIGNyZWF0ZWQgYXJlIG5vdCBjb250YWluZWQgaW4gdGhlIG9yaWdpbmFsIGRhdGEubm9kZXNcbiAgICogcGFzc2VkIG9uIG5ldHdvcmsgY3JlYXRpb24uIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGNsdXN0ZXIgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge0lkVHlwZX0gY2x1c3RlcmVkTm9kZUlkXG4gICAqIEBwYXJhbSB7Tm9kZU9wdGlvbnN9IG9wdGlvbnNcbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ2x1c3RlcmVkTm9kZSh2aXNOZXR3b3JrOiBzdHJpbmcsIGNsdXN0ZXJlZE5vZGVJZDogSWRUeXBlLCBvcHRpb25zPzogTm9kZU9wdGlvbnMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS51cGRhdGVDbHVzdGVyZWROb2RlKGNsdXN0ZXJlZE5vZGVJZCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBub2RlSWRzIG9mIHRoZSBub2RlcyB0aGF0XG4gICAqIHdvdWxkIGJlIHJlbGVhc2VkIGlmIHlvdSBvcGVuIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SWRUeXBlfSBjbHVzdGVyTm9kZUlkIHRoZSBpZCBvZiB0aGUgY2x1c3RlciBub2RlXG4gICAqIEByZXR1cm5zIHtJZFR5cGVbXX1cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0Tm9kZXNJbkNsdXN0ZXIodmlzTmV0d29yazogc3RyaW5nLCBjbHVzdGVyTm9kZUlkOiBJZFR5cGUpOiBJZFR5cGVbXSB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldE5vZGVzSW5DbHVzdGVyKGNsdXN0ZXJOb2RlSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgd2l0aCBpZCAke3Zpc05ldHdvcmt9IG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGNsdXN0ZXIsIHJlbGVhc2VzIHRoZSBjb250YWluZWQgbm9kZXMgYW5kIGVkZ2VzLFxuICAgKiByZW1vdmluZyB0aGUgY2x1c3RlciBub2RlIGFuZCBjbHVzdGVyIGVkZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7SWRUeXBlfSBub2RlSWQgVGhlIG5vZGUgaWQgdGhhdCByZXByZXNlbnRzIHRoZSBjbHVzdGVyLlxuICAgKiBAcGFyYW0ge09wZW5DbHVzdGVyT3B0aW9uc30gW29wdGlvbnNdIENsdXN0ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93biB3aGVuIHRoZSBuZXR3b3JrIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgTmV0d29ya1NlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBvcGVuQ2x1c3Rlcih2aXNOZXR3b3JrOiBzdHJpbmcsIG5vZGVJZDogSWRUeXBlLCBvcHRpb25zPzogT3BlbkNsdXN0ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10ub3BlbkNsdXN0ZXIobm9kZUlkLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHdpdGggaWQgJHt2aXNOZXR3b3JrfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSB3aG9zZSBJRCBoYXMgYmVlbiBzdXBwbGllZCBpcyBhIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtJZFR5cGV9IG5vZGVJZCBUaGUgYXNzb2NpYXRlZCBub2RlIGlkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbm9kZSB3aG9zZSBJRCBoYXMgYmVlbiBzdXBwbGllZCBpcyBhIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGlzQ2x1c3Rlcih2aXNOZXR3b3JrOiBzdHJpbmcsIG5vZGVJZDogSWRUeXBlKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmlzQ2x1c3Rlcihub2RlSWQpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB5b3UgbGlrZSB0aGUgbGF5b3V0IG9mIHlvdXIgbmV0d29yayBhbmQgd291bGQgbGlrZSBpdCB0byBzdGFydCBpbiB0aGUgc2FtZSB3YXkgbmV4dCB0aW1lLFxuICAgKiBhc2sgZm9yIHRoZSBzZWVkIHVzaW5nIHRoaXMgbWV0aG9kIGFuZCBwdXQgaXQgaW4gdGhlIGxheW91dC5yYW5kb21TZWVkIG9wdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc2VlZCBvZiB0aGUgY3VycmVudCBuZXR3b3JrIG9yIC0xIHdoZW4gdGhlIG5ldHdvcmsgaXMgbm90IGRlZmluZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFNlZWQodmlzTmV0d29yazogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0U2VlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGNhbnZhcyBjb29yZGluYXRlcyB0byBjb29yZGluYXRlcyBvbiB0aGUgRE9NLlxuICAgKiBJbnB1dCBhbmQgb3V0cHV0IGFyZSBpbiB0aGUgZm9ybSBvZiB7eDpOdW1iZXIseTpOdW1iZXJ9LlxuICAgKiBUaGUgRE9NIHZhbHVlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIG5ldHdvcmsgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7UG9zaXRpb259IHBvc2l0aW9uIFRoZSBjYW52YXMgcG9zaXRpb24uXG4gICAqIEByZXR1cm5zIHtQb3NpdGlvbn0gVGhlIERPTSBwb3NpdGlvbi5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2FudmFzVG9ET00odmlzTmV0d29yazogc3RyaW5nLCBwb3NpdGlvbjogUG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5jYW52YXNUb0RPTShwb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBET00gY29vcmRpbmF0ZXMgdG8gY29vcmRpbmF0ZXMgb24gdGhlIGNhbnZhcy5cbiAgICogSW5wdXQgYW5kIG91dHB1dCBhcmUgaW4gdGhlIGZvcm0gb2Yge3g6TnVtYmVyLHk6TnVtYmVyfS5cbiAgICogVGhlIERPTSB2YWx1ZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBuZXR3b3JrIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge1Bvc2l0aW9ufSBwb3NpdGlvbiBUaGUgRE9NIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJucyB7UG9zaXRpb259IFRoZSBjYW52YXMgcG9zaXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIERPTXRvQ2FudmFzKHZpc05ldHdvcms6IHN0cmluZywgcG9zaXRpb246IFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uRE9NdG9DYW52YXMocG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gbG9va3MgdXAgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIERPTSBjb29yZGluYXRlcyBvbiB0aGUgY2FudmFzLlxuICAgKiBJbnB1dCBhbmQgb3V0cHV0IGFyZSBpbiB0aGUgZm9ybSBvZiB7eDpOdW1iZXIseTpOdW1iZXJ9LlxuICAgKiBUaGUgRE9NIHZhbHVlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIG5ldHdvcmsgY29udGFpbmVyIC0+IERPTSBub3QgQ2FudmFzIGNvb3Jkcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge1Bvc2l0aW9ufSBwb3NpdGlvbiBUaGUgRE9NIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJucyB7SWRUeXBlfSBub2RlSWQgVGhlIGFzc29jaWF0ZWQgbm9kZSBpZC5cbiAgICpcbiAgICogQG1lbWJlck9mIE5ldHdvcmtTZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0Tm9kZUF0KHZpc05ldHdvcms6IHN0cmluZywgcG9zaXRpb246IFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0Tm9kZUF0KHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGxvb2tzIHVwIHRoZSBlZGdlIGF0IHRoZSBnaXZlbiBET00gY29vcmRpbmF0ZXMgb24gdGhlIGNhbnZhcy5cbiAgICogSW5wdXQgYW5kIG91dHB1dCBhcmUgaW4gdGhlIGZvcm0gb2Yge3g6TnVtYmVyLHk6TnVtYmVyfS5cbiAgICogVGhlIERPTSB2YWx1ZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBuZXR3b3JrIGNvbnRhaW5lciAtPiBET00gbm90IENhbnZhcyBjb29yZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb24gVGhlIERPTSBwb3NpdGlvbi5cbiAgICogQHJldHVybnMge0lkVHlwZX0gZWRnZUlkIFRoZSBhc3NvY2lhdGVkIGVkZ2UgaWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldEVkZ2VBdCh2aXNOZXR3b3JrOiBzdHJpbmcsIHBvc2l0aW9uOiBQb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldEVkZ2VBdChwb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBsb29rcyB1cCB0aGUgZWRnZXMgZm9yIGEgZ2l2ZW4gbm9kZUlkLlxuICAgKiBUaGUgRE9NIHZhbHVlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIG5ldHdvcmsgY29udGFpbmVyIC0+IERPTSBub3QgQ2FudmFzIGNvb3Jkcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge0lkVHlwZX0gbm9kZUlkIFRoZSBhc3NvY2lhdGVkIG5vZGUgaWQuXG4gICAqIEByZXR1cm5zIHtJZFR5cGVbXX0gUmV0dXJuIGFycmF5IG9mIGVkZ2UgaWRzXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldENvbm5lY3RlZEVkZ2VzKHZpc05ldHdvcms6IHN0cmluZywgbm9kZUlkOiBJZFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5nZXRDb25uZWN0ZWRFZGdlcyhub2RlSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygbm9kZUlkcyBvZiB0aGUgYWxsIHRoZSBub2RlcyB0aGF0IGFyZSBkaXJlY3RseSBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgKiBJZiB5b3Ugc3VwcGx5IGFuIGVkZ2VJZCwgdmlzIHdpbGwgZmlyc3QgbWF0Y2ggdGhlIGlkIHRvIG5vZGVzLlxuICAgKiBJZiBubyBtYXRjaCBpcyBmb3VuZCwgaXQgd2lsbCBzZWFyY2ggaW4gdGhlIGVkZ2VsaXN0IGFuZCByZXR1cm4gYW4gYXJyYXk6IFtmcm9tSWQsIHRvSWRdLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSBub2RlT3JFZGdlSWQgYSBub2RlIG9yIGVkZ2UgaWRcbiAgICogQHJldHVybnMge0lkVHlwZVtdfSBSZXR1cm4gYXJyYXkgb2Ygbm9kZSBpZHNcbiAgICovXG4gIHB1YmxpYyBnZXRDb25uZWN0ZWROb2Rlcyh2aXNOZXR3b3JrOiBzdHJpbmcsIG5vZGVPckVkZ2VJZDogSWRUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0Q29ubmVjdGVkTm9kZXMobm9kZU9yRWRnZUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7QXJyYXkuPE5vZGUuaWQ+fFN0cmluZ30gW2lkc10gIC0tPiBvcHRpb25hbCwgY2FuIGJlIGFycmF5IG9mIG5vZGVJZHMsIGNhbiBiZSBzdHJpbmdcbiAgICogQHJldHVybnMge3t9fVxuICAgKi9cbiAgcHVibGljIGdldFBvc2l0aW9ucyh2aXNOZXR3b3JrOiBzdHJpbmcsIG5vZGVJZHM6IElkVHlwZVtdKSB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uZ2V0UG9zaXRpb25zKG5vZGVJZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICovXG4gIHB1YmxpYyBnZXRCb3VuZGluZ0JveCh2aXNOZXR3b3JrOiBzdHJpbmcsIG5vZGVJZDogSWRUeXBlKTogQm91bmRpbmdCb3gge1xuICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldEJvdW5kaW5nQm94KG5vZGVJZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2Rlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKi9cbiAgcHVibGljIHN0b3JlUG9zaXRpb25zKHZpc05ldHdvcms6IHN0cmluZyk6IHZvaWQge1xuICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLnN0b3JlUG9zaXRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogWW91IGNhbiBhbmltYXRlIG9yIG1vdmUgdGhlIGNhbWVyYSB1c2luZyB0aGUgbW92ZVRvIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge01vdmVUb09wdGlvbnN9IG9wdGlvbnMgT3B0aW9ucyBmb3IgbW92ZVRvIGZ1bmN0aW9uLlxuICAgKi9cbiAgcHVibGljIG1vdmVUbyh2aXNOZXR3b3JrOiBzdHJpbmcsIG1vdmVUb09wdGlvbnM6IE1vdmVUb09wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5uZXR3b3Jrc1t2aXNOZXR3b3JrXS5tb3ZlVG8obW92ZVRvT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHBoeXNpY3Mgc2ltdWxhdGlvbi5cbiAgICogVGhpcyBpcyBub3JtYWxseSBkb25lIHdoZW5ldmVyIG5lZWRlZCBhbmQgaXMgb25seSByZWFsbHkgdXNlZnVsXG4gICAqIGlmIHlvdSBzdG9wIHRoZSBzaW11bGF0aW9uIHlvdXJzZWxmIGFuZCB3aXNoIHRvIGNvbnRpbnVlIGl0IGFmdGVyd2FyZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNOZXR3b3JrIFRoZSBuZXR3b3JrIG5hbWUvaWRlbnRpZmllci5cbiAgICovXG4gIHB1YmxpYyBzdGFydFNpbXVsYXRpb24odmlzTmV0d29yazogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uc3RhcnRTaW11bGF0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBzdG9wcyB0aGUgcGh5c2ljcyBzaW11bGF0aW9uIGFuZCB0cmlnZ2VycyBhIHN0YWJpbGl6ZWQgZXZlbnQuXG4gICAqIFR0IGNhbiBiZSByZXN0YXJ0ZWQgYnkgZHJhZ2dpbmcgYSBub2RlLFxuICAgKiBhbHRlcmluZyB0aGUgZGF0YXNldCBvciBjYWxsaW5nIHN0YXJ0U2ltdWxhdGlvbigpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlzTmV0d29yayBUaGUgbmV0d29yayBuYW1lL2lkZW50aWZpZXIuXG4gICAqL1xuICBwdWJsaWMgc3RvcFNpbXVsYXRpb24odmlzTmV0d29yazogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10uc3RvcFNpbXVsYXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNjYWxlIG9mIHRoZSBuZXR3b3JrLiAxLjAgaXMgY29tcGFyaWJsZSB0byAxMDAlLCAwIGlzIHpvb21lZCBvdXQgaW5maW5pdGVseS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc05ldHdvcmsgVGhlIG5ldHdvcmsgbmFtZS9pZGVudGlmaWVyLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3duIHdoZW4gdGhlIG5ldHdvcmsgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBOZXR3b3JrU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFNjYWxlKHZpc05ldHdvcms6IHN0cmluZyk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMubmV0d29ya3NbdmlzTmV0d29ya10pIHtcbiAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtzW3Zpc05ldHdvcmtdLmdldFNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB3aXRoIGlkICR7dmlzTmV0d29ya30gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfVxufVxuIl19